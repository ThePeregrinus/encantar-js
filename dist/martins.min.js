/*!
 * MARTINS.js Free Edition version 0.1.0
 * GPU-accelerated Augmented Reality for the web
 * Copyright 2022 Alexandre Martins <alemartf(at)gmail.com> (https://github.com/alemart)
 * https://github.com/alemart/martins-js
 *
 * @license AGPL-3.0-only
 * Date: 2022-04-21T17:21:25.844Z
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Martins=t():e.Martins=t()}(self,(function(){return(()=>{var e={528:e=>{
/*!
 * Speedy Vision version 0.9.0-wip
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2022 Alexandre Martins <alemartf(at)gmail.com> (https://github.com/alemart)
 * https://github.com/alemart/speedy-vision
 *
 * @license Apache-2.0
 * Date: 2022-04-19T18:11:01.441Z
 */
var t;self,t=function(){return(()=>{var e={"./src/core/pipeline/factories/filter-factory.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineFilterFactory:()=>A});var n=i("./src/core/speedy-namespace.js"),s=i("./src/core/pipeline/nodes/filters/greyscale.js"),r=i("./src/core/pipeline/nodes/filters/gaussian-blur.js"),o=i("./src/core/pipeline/nodes/filters/simple-blur.js"),a=i("./src/core/pipeline/nodes/filters/median-blur.js"),c=i("./src/core/pipeline/nodes/filters/convolution.js"),p=i("./src/core/pipeline/nodes/filters/nightvision.js"),l=i("./src/core/pipeline/nodes/filters/normalize.js");class A extends n.SpeedyNamespace{static Greyscale(e){return new s.SpeedyPipelineNodeGreyscale(e)}static GaussianBlur(e){return new r.SpeedyPipelineNodeGaussianBlur(e)}static SimpleBlur(e){return new o.SpeedyPipelineNodeSimpleBlur(e)}static MedianBlur(e){return new a.SpeedyPipelineNodeMedianBlur(e)}static Convolution(e){return new c.SpeedyPipelineNodeConvolution(e)}static Nightvision(e){return new p.SpeedyPipelineNodeNightvision(e)}static Normalize(e){return new l.SpeedyPipelineNodeNormalize(e)}}},"./src/core/pipeline/factories/image-factory.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineImagePortalFactory:()=>A,SpeedyPipelineImageFactory:()=>d});var n=i("./src/core/speedy-namespace.js"),s=i("./src/core/pipeline/nodes/images/source.js"),r=i("./src/core/pipeline/nodes/images/sink.js"),o=i("./src/core/pipeline/nodes/images/multiplexer.js"),a=i("./src/core/pipeline/nodes/images/buffer.js"),c=i("./src/core/pipeline/nodes/images/pyramid.js"),p=i("./src/core/pipeline/nodes/images/mixer.js"),l=i("./src/core/pipeline/nodes/images/portal.js");class A extends n.SpeedyNamespace{static Source(e){return new l.SpeedyPipelineNodeImagePortalSource(e)}static Sink(e){return new l.SpeedyPipelineNodeImagePortalSink(e)}}class d extends n.SpeedyNamespace{static Source(e){return new s.SpeedyPipelineNodeImageSource(e)}static Sink(e){return new r.SpeedyPipelineNodeImageSink(e)}static Multiplexer(e){return new o.SpeedyPipelineNodeImageMultiplexer(e)}static Buffer(e){return new a.SpeedyPipelineNodeImageBuffer(e)}static Pyramid(e){return new c.SpeedyPipelineNodeImagePyramid(e)}static Mixer(e){return new p.SpeedyPipelineNodeImageMixer(e)}static get Portal(){return A}}},"./src/core/pipeline/factories/keypoint-factory.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineKeypointPortalFactory:()=>M,SpeedyPipelineKeypointFactory:()=>w});var n=i("./src/core/speedy-namespace.js"),s=i("./src/core/pipeline/nodes/keypoints/source.js"),r=i("./src/core/pipeline/nodes/keypoints/sink.js"),o=i("./src/core/pipeline/nodes/keypoints/clipper.js"),a=i("./src/core/pipeline/nodes/keypoints/border-clipper.js"),c=i("./src/core/pipeline/nodes/keypoints/buffer.js"),p=i("./src/core/pipeline/nodes/keypoints/mixer.js"),l=i("./src/core/pipeline/nodes/keypoints/shuffler.js"),A=i("./src/core/pipeline/nodes/keypoints/multiplexer.js"),d=i("./src/core/pipeline/nodes/keypoints/transformer.js"),u=i("./src/core/pipeline/nodes/keypoints/subpixel.js"),g=i("./src/core/pipeline/nodes/keypoints/detectors/fast.js"),h=i("./src/core/pipeline/nodes/keypoints/detectors/harris.js"),I=i("./src/core/pipeline/nodes/keypoints/descriptors/orb.js"),m=i("./src/core/pipeline/nodes/keypoints/trackers/lk.js"),f=i("./src/core/pipeline/nodes/keypoints/matchers/lsh-static-tables.js"),y=i("./src/core/pipeline/nodes/keypoints/matchers/lsh-knn.js"),S=i("./src/core/pipeline/nodes/keypoints/matchers/bf-knn.js"),_=i("./src/core/pipeline/nodes/keypoints/distance-filter.js"),x=i("./src/core/pipeline/nodes/keypoints/hamming-distance-filter.js"),C=i("./src/core/pipeline/nodes/keypoints/portal.js");class E extends n.SpeedyNamespace{static FAST(e){return new g.SpeedyPipelineNodeFASTKeypointDetector(e)}static Harris(e){return new h.SpeedyPipelineNodeHarrisKeypointDetector(e)}}class P extends n.SpeedyNamespace{static ORB(e){return new I.SpeedyPipelineNodeORBKeypointDescriptor(e)}}class v extends n.SpeedyNamespace{static LK(e){return new m.SpeedyPipelineNodeLKKeypointTracker(e)}}class B extends n.SpeedyNamespace{static StaticLSHTables(e){return new f.SpeedyPipelineNodeStaticLSHTables(e)}static LSHKNN(e){return new y.SpeedyPipelineNodeLSHKNNMatcher(e)}static BFKNN(e){return new S.SpeedyPipelineNodeBruteForceKNNKeypointMatcher(e)}}class M extends n.SpeedyNamespace{static Source(e){return new C.SpeedyPipelineNodeKeypointPortalSource(e)}static Sink(e){return new C.SpeedyPipelineNodeKeypointPortalSink(e)}}class w extends n.SpeedyNamespace{static get Detector(){return E}static get Descriptor(){return P}static get Tracker(){return v}static get Matcher(){return B}static get Portal(){return M}static Source(e){return new s.SpeedyPipelineNodeKeypointSource(e)}static Sink(e){return new r.SpeedyPipelineNodeKeypointSink(e)}static SinkOfTrackedKeypoints(e){return new r.SpeedyPipelineNodeTrackedKeypointSink(e)}static SinkOfMatchedKeypoints(e){return new r.SpeedyPipelineNodeMatchedKeypointSink(e)}static Clipper(e){return new o.SpeedyPipelineNodeKeypointClipper(e)}static BorderClipper(e){return new a.SpeedyPipelineNodeKeypointBorderClipper(e)}static Buffer(e){return new c.SpeedyPipelineNodeKeypointBuffer(e)}static Mixer(e){return new p.SpeedyPipelineNodeKeypointMixer(e)}static Shuffler(e){return new l.SpeedyPipelineNodeKeypointShuffler(e)}static Multiplexer(e){return new A.SpeedyPipelineNodeKeypointMultiplexer(e)}static Transformer(e){return new d.SpeedyPipelineNodeKeypointTransformer(e)}static SubpixelRefiner(e){return new u.SpeedyPipelineNodeKeypointSubpixelRefiner(e)}static DistanceFilter(e){return new _.SpeedyPipelineNodeKeypointDistanceFilter(e)}static HammingDistanceFilter(e){return new x.SpeedyPipelineNodeKeypointHammingDistanceFilter(e)}}},"./src/core/pipeline/factories/transform-factory.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineTransformFactory:()=>o});var n=i("./src/core/speedy-namespace.js"),s=i("./src/core/pipeline/nodes/transforms/perspective-warp.js"),r=i("./src/core/pipeline/nodes/transforms/resize.js");class o extends n.SpeedyNamespace{static Resize(e){return new r.SpeedyPipelineNodeResize(e)}static PerspectiveWarp(e){return new s.SpeedyPipelineNodePerspectiveWarp(e)}}},"./src/core/pipeline/factories/vector2-factory.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineVector2Factory:()=>r});var n=i("./src/core/speedy-vector.js"),s=i("./src/core/pipeline/nodes/vector2/sink.js");class r extends Function{constructor(){return super("...args","return this._create(...args)"),this.bind(this)}_create(e,t){return new n.SpeedyVector2(e,t)}Sink(e){return new s.SpeedyPipelineNodeVector2Sink(e)}}},"./src/core/pipeline/nodes/filters/convolution.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeConvolution:()=>p});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/core/speedy-size.js"),i("./src/utils/utils.js"),i("./src/utils/types.js"),i("./src/utils/errors.js")),a=(i("./src/core/speedy-promise.js"),i("./src/core/speedy-matrix.js"));const c={3:"convolution3",5:"convolution5",7:"convolution7"};class p extends n.SpeedyPipelineNode{constructor(e){super(e,1,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._kernel=a.SpeedyMatrix.Create(3,3,[0,0,0,0,1,0,0,0,0])}get kernel(){return this._kernel}set kernel(e){if(e.rows!=e.columns)throw new o.NotSupportedError("Use a square kernel");if(3!=e.rows&&5!=e.rows&&7!=e.rows)throw new o.NotSupportedError("Invalid kernel size. Supported sizes: 3x3, 5x5, 7x7");this._kernel=e}_run(e){const{image:t,format:i}=this.input().read(),n=t.width,s=t.height,r=this._tex[0],o=this._kernel.rows,a=c[o],p=this._kernel.read();e.programs.filters[a].outputs(n,s,r)(t,p),this.output().swrite(r,i)}}},"./src/core/pipeline/nodes/filters/gaussian-blur.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeGaussianBlur:()=>g});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/core/speedy-size.js")),a=i("./src/core/speedy-vector.js"),c=i("./src/utils/utils.js"),p=i("./src/utils/errors.js");i("./src/core/speedy-promise.js");const l=Object.freeze({3:[.27901008925473514,.44197982149052983,.27901008925473514],5:[.06135959781344021,.2447701955296099,.3877404133138998,.2447701955296099,.06135959781344021],7:[.03873542500847274,.11308485700794121,.2150068609928349,.26634571398150225,.2150068609928349,.11308485700794121,.03873542500847274],9:[.028532262603370988,.067234535494912,.12400932997922749,.17904386461741617,.20236001461014655,.17904386461741617,.12400932997922749,.067234535494912,.028532262603370988],11:[.022656882730580346,.04610857898527292,.08012661469398517,.11890414969751599,.15067709325491124,.16305336127546846,.15067709325491124,.11890414969751599,.08012661469398517,.04610857898527292,.022656882730580346],13:[.018815730430644363,.03447396964662016,.05657737457255748,.08317258170844948,.10952340502389682,.12918787500405662,.13649812722755,.12918787500405662,.10952340502389682,.08317258170844948,.05657737457255748,.03447396964662016,.018815730430644363],15:[.016100340991695383,.027272329212157102,.042598338587449644,.06135478775568558,.08148767614129326,.09979838342934616,.11270444144735056,.11736740487004466,.11270444144735056,.09979838342934616,.08148767614129326,.06135478775568558,.042598338587449644,.027272329212157102,.016100340991695383]}),A=new a.SpeedyVector2(0,0),d=Object.freeze({3:"convolution3x",5:"convolution5x",7:"convolution7x",9:"convolution9x",11:"convolution11x",13:"convolution13x",15:"convolution15x"}),u=Object.freeze({3:"convolution3y",5:"convolution5y",7:"convolution7y",9:"convolution9y",11:"convolution11y",13:"convolution13y",15:"convolution15y"});class g extends n.SpeedyPipelineNode{constructor(e){super(e,2,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._kernelSize=new o.SpeedySize(5,5),this._sigma=A,this._kernel={x:l[this._kernelSize.width],y:l[this._kernelSize.height]}}get kernelSize(){return this._kernelSize}set kernelSize(e){c.Utils.assert(e instanceof o.SpeedySize);const t=e.width,i=e.height;if(t<3||i<3||t>15||i>15||t%2==0||i%2==0)throw new p.NotSupportedError(`Unsupported kernel size: ${t}x${i}`);this._kernelSize=e,this._updateKernel()}get sigma(){return this._sigma}set sigma(e){c.Utils.assert(e instanceof a.SpeedyVector2,"Sigma must be a SpeedyVector2"),c.Utils.assert(e.x>=0&&e.y>=0),this._sigma=e,this._updateKernel()}_run(e){const{image:t,format:i}=this.input().read(),n=t.width,s=t.height,r=this._kernel.x,o=this._kernel.y,a=d[this._kernelSize.width],c=u[this._kernelSize.height],p=this._tex[0],l=this._tex[1];e.programs.filters[a].outputs(n,s,p)(t,r),e.programs.filters[c].outputs(n,s,l)(p,o),this.output().swrite(l,i)}_updateKernel(){this._sigma.x==A.x?this._kernel.x=l[this._kernelSize.width]:this._kernel.x=c.Utils.gaussianKernel(this._sigma.x,this._kernelSize.width,!0),this._sigma.y==A.y?this._kernel.y=l[this._kernelSize.height]:this._kernel.y=c.Utils.gaussianKernel(this._sigma.y,this._kernelSize.height,!0)}}},"./src/core/pipeline/nodes/filters/greyscale.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeGreyscale:()=>a});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/types.js"));i("./src/core/speedy-promise.js");class a extends n.SpeedyPipelineNode{constructor(e){super(e,1,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)])}_run(e){const{image:t,format:i}=this.input().read(),n=t.width,s=t.height,r=this._tex[0],a=e.programs.filters;a.rgb2grey.outputs(n,s,r),a.rgb2grey(t),this.output().swrite(r,o.ImageFormat.GREY)}}},"./src/core/pipeline/nodes/filters/median-blur.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeMedianBlur:()=>A});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/core/speedy-size.js")),a=i("./src/utils/utils.js"),c=i("./src/utils/types.js"),p=i("./src/utils/errors.js");i("./src/core/speedy-promise.js");const l={3:"median3",5:"median5",7:"median7"};class A extends n.SpeedyPipelineNode{constructor(e){super(e,1,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image).satisfying((e=>e.format===c.ImageFormat.GREY)),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._kernelSize=new o.SpeedySize(5,5)}get kernelSize(){return this._kernelSize}set kernelSize(e){a.Utils.assert(e instanceof o.SpeedySize);const t=e.width;if(3!=t&&5!=t&&7!=t)throw new p.NotSupportedError("Supported kernel sizes: 3x3, 5x5, 7x7");if(e.width!=e.height)throw new p.NotSupportedError("Use a square kernel");this._kernelSize=e}_run(e){const{image:t,format:i}=this.input().read(),n=t.width,s=t.height,r=this._kernelSize.width,o=l[r],a=this._tex[0];e.programs.filters[o].outputs(n,s,a)(t),this.output().swrite(a,i)}}},"./src/core/pipeline/nodes/filters/nightvision.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeNightvision:()=>c});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/errors.js")),a=i("./src/utils/types.js");i("./src/core/speedy-promise.js");class c extends n.SpeedyPipelineNode{constructor(e){super(e,3,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image).satisfying((e=>e.format===a.ImageFormat.RGBA||e.format===a.ImageFormat.GREY)),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._gain=.5,this._offset=.5,this._decay=0,this._quality="medium"}get gain(){return this._gain}set gain(e){this._gain=+e}get offset(){return this._offset}set offset(e){this._offset=+e}get decay(){return this._decay}set decay(e){this._decay=Math.max(0,Math.min(+e,1))}get quality(){return this._quality}set quality(e){if("high"!==e&&"medium"!==e&&"low"!==e)throw new o.IllegalArgumentError(`Invalid quality level for the Nightvision filter: "${e}"`);this._quality=e}_run(e){const{image:t,format:i}=this.input().read(),n=t.width,s=t.height,r=this._gain,o=this._offset,c=this._decay,p=this._quality,l=e.programs.filters,A=this._tex[0],d=this._tex[1],u=this._tex[2];"medium"==p?(l.illuminationMapX.outputs(n,s,A),l.illuminationMapY.outputs(n,s,d),l.illuminationMapX(t),l.illuminationMapY(A)):"high"==p?(l.illuminationMapHiX.outputs(n,s,A),l.illuminationMapHiY.outputs(n,s,d),l.illuminationMapHiX(t),l.illuminationMapHiY(A)):"low"==p&&(l.illuminationMapLoX.outputs(n,s,A),l.illuminationMapLoY.outputs(n,s,d),l.illuminationMapLoX(t),l.illuminationMapLoY(A)),i===a.ImageFormat.GREY?(l.nightvisionGreyscale.outputs(n,s,u),l.nightvisionGreyscale(t,d,r,o,c)):i===a.ImageFormat.RGBA&&(l.nightvision.outputs(n,s,u),l.nightvision(t,d,r,o,c)),this.output().swrite(u,i)}}},"./src/core/pipeline/nodes/filters/normalize.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeNormalize:()=>c});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js")),a=i("./src/utils/types.js");i("./src/core/speedy-promise.js");class c extends n.SpeedyPipelineNode{constructor(e){super(e,4,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image).satisfying((e=>e.format===a.ImageFormat.GREY)),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._minValue=0,this._maxValue=255}get minValue(){return this._minValue}set minValue(e){this._minValue=Math.max(0,Math.min(+e,255))}get maxValue(){return this._maxValue}set maxValue(e){this._maxValue=Math.max(0,Math.min(+e,255))}_run(e){const{image:t,format:i}=this.input().read(),n=t.width,s=t.height,r=this._tex[3];let o=this._minValue,c=this._maxValue;o>c&&(o=c=(o+c)/2);const p=this._scanMinMax(e,t,a.PixelComponent.GREEN);e.programs.filters.normalizeGreyscale.outputs(n,s,r),e.programs.filters.normalizeGreyscale(p,o,c),this.output().swrite(r,i)}_scanMinMax(e,t,i){const n=this._tex,s=e.programs.utils,r=t.width,c=t.height,p=0|Math.ceil(Math.log2(Math.max(r,c)));o.Utils.assert(void 0!==a.ColorComponentId[i]),s.copyComponents.outputs(r,c,n[2]),s.scanMinMax2D.outputs(r,c,n[0],n[1]);let l=s.copyComponents(t,t,a.PixelComponent.ALL,a.ColorComponentId[i]);for(let e=0;e<p;e++)l=s.scanMinMax2D(l,e);return l}}},"./src/core/pipeline/nodes/filters/simple-blur.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeSimpleBlur:()=>d});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/core/speedy-size.js")),a=i("./src/utils/utils.js"),c=(i("./src/utils/types.js"),i("./src/utils/errors.js"));i("./src/core/speedy-promise.js");const p=Object.freeze({3:new Array(3).fill(1/3),5:new Array(5).fill(.2),7:new Array(7).fill(1/7),9:new Array(9).fill(1/9),11:new Array(11).fill(1/11),13:new Array(13).fill(1/13),15:new Array(15).fill(1/15)}),l=Object.freeze({3:"convolution3x",5:"convolution5x",7:"convolution7x",9:"convolution9x",11:"convolution11x",13:"convolution13x",15:"convolution15x"}),A=Object.freeze({3:"convolution3y",5:"convolution5y",7:"convolution7y",9:"convolution9y",11:"convolution11y",13:"convolution13y",15:"convolution15y"});class d extends n.SpeedyPipelineNode{constructor(e){super(e,2,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._kernelSize=new o.SpeedySize(5,5),this._kernel={x:p[this._kernelSize.width],y:p[this._kernelSize.height]}}get kernelSize(){return this._kernelSize}set kernelSize(e){a.Utils.assert(e instanceof o.SpeedySize);const t=e.width,i=e.height;if(t<3||i<3||t>15||i>15||t%2==0||i%2==0)throw new c.NotSupportedError(`Unsupported kernel size: ${t}x${i}`);this._kernelSize=e,this._kernel.x=p[this._kernelSize.width],this._kernel.y=p[this._kernelSize.height]}_run(e){const{image:t,format:i}=this.input().read(),n=t.width,s=t.height,r=this._kernel.x,o=this._kernel.y,a=l[this._kernelSize.width],c=A[this._kernelSize.height],p=this._tex[0],d=this._tex[1];e.programs.filters[a].outputs(n,s,p)(t,r),e.programs.filters[c].outputs(n,s,d)(p,o),this.output().swrite(d,i)}}},"./src/core/pipeline/nodes/images/buffer.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeImageBuffer:()=>c});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=i("./src/utils/types.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/errors.js"));i("./src/core/speedy-promise.js");class c extends n.SpeedyPipelineNode{constructor(e){super(e,2,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._pageIndex=0,this._initialized=!1,this._previousFormat=o.ImageFormat.RGBA,this._frozen=!1}get frozen(){return this._frozen}set frozen(e){this._frozen=Boolean(e)}release(e){this._initialized=!1,super.release(e)}_run(e){const{image:t,format:i}=this.input().read(),n=this._previousFormat,s=this._tex,r=s[1-this._pageIndex],o=s[this._pageIndex];if(t.hasMipmaps())throw new a.NotSupportedError(`${this.fullName} can't bufferize a pyramid`);if(this._frozen&&this._initialized||(this._previousFormat=i,r.resize(t.width,t.height),t.copyTo(r),this._pageIndex=1-this._pageIndex),!this._initialized)return this._initialized=!0,void this.output().swrite(r,i);this.output().swrite(o,n)}}},"./src/core/pipeline/nodes/images/mixer.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeImageMixer:()=>a});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/types.js"),i("./src/core/speedy-promise.js"),i("./src/utils/errors.js"));class a extends n.SpeedyPipelineNode{constructor(e){super(e,1,[(0,r.InputPort)("in0").expects(s.SpeedyPipelineMessageType.Image),(0,r.InputPort)("in1").expects(s.SpeedyPipelineMessageType.Image),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._alpha=.5,this._beta=.5,this._gamma=0}get alpha(){return this._alpha}set alpha(e){this._alpha=+e}get beta(){return this._beta}set beta(e){this._beta=+e}get gamma(){return this._gamma}set gamma(e){this._gamma=+e}_run(e){const t=this.input("in0").read(),i=this.input("in1").read(),n=t.image,s=i.image,r=t.format,a=i.format,c=Math.max(n.width,s.width),p=Math.max(n.height,s.height),l=this._alpha,A=this._beta,d=this._gamma,u=this._tex[0];if(r!=a)throw new o.NotSupportedError("Can't mix images of different formats");e.programs.transforms.additiveMix.outputs(c,p,u),e.programs.transforms.additiveMix(n,s,l,A,d),this.output().swrite(u,r)}}},"./src/core/pipeline/nodes/images/multiplexer.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeImageMultiplexer:()=>c});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/core/speedy-media.js"),i("./src/utils/utils.js"),i("./src/utils/errors.js"));i("./src/core/speedy-promise.js");const a=["in0","in1"];class c extends n.SpeedyPipelineNode{constructor(e){super(e,0,[...a.map((e=>(0,r.InputPort)(e).expects(s.SpeedyPipelineMessageType.Image))),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._port=0}get port(){return this._port}set port(e){if(e<0||e>=a.length)throw new o.IllegalArgumentError(`Invalid port: ${e}`);this._port=0|e}_run(e){const t=this.input(a[this._port]).read();this.output().write(t)}}},"./src/core/pipeline/nodes/images/portal.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeImagePortalSink:()=>c,SpeedyPipelineNodeImagePortalSource:()=>p});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=i("./src/utils/types.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/errors.js"));i("./src/core/speedy-promise.js");class c extends n.SpeedyPipelineNode{constructor(e){super(e,1,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._format=o.ImageFormat.RGBA,this._initialized=!1}get image(){if(!this._initialized)throw new a.IllegalOperationError(`Portal error: ${this.fullName} holds no data`);return this._tex[0]}get format(){if(!this._initialized)throw new a.IllegalOperationError(`Portal error: ${this.fullName} holds no data`);return this._format}init(e){super.init(e),this._tex[0].resize(1,1).clear(),this._format=o.ImageFormat.RGBA,this._initialized=!0}release(e){this._initialized=!1,super.release(e)}_run(e){const{image:t,format:i}=this.input().read(),n=this._tex[0];if(t.hasMipmaps())throw new a.NotSupportedError(`${this.fullName} can't store a pyramid`);this._format=i,n.resize(t.width,t.height),t.copyTo(n)}}class p extends n.SpeedyPipelineSourceNode{constructor(e){super(e,0,[(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._source=null}get source(){return this._source}set source(e){if(null!==e&&!(e instanceof c))throw new a.IllegalArgumentError(`Incompatible source for ${this.fullName}`);this._source=e}_run(e){if(null==this._source)throw new a.IllegalOperationError(`${this.fullName} has no source`);this.output().swrite(this._source.image,this._source.format)}}},"./src/core/pipeline/nodes/images/pyramid.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeImagePyramid:()=>p});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/globals.js"));i("./src/utils/types.js"),i("./src/core/speedy-promise.js");const a=o.PYRAMID_MAX_LEVELS,c=2*a;class p extends n.SpeedyPipelineNode{constructor(e){super(e,c+1,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)])}_run(e){const{image:t,format:i}=this.input().read(),n=this._tex[0],s=e.programs.pyramids;let r=t.width,o=t.height;const p=1+Math.floor(Math.log2(Math.max(r,o))),l=new Array(c+1);for(let e=c;e>=1;e--)l[e-1]=this._tex[e];l[0].resize(r,o),t.copyTo(l[0]);const A=Math.min(p,a);for(let t=1;t<A;t++){const i=Math.max(1,r>>>1),n=Math.max(1,o>>>1),c=t-1+a;s.smoothX.outputs(r,o,l[c])(l[t-1]),s.smoothY.outputs(r,o,l[t-1])(l[c]),s.downsample2.outputs(i,n,l[t])(l[t-1]),e.gl.flush(),r=i,o=n}n.resize(t.width,t.height),n.clear(),t.copyTo(n),n.generateMipmaps(l.slice(0,A)),this.output().swrite(n,i)}}},"./src/core/pipeline/nodes/images/sink.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeImageSink:()=>l});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/core/speedy-media.js")),a=(i("./src/core/speedy-media-source.js"),i("./src/utils/utils.js")),c=i("./src/utils/types.js"),p=i("./src/core/speedy-promise.js");class l extends n.SpeedyPipelineSinkNode{constructor(e="image"){super(e,0,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._bitmap=null,this._format=c.ImageFormat.RGBA}export(){return a.Utils.assert(null!=this._bitmap),o.SpeedyMedia.load(this._bitmap,{format:this._format},!1)}_run(e){const{image:t,format:i}=this.input().read();return new p.SpeedyPromise((n=>{const s=e.renderToCanvas(t);createImageBitmap(s,0,s.height-t.height,t.width,t.height).then((e=>{this._bitmap=e,this._format=i,n()}))}))}}},"./src/core/pipeline/nodes/images/source.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeImageSource:()=>c});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/core/speedy-media.js")),a=(i("./src/utils/utils.js"),i("./src/utils/types.js"),i("./src/utils/errors.js"));i("./src/core/speedy-promise.js");class c extends n.SpeedyPipelineSourceNode{constructor(e){super(e,2,[(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._media=null,this._textureIndex=0}get media(){return this._media}set media(e){if(null!==e&&!(e instanceof o.SpeedyMedia))throw new a.IllegalArgumentError(`Not a SpeedyMedia: ${e}`);this._media=e}_run(e){if(null==this._media)throw new a.IllegalOperationError(`Did you forget to set the media of ${this.fullName}?`);this._textureIndex=(this._textureIndex+1)%this._tex.length;const t=this._tex[this._textureIndex];e.upload(this._media._source,t),this.output().swrite(t,this._media._format)}}},"./src/core/pipeline/nodes/keypoints/border-clipper.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointBorderClipper:()=>l});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),r=i("./src/core/pipeline/pipeline-message.js"),o=i("./src/core/pipeline/pipeline-portbuilder.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/core/speedy-size.js")),c=i("./src/core/speedy-vector.js"),p=(i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/errors.js"));i("./src/utils/globals.js"),i("./src/core/speedy-promise.js");class l extends n.SpeedyPipelineNode{constructor(e){super(e,5,[(0,o.InputPort)().expects(r.SpeedyPipelineMessageType.Keypoints),(0,o.OutputPort)().expects(r.SpeedyPipelineMessageType.Keypoints)]),this._imageSize=new a.SpeedySize(0,0),this._borderSize=new c.SpeedyVector2(0,0)}get imageSize(){return this._imageSize}set imageSize(e){this._imageSize=e}get borderSize(){return this._borderSize}set borderSize(e){this._borderSize=e}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:r}=this.input().read(),o=e.programs.keypoints,a=this._imageSize,c=this._borderSize,l=a.width,A=a.height,d=c.x,u=c.x,g=c.y,h=c.y,I=this._tex;if(0==l||0==A)throw new p.IllegalOperationError("BorderClipper: did you forget to set the image size?");const m=s.SpeedyPipelineNodeKeypointDetector.encoderCapacity(i,n,r),f=Math.max(1,Math.ceil(Math.sqrt(m)));o.clipBorder.outputs(r,r,I[0]),o.mixKeypointsInit.outputs(f,f,I[1]),o.mixKeypointsSort.outputs(f,f,I[2],I[3]),o.mixKeypointsApply.outputs(r,r,I[4]);let y=o.clipBorder(l,A,g,u,h,d,t,i,n,r),S=o.mixKeypointsInit(y,i,n,r,m);for(let e=1;e<m;e*=2)S=o.mixKeypointsSort(S,e);y=o.mixKeypointsApply(S,y,i,n,r),this.output().swrite(y,i,n,r)}}},"./src/core/pipeline/nodes/keypoints/buffer.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointBuffer:()=>o});var n=i("./src/core/pipeline/pipeline-node.js"),s=(i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),i("./src/core/pipeline/pipeline-message.js")),r=i("./src/core/pipeline/pipeline-portbuilder.js");i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/core/speedy-promise.js");class o extends n.SpeedyPipelineNode{constructor(e){super(e,2,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Keypoints),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Keypoints)]),this._pageIndex=0,this._initialized=!1,this._previousDescriptorSize=0,this._previousExtraSize=0,this._previousEncoderLength=0,this._frozen=!1}get frozen(){return this._frozen}set frozen(e){this._frozen=Boolean(e)}release(e){this._initialized=!1,super.release(e)}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:s}=this.input().read(),r=this._previousDescriptorSize,o=this._previousExtraSize,a=this._previousEncoderLength,c=this._tex,p=c[1-this._pageIndex],l=c[this._pageIndex];if(this._frozen&&this._initialized||(this._previousDescriptorSize=i,this._previousExtraSize=n,this._previousEncoderLength=s,p.resize(s,s),t.copyTo(p),this._pageIndex=1-this._pageIndex),!this._initialized)return this._initialized=!0,void this.output().swrite(p,i,n,s);this.output().swrite(l,r,o,a)}}},"./src/core/pipeline/nodes/keypoints/clipper.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointClipper:()=>p});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),r=i("./src/core/pipeline/pipeline-message.js"),o=i("./src/core/pipeline/pipeline-portbuilder.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/globals.js"));i("./src/core/speedy-promise.js");const c=a.MAX_ENCODER_CAPACITY;class p extends n.SpeedyPipelineNode{constructor(e){super(e,4,[(0,o.InputPort)().expects(r.SpeedyPipelineMessageType.Keypoints),(0,o.OutputPort)().expects(r.SpeedyPipelineMessageType.Keypoints)]),this._size=c}get size(){return this._size}set size(e){this._size=Math.max(0,Math.min(0|e,c))}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:r}=this.input().read(),o=e.programs.keypoints,a=this._size,c=this._tex,p=this._tex[3],l=s.SpeedyPipelineNodeKeypointDetector.encoderCapacity(i,n,r),A=Math.ceil(l/32),d=32*A,u=Math.min(l,a),g=s.SpeedyPipelineNodeKeypointDetector.encoderLength(u,i,n);o.sortCreatePermutation.outputs(32,A,c[0]);let h=o.sortCreatePermutation(t,i,n,r);const I=Math.ceil(Math.log2(d));o.sortMergePermutation.outputs(32,A,c[1],c[2]);for(let e=1;e<=I;e++){const t=1<<e,i=e<<1;h=o.sortMergePermutation(h,t,i)}o.sortApplyPermutation.outputs(g,g,p),o.sortApplyPermutation(h,u,t,i,n),this.output().swrite(p,i,n,g)}}},"./src/core/pipeline/nodes/keypoints/descriptors/descriptor.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointDescriptor:()=>o});var n=i("./src/core/pipeline/pipeline-node.js"),s=(i("./src/core/pipeline/pipeline-portbuilder.js"),i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/core/pipeline/nodes/keypoints/detectors/detector.js")),r=i("./src/utils/utils.js");class o extends n.SpeedyPipelineNode{constructor(e,t=0,i){super(e,t+1,i)}_allocateDescriptors(e,t,i,n,o,a){r.Utils.assert(t>=0&&i>=0),r.Utils.assert(n>=0&&n%4==0&&o===i);const c=a.width,p=s.SpeedyPipelineNodeKeypointDetector.encoderCapacity(t,i,c),l=s.SpeedyPipelineNodeKeypointDetector.encoderLength(p,n,o),A=this._tex[this._tex.length-1];return e.programs.keypoints.allocateDescriptors.outputs(l,l,A)(a,t,i,c,n,o,l)}}},"./src/core/pipeline/nodes/keypoints/descriptors/orb.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeORBKeypointDescriptor:()=>c}),i("./src/core/pipeline/pipeline-node.js");var n=i("./src/core/pipeline/pipeline-message.js"),s=i("./src/core/pipeline/pipeline-portbuilder.js"),r=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/types.js")),o=(i("./src/utils/utils.js"),i("./src/core/speedy-promise.js"),i("./src/core/pipeline/nodes/keypoints/detectors/detector.js")),a=i("./src/core/pipeline/nodes/keypoints/descriptors/descriptor.js");class c extends a.SpeedyPipelineNodeKeypointDescriptor{constructor(e){super(e,3,[(0,s.InputPort)("image").expects(n.SpeedyPipelineMessageType.Image).satisfying((e=>e.format===r.ImageFormat.GREY)),(0,s.InputPort)("keypoints").expects(n.SpeedyPipelineMessageType.Keypoints),(0,s.OutputPort)().expects(n.SpeedyPipelineMessageType.Keypoints)])}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:s}=this.input("keypoints").read(),r=this.input("image").read().image,a=this._tex,c=this._tex[2],p=o.SpeedyPipelineNodeKeypointDetector.encoderCapacity(i,n,s),l=Math.max(1,Math.ceil(Math.sqrt(p))),A=e.programs.keypoints.orbOrientation.outputs(l,l,a[0])(r,t,i,n,s),d=e.programs.keypoints.transferOrientation.outputs(s,s,a[1])(A,t,i,n,s),u=this._allocateDescriptors(e,i,n,32,n,d),g=u.width,h=e.programs.keypoints.orbDescriptor.outputs(g,g,c)(r,u,n,g);this.output().swrite(h,32,n,g)}}},"./src/core/pipeline/nodes/keypoints/detectors/detector.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointDetector:()=>c,SpeedyPipelineNodeMultiscaleKeypointDetector:()=>p});var n=i("./src/core/pipeline/pipeline-node.js"),s=(i("./src/core/pipeline/pipeline-message.js"),i("./src/core/pipeline/pipeline-portbuilder.js"),i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js")),r=(i("./src/utils/utils.js"),i("./src/core/speedy-promise.js"),i("./src/utils/globals.js"));const o=r.MAX_ENCODER_CAPACITY,a=r.DEFAULT_ENCODER_CAPACITY;class c extends n.SpeedyPipelineNode{constructor(e,t=0,i){super(e,t+0,i),this._capacity=a,this._oldWrapS=0,this._tex16=new Array(2).fill(null)}init(e){super.init(e),this._oldWrapS=this._setupSpecialTexture(e.gl.TEXTURE_WRAP_S,e.gl.REPEAT),this._allocateTex16(e),e.subscribe(this._allocateTex16,this,e)}release(e){e.unsubscribe(this._allocateTex16,this),this._deallocateTex16(e),this._setupSpecialTexture(e.gl.TEXTURE_WRAP_S,this._oldWrapS),super.release(e)}_setupSpecialTexture(e,t){}get capacity(){return this._capacity}set capacity(e){this._capacity=Math.min(Math.max(0,0|e),o)}_encodeKeypoints(e,t,i,n=0,s=0){const r=this._capacity,o=c.encoderLength(r,n,s),a=1<<(Math.ceil(Math.log2(t.width*t.height))>>>1),p=Math.ceil(t.width*t.height/a),l=Math.max(a,p),A=e.programs.keypoints;A.initLookupTable.outputs(a,p,this._tex16[1]),A.sortLookupTable.outputs(a,p,this._tex16[0],this._tex16[1]),A.encodeKeypoints.outputs(o,o,i);let d=A.initLookupTable(t);for(let e=1;e<l;e*=2)d=A.sortLookupTable(d,e,a,p);return A.encodeKeypoints(t,d,a,n,s,o,r)}_encodeKeypointsOLD(e,t,i,n=0,s=0){const r=this._capacity,o=c.encoderLength(r,n,s),a=t.width,p=t.height,l=[a,p],A=this._tex.slice(this._tex.length-0),d=e.programs.keypoints,u=A.pop();d.encodeKeypointSkipOffsets.outputs(a,p,A[0]),d.encodeKeypointLongSkipOffsets.outputs(a,p,A[1],A[0]),d.encodeKeypointPositions.outputs(o,o,A[2],A[3]),d.encodeKeypointProperties.outputs(o,o,i),t=e.programs.utils.copy.outputs(a,p,u)(t);let g=d.encodeKeypointSkipOffsets(t,l);for(let e=0;e<2;e++)g=d.encodeKeypointLongSkipOffsets(g,l);let h=A[3].clear();for(let e=0;e<4;e++)h=d.encodeKeypointPositions(g,l,e,4,r,h,n,s,o);return d.encodeKeypointProperties(t,h,n,s,o)}_encodeZeroKeypoints(e,t,i=0,n=0){const s=c.encoderLength(0,i,n),r=e.programs.keypoints;return r.encodeNullKeypoints.outputs(s,s,t),r.encodeNullKeypoints()}_allocateTex16(e){const t=e.gl;for(let e=0;e<this._tex16.length;e++)this._tex16[e]=new s.SpeedyDrawableTexture(t,1,1,t.RGBA_INTEGER,t.RGBA16UI,t.UNSIGNED_SHORT,t.NEAREST,t.CLAMP_TO_EDGE)}_deallocateTex16(e){for(let e=0;e<this._tex16.length;e++)this._tex16[e]=this._tex16[e].release()}static encoderLength(e,t,i){const n=e*Math.ceil((r.MIN_KEYPOINT_SIZE+t+i)/4);return Math.max(r.MIN_ENCODER_LENGTH,Math.ceil(Math.sqrt(n)))}static encoderCapacity(e,t,i){const n=Math.ceil((r.MIN_KEYPOINT_SIZE+e+t)/4),s=i*i;return Math.floor(s/n)}}class p extends c{constructor(e,t,i){super(e,t,i),this._levels=1,this._scaleFactor=1.4142135623730951}get levels(){return this._levels}set levels(e){this._levels=Math.max(1,0|e)}get scaleFactor(){return this._scaleFactor}set scaleFactor(e){this._scaleFactor=Math.max(1,Math.min(+e,2))}}},"./src/core/pipeline/nodes/keypoints/detectors/fast.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeFASTKeypointDetector:()=>p});var n=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/types.js")),a=(i("./src/utils/utils.js"),i("./src/utils/errors.js")),c=(i("./src/core/speedy-promise.js"),i("./src/utils/globals.js"));class p extends n.SpeedyPipelineNodeMultiscaleKeypointDetector{constructor(e){super(e,5,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image).satisfying((e=>e.format===o.ImageFormat.GREY)),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Keypoints)]),this._threshold=20}get threshold(){return this._threshold}set threshold(e){this._threshold=Math.max(0,Math.min(0|e,255))}_run(e){const{image:t,format:i}=this.input().read(),n=t.width,s=t.height,r=this._tex,o=this._capacity,p=this._threshold,l=Math.log2(this.scaleFactor),A=this.levels;if(1!=A&&!t.hasMipmaps())throw new a.IllegalOperationError(`Expected a pyramid in ${this.fullName}`);if(0==o){const t=this._encodeZeroKeypoints(e,r[4]),i=t.width;return void this.output().swrite(t,0,0,i)}e.programs.keypoints.fast9_16.outputs(n,s,r[0],r[1]),e.programs.keypoints.nonmaxSpace.outputs(n,s,r[2]);let d=r[1].clear(),u=Math.max(1,Math.min(A,c.PYRAMID_MAX_LEVELS/l|0));for(let i=l*(u-1);u-- >0;i-=l)d=e.programs.keypoints.fast9_16(d,t,i,p);d=e.programs.keypoints.nonmaxSpace(d),A>1&&(d=e.programs.keypoints.nonmaxScaleSimple.outputs(n,s,r[1])(d,t,l));let g=this._encodeKeypoints(e,d,r[3]);const h=g.width;A>1&&(g=e.programs.keypoints.refineScaleFAST916.outputs(h,h,r[4])(t,l,g,0,0,h,p)),this.output().swrite(g,0,0,h)}}},"./src/core/pipeline/nodes/keypoints/detectors/harris.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeHarrisKeypointDetector:()=>d});var n=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/types.js")),a=i("./src/core/speedy-size.js"),c=i("./src/utils/utils.js"),p=i("./src/utils/errors.js"),l=(i("./src/core/speedy-promise.js"),i("./src/utils/globals.js"));const A=Object.freeze({1:"harris1",3:"harris3",5:"harris5",7:"harris7"});class d extends n.SpeedyPipelineNodeMultiscaleKeypointDetector{constructor(e){super(e,6,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image).satisfying((e=>e.format===o.ImageFormat.GREY)),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Keypoints)]),this._windowSize=new a.SpeedySize(3,3),this._quality=.1}get quality(){return this._quality}set quality(e){this._quality=Math.max(0,Math.min(+e,1))}get windowSize(){return this._windowSize}set windowSize(e){const t=e.width;if(t!=e.height||1!=t&&3!=t&&5!=t&&7!=t)throw new p.IllegalArgumentError(`Invalid window: ${e}. Acceptable sizes: 1x1, 3x3, 5x5, 7x7`);this._windowSize=e}_run(e){const{image:t,format:i}=this.input().read(),n=t.width,s=t.height,r=this._capacity,o=this._quality,a=this._windowSize.width,d=this.levels,u=Math.log2(this.scaleFactor),g=d>1?this.scaleFactor:1,h=e.programs.keypoints[A[a]],I=this._tex;if(1!=d&&!t.hasMipmaps())throw new p.IllegalOperationError(`Expected a pyramid in ${this.fullName}`);if(0==r){const t=this._encodeZeroKeypoints(e,I[5]),i=t.width;return void this.output().swrite(t,0,0,i)}h.outputs(n,s,I[0],I[1]),e.programs.utils.sobelDerivatives.outputs(n,s,I[2]),e.programs.keypoints.nonmaxSpace.outputs(n,s,I[3]);let m=I[1].clear(),f=Math.max(1,Math.min(d,l.PYRAMID_MAX_LEVELS/u|0));for(let i=u*(f-1);f-- >0;i-=u){const n=c.Utils.gaussianKernel(g*(1+i),a);m=h(m,t,e.programs.utils.sobelDerivatives(t,i),i,u,n),m=e.programs.keypoints.nonmaxSpace(m)}if(d>1){const i=e.programs.keypoints.laplacian.outputs(n,s,I[0])(m,t,u,0);m=e.programs.keypoints.nonmaxScale.outputs(n,s,I[2])(m,t,i,u)}e.programs.keypoints.harrisScoreFindMax.outputs(n,s,I[0],I[1]),f=Math.ceil(Math.log2(Math.max(n,s)));let y=m;for(let t=0;t<f;t++)y=e.programs.keypoints.harrisScoreFindMax(y,t);m=e.programs.keypoints.harrisScoreCutoff.outputs(n,s,y==I[0]?I[1]:I[0])(m,y,o);let S=this._encodeKeypoints(e,m,I[4]);const _=S.width;d>1&&(S=e.programs.keypoints.refineScaleLoG.outputs(_,_,I[5])(t,u,S,0,0,_)),this.output().swrite(S,0,0,_)}}},"./src/core/pipeline/nodes/keypoints/distance-filter.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointDistanceFilter:()=>c});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/core/speedy-promise.js"),i("./src/core/speedy-matrix.js"),i("./src/utils/errors.js")),a=i("./src/utils/globals.js");class c extends n.SpeedyPipelineNode{constructor(e){super(e,1,[(0,r.InputPort)("in").expects(s.SpeedyPipelineMessageType.Keypoints),(0,r.InputPort)("reference").expects(s.SpeedyPipelineMessageType.Keypoints),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Keypoints)]),this._threshold=a.MAX_TEXTURE_LENGTH+1}get threshold(){return this._threshold}set threshold(e){this._threshold=Math.max(0,+e)}_run(e){const t=this.input("in").read(),i=this.input("reference").read(),n=this._threshold;if(t.descriptorSize!=i.descriptorSize||t.extraSize!=i.extraSize)throw new o.IllegalOperationError("The distance filter requires two compatible shapes of keypoint streams");const s=this._tex[0],r=Math.max(t.encoderLength,i.encoderLength),a=t.descriptorSize,c=t.extraSize;e.programs.keypoints.distanceFilter.outputs(r,r,s)(t.encodedKeypoints,t.encoderLength,i.encodedKeypoints,i.encoderLength,a,c,r,n),this.output().swrite(s,a,c,r)}}},"./src/core/pipeline/nodes/keypoints/hamming-distance-filter.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointHammingDistanceFilter:()=>p});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/core/speedy-promise.js"),i("./src/core/speedy-matrix.js"),i("./src/utils/errors.js")),a=i("./src/utils/globals.js");const c={32:"hammingDistanceFilter32",64:"hammingDistanceFilter64"};class p extends n.SpeedyPipelineNode{constructor(e){super(e,1,[(0,r.InputPort)("in").expects(s.SpeedyPipelineMessageType.Keypoints).satisfying((e=>e.descriptorSize>0)),(0,r.InputPort)("reference").expects(s.SpeedyPipelineMessageType.Keypoints).satisfying((e=>e.descriptorSize>0)),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Keypoints)]),this._threshold=8*a.MAX_DESCRIPTOR_SIZE}get threshold(){return this._threshold}set threshold(e){this._threshold=Math.max(0,0|e)}_run(e){const t=this.input("in").read(),i=this.input("reference").read(),n=this._threshold;if(t.descriptorSize!=i.descriptorSize||t.extraSize!=i.extraSize)throw new o.IllegalOperationError("The Hamming distance filter requires two compatible shapes of keypoint streams");if(!Object.prototype.hasOwnProperty.call(c,t.descriptorSize))throw new o.NotSupportedError(`Hamming distance filter - invalid descriptor size: ${t.descriptorSize}`);const s=this._tex[0],r=Math.max(t.encoderLength,i.encoderLength),a=t.descriptorSize,p=t.extraSize,l=c[t.descriptorSize];e.programs.keypoints[l].outputs(r,r,s)(t.encodedKeypoints,t.encoderLength,i.encodedKeypoints,i.encoderLength,a,p,r,n),this.output().swrite(s,a,p,r)}}},"./src/core/pipeline/nodes/keypoints/matchers/bf-knn.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeBruteForceKNNKeypointMatcher:()=>p});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/errors.js"));i("./src/core/speedy-promise.js");const c={32:"bfMatcher32",64:"bfMatcher64"};class p extends n.SpeedyPipelineNode{constructor(e){super(e,6,[(0,r.InputPort)("keypoints").expects(s.SpeedyPipelineMessageType.Keypoints).satisfying((e=>e.descriptorSize>0)),(0,r.InputPort)("database").expects(s.SpeedyPipelineMessageType.Keypoints).satisfying((e=>e.descriptorSize>0)),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.KeypointMatches)]),this._matchesPerKeypoint=1}get k(){return this._matchesPerKeypoint}set k(e){this._matchesPerKeypoint=Math.max(1,0|e)}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:s}=this.input("keypoints").read(),r=this.input("database").read(),p=this._tex[0],l=this._tex[1],A=this._tex[2],d=this._tex[3],u=this._tex[4],g=this._tex[5],h=this._matchesPerKeypoint,I=e.programs.keypoints;if(i!==r.descriptorSize)throw new a.IllegalArgumentError(`Incompatible descriptors in ${this.fullName}`);if(!Object.prototype.hasOwnProperty.call(c,i))throw new a.NotSupportedError(`Unsupported descriptor size (${i}) in ${this.fullName}`);const m=I[c[i]],f=o.SpeedyPipelineNodeKeypointDetector.encoderCapacity(i,n,s),y=o.SpeedyPipelineNodeKeypointDetector.encoderCapacity(r.descriptorSize,r.extraSize,r.encoderLength),S=m.definedConstant("NUMBER_OF_KEYPOINTS_PER_PASS"),_=Math.ceil(y/S),x=Math.max(1,Math.ceil(Math.sqrt(f))),C=Math.max(1,Math.ceil(Math.sqrt(f*h)));I.bfMatcherTransfer.outputs(C,C,u,g),I.bfMatcherInitCandidates.outputs(x,x,A),I.bfMatcherInitFilters.outputs(x,x,d),m.outputs(x,x,p,l);let E=g.clear(),P=I.bfMatcherInitFilters();for(let o=0;o<h;o++){let a=I.bfMatcherInitCandidates();for(let o=0;o<_;o++)a=m(a,P,x,r.encodedKeypoints,r.descriptorSize,r.extraSize,r.encoderLength,t,i,n,s,o),e.gl.flush();h>1&&a.copyTo(P),E=I.bfMatcherTransfer(E,a,h,o)}this.output().swrite(E,h)}}},"./src/core/pipeline/nodes/keypoints/matchers/lsh-knn.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeLSHKNNMatcher:()=>d});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-lsh.js")),c=(i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js")),p=i("./src/utils/errors.js");i("./src/core/speedy-promise.js");const l={fastest:0,default:1,demanding:2},A=a.LSH_ACCEPTABLE_DESCRIPTOR_SIZES.reduce(((e,t)=>(e[t]=(e=>{return t=t=>{return i=i=>`lshKnn${e}h${t}lv${i}`,[0,1,2].reduce(((e,t)=>(e[t]=i(t),e)),{});var i},a.LSH_ACCEPTABLE_HASH_SIZES.reduce(((e,i)=>(e[i]=t(i),e)),{});var t})(t),e)),{});class d extends n.SpeedyPipelineNode{constructor(e){super(e,6,[(0,r.InputPort)("keypoints").expects(s.SpeedyPipelineMessageType.Keypoints).satisfying((e=>e.descriptorSize>0)),(0,r.InputPort)("lsh").expects(s.SpeedyPipelineMessageType.LSHTables),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.KeypointMatches)]),this._k=1,this._quality="default"}get k(){return this._k}set k(e){this._k=Math.max(1,0|e)}get quality(){return this._quality}set quality(e){if(!Object.prototype.hasOwnProperty.call(l,e))throw new p.IllegalArgumentError(`Invalid quality level: "${e}"`);this._quality=e}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:s}=this.input("keypoints").read(),r=this.input("lsh").read().lsh,a=e.programs.keypoints,d=r.tables,u=r.descriptorDB,g=d.width,h=u.width,I=r.tableCount,m=r.hashSize,f=r.bucketCapacity,y=r.bucketsPerTable,S=r.sequences,_=this._tex[0],x=this._tex[1],C=this._tex[2],E=this._tex[3],P=this._tex[4],v=this._tex[5],B=l[this._quality],M=this._k;if(i!==r.descriptorSize)throw new p.IllegalArgumentError(`Can't match different types of descriptors in ${this.fullName}`);c.Utils.assert(null!=A[i]),c.Utils.assert(null!=A[i][m]),c.Utils.assert(null!=A[i][m][B]);const w=o.SpeedyPipelineNodeKeypointDetector.encoderCapacity(i,n,s),b=Math.max(1,Math.ceil(Math.sqrt(w*M)));let Q=v;a.lshKnnTransfer.outputs(b,b,P,v);const k=Math.max(1,Math.ceil(Math.sqrt(w)));a.lshKnnInitCandidates.outputs(k,k,_),a.lshKnnInitFilters.outputs(k,k,E);const D=a[A[i][m][B]];D.outputs(k,k,x,C),D.setUBO("LSHSequences",S),Q.clear(),a.lshKnnInitFilters();for(let r=0;r<M;r++){let o=a.lshKnnInitCandidates();for(let r=0;r<I;r++)o=D(o,E,k,d,u,r,f,y,g,h,t,i,n,s),e.gl.flush();o.copyTo(E),Q=a.lshKnnTransfer(Q,o,M,r)}this.output().swrite(Q,M)}}},"./src/core/pipeline/nodes/keypoints/matchers/lsh-static-tables.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeStaticLSHTables:()=>p});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=i("./src/core/speedy-keypoint.js"),a=(i("./src/core/speedy-keypoint-descriptor.js"),i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/errors.js")),c=(i("./src/utils/utils.js"),i("./src/core/speedy-promise.js"),i("./src/gpu/speedy-lsh.js"));class p extends n.SpeedyPipelineSourceNode{constructor(e){super(e,2,[(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.LSHTables)]),this._keypoints=[],this._keypointsCopy=[],this._numberOfTables=c.LSH_DEFAULT_NUMBER_OF_TABLES,this._hashSize=c.LSH_DEFAULT_HASH_SIZE,this._lsh=null}get keypoints(){return this._keypoints}set keypoints(e){if(!Array.isArray(e)||e.find((e=>!(e instanceof o.SpeedyKeypoint))))throw new a.IllegalArgumentError("Static LSH tables: an invalid set of keypoints has been provided");this._keypoints!==e&&(this._keypoints=e,this._keypointsCopy=e.slice(0),this._lsh=null)}get numberOfTables(){return this._numberOfTables}set numberOfTables(e){if(!c.LSH_ACCEPTABLE_NUMBER_OF_TABLES.includes(e))throw new a.IllegalArgumentError(`Invalid number of tables: ${e}. Acceptable values: ${c.LSH_ACCEPTABLE_NUMBER_OF_TABLES.join(", ")}`);e!==this._numberOfTables&&(this._numberOfTables=0|e,this._lsh=null)}get hashSize(){return this._hashSize}set hashSize(e){if(!c.LSH_ACCEPTABLE_HASH_SIZES.includes(e))throw new a.IllegalArgumentError(`Invalid hash size: ${e}. Acceptable values: ${c.LSH_ACCEPTABLE_HASH_SIZES.join(", ")}`);e!==this._hashSize&&(this._hashSize=0|e,this._lsh=null)}_run(e){null==this._lsh&&(this._lsh=this._train()),this.output().swrite(this._lsh)}_train(){const e=this._keypointsCopy,t=this._numberOfTables,i=this._hashSize;if(e.find((e=>null==e.descriptor)))throw new a.IllegalOperationError("Static LSH tables: can't train the model with no keypoint descriptors!");const n=e.map((e=>e.descriptor.data)),s=this._tex[0],r=this._tex[1];return new c.SpeedyLSH(s,r,n,t,i)}}},"./src/core/pipeline/nodes/keypoints/mixer.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointMixer:()=>c});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),r=i("./src/core/pipeline/pipeline-message.js"),o=i("./src/core/pipeline/pipeline-portbuilder.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/errors.js"));i("./src/utils/globals.js"),i("./src/core/speedy-promise.js");class c extends n.SpeedyPipelineNode{constructor(e){super(e,5,[(0,o.InputPort)("in0").expects(r.SpeedyPipelineMessageType.Keypoints),(0,o.InputPort)("in1").expects(r.SpeedyPipelineMessageType.Keypoints),(0,o.OutputPort)().expects(r.SpeedyPipelineMessageType.Keypoints)])}_run(e){const t=this.input("in0").read(),i=this.input("in1").read(),n=t.descriptorSize,r=t.extraSize,o=e.programs.keypoints,c=this._tex;if(t.descriptorSize!==i.descriptorSize||t.extraSize!=t.extraSize)throw new a.IllegalOperationError("Can't merge two sets of keypoints that have different formats");const p=s.SpeedyPipelineNodeKeypointDetector.encoderCapacity(t.descriptorSize,t.extraSize,t.encoderLength),l=s.SpeedyPipelineNodeKeypointDetector.encoderCapacity(i.descriptorSize,i.extraSize,i.encoderLength),A=p+l,d=s.SpeedyPipelineNodeKeypointDetector.encoderLength(A,n,r),u=Math.max(1,Math.ceil(Math.sqrt(A)));o.mixKeypointsPreInit.outputs(d,d,c[0]),o.mixKeypointsInit.outputs(u,u,c[1]),o.mixKeypointsSort.outputs(u,u,c[2],c[3]),o.mixKeypointsApply.outputs(d,d,c[4]);let g=o.mixKeypointsPreInit(t.encodedKeypoints,i.encodedKeypoints,t.encoderLength,i.encoderLength,p,l,n,r,d),h=o.mixKeypointsInit(g,n,r,d,A);for(let e=1;e<A;e*=2)h=o.mixKeypointsSort(h,e);g=o.mixKeypointsApply(h,g,n,r,d),this.output().swrite(g,n,r,d)}}},"./src/core/pipeline/nodes/keypoints/multiplexer.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointMultiplexer:()=>c});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/core/speedy-media.js"),i("./src/utils/utils.js"),i("./src/utils/errors.js"));i("./src/core/speedy-promise.js");const a=["in0","in1"];class c extends n.SpeedyPipelineNode{constructor(e){super(e,0,[...a.map((e=>(0,r.InputPort)(e).expects(s.SpeedyPipelineMessageType.Keypoints))),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Keypoints)]),this._port=0}get port(){return this._port}set port(e){if(e<0||e>=a.length)throw new o.IllegalArgumentError(`Invalid port: ${e}`);this._port=0|e}_run(e){const t=this.input(a[this._port]).read();this.output().write(t)}}},"./src/core/pipeline/nodes/keypoints/portal.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointPortalSink:()=>c,SpeedyPipelineNodeKeypointPortalSource:()=>p});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),o=i("./src/core/pipeline/pipeline-portbuilder.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/errors.js"));i("./src/core/speedy-promise.js");class c extends n.SpeedyPipelineNode{constructor(e){super(e,1,[(0,o.InputPort)().expects(s.SpeedyPipelineMessageType.Keypoints)]),this._descriptorSize=0,this._extraSize=0,this._encoderLength=0,this._initialized=!1}get encodedKeypoints(){if(!this._initialized)throw new a.IllegalOperationError(`Portal error: ${this.fullName} holds no data`);return this._tex[0]}get descriptorSize(){if(!this._initialized)throw new a.IllegalOperationError(`Portal error: ${this.fullName} holds no data`);return this._descriptorSize}get extraSize(){if(!this._initialized)throw new a.IllegalOperationError(`Portal error: ${this.fullName} holds no data`);return this._extraSize}get encoderLength(){if(!this._initialized)throw new a.IllegalOperationError(`Portal error: ${this.fullName} holds no data`);return this._encoderLength}init(e){super.init(e);const t=r.SpeedyPipelineNodeKeypointDetector.encoderLength(0,0,0);this._tex[0].resize(t,t).clearToColor(1,1,1,1),this._descriptorSize=this._extraSize=0,this._encoderLength=t,this._initialized=!0}release(e){this._initialized=!1,super.release(e)}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:s}=this.input().read(),r=this._tex[0];r.resize(t.width,t.height),t.copyTo(r),this._descriptorSize=i,this._extraSize=n,this._encoderLength=s}}class p extends n.SpeedyPipelineSourceNode{constructor(e){super(e,0,[(0,o.OutputPort)().expects(s.SpeedyPipelineMessageType.Keypoints)]),this._source=null}get source(){return this._source}set source(e){if(null!==e&&!(e instanceof c))throw new a.IllegalArgumentError(`Incompatible source for ${this.fullName}`);this._source=e}_run(e){if(null==this._source)throw new a.IllegalOperationError(`${this.fullName} has no source`);this.output().swrite(this._source.encodedKeypoints,this._source.descriptorSize,this._source.extraSize,this._source.encoderLength)}}},"./src/core/pipeline/nodes/keypoints/shuffler.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointShuffler:()=>c});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),r=i("./src/core/pipeline/pipeline-message.js"),o=i("./src/core/pipeline/pipeline-portbuilder.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/utils/utils.js"));i("./src/core/speedy-promise.js");class c extends n.SpeedyPipelineNode{constructor(e){super(e,6,[(0,o.InputPort)().expects(r.SpeedyPipelineMessageType.Keypoints),(0,o.OutputPort)().expects(r.SpeedyPipelineMessageType.Keypoints)]),this._maxKeypoints=Number.NaN}get maxKeypoints(){return this._maxKeypoints}set maxKeypoints(e){Number.isNaN(e)?this._maxKeypoints=Number.NaN:this._maxKeypoints=Math.max(0,0|e)}_run(e){let{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:r}=this.input().read();const o=s.SpeedyPipelineNodeKeypointDetector.encoderCapacity(i,n,r),a=this._maxKeypoints,c=e.programs.keypoints.shuffle.definedConstant("PERMUTATION_MAXLEN"),p=Math.min(c,o),l=this._generatePermutation(p,c);t=e.programs.keypoints.shuffle.setUBO("Permutation",l).outputs(r,r,this._tex[0])(t,i,n,r),e.programs.keypoints.mixKeypointsInit.outputs(r,r,this._tex[1]),e.programs.keypoints.mixKeypointsSort.outputs(r,r,this._tex[2],this._tex[3]),e.programs.keypoints.mixKeypointsApply.outputs(r,r,this._tex[4]);let A=e.programs.keypoints.mixKeypointsInit(t,i,n,r,o);for(let t=1;t<o;t*=2)A=e.programs.keypoints.mixKeypointsSort(A,t);if(t=e.programs.keypoints.mixKeypointsApply(A,t,i,n,r),!Number.isNaN(a)&&a<o){const o=s.SpeedyPipelineNodeKeypointDetector.encoderLength(a,i,n);t=e.programs.keypoints.clip.outputs(o,o,this._tex[5])(t,i,n,r,a),r=o}this.output().swrite(t,i,n,r)}_generatePermutation(e,t=e){const i=new Int32Array(t),n=i.subarray(0,e).fill(-1),s=a.Utils.shuffle(a.Utils.range(e));for(let t=0,i=0;t<e;t++)if(n[t]<0){do{n[t]=s[i++]}while(n[t]<t);n[n[t]]=t}return i}}},"./src/core/pipeline/nodes/keypoints/sink.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointSink:()=>f,SpeedyPipelineNodeTrackedKeypointSink:()=>y,SpeedyPipelineNodeMatchedKeypointSink:()=>S});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),r=i("./src/core/pipeline/pipeline-message.js"),o=i("./src/core/pipeline/pipeline-portbuilder.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture-reader.js")),c=(i("./src/gpu/speedy-texture.js"),i("./src/core/speedy-media.js"),i("./src/utils/utils.js")),p=(i("./src/utils/types.js"),i("./src/utils/errors.js")),l=i("./src/core/speedy-promise.js"),A=i("./src/core/speedy-keypoint.js"),d=i("./src/core/speedy-keypoint-descriptor.js"),u=i("./src/core/speedy-keypoint-match.js"),g=i("./src/core/speedy-vector.js"),h=i("./src/utils/globals.js");const I=new Uint8Array([]);class m extends n.SpeedyPipelineSinkNode{constructor(e="keypoints",t=0,i=[]){super(e,t+2,i),this._keypoints=[],this._textureReader=new a.SpeedyTextureReader,this._page=0,this._turbo=!1,this._includeDiscarded=!1}get turbo(){return this._turbo}set turbo(e){this._turbo=Boolean(e)}get includeDiscarded(){return this._includeDiscarded}set includeDiscarded(e){this._includeDiscarded=Boolean(e)}init(e){super.init(e),this._textureReader.init(e)}release(e){this._textureReader.release(e),super.release(e)}export(){return l.SpeedyPromise.resolve(this._keypoints)}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:s}=this.input().read();return this._download(e,t,i,n,s)}_download(e,t,i,n,s){const r=this._turbo,o=(a=s)>1?1<<Math.ceil(Math.log2(a)):1;var a;const c=Math.ceil(s*s/o),p=this._tex[this._tex.length-1-this._page];return e.programs.utils.copyKeypoints.outputs(o,c,p)(t),this._page=1-this._page,this._textureReader.readPixelsAsync(p,0,0,p.width,p.height,r).then((e=>{this._keypoints=this._decode(e,i,n,o,c)}))}_decode(e,t,i,n,s){const r=h.MIN_KEYPOINT_SIZE+t+i,o=h.LOG2_PYRAMID_MAX_SCALE,a=h.PYRAMID_MAX_LEVELS,l=Math.PI/255,A=[],d=this._includeDiscarded;let u,g,m,f,y,S,_,x,C=I,E=I;if(t%4!=0||i%4!=0)throw new p.IllegalArgumentError(`Invalid descriptorSize (${t}) / extraSize (${i})`);const P=n*s*4,v=e.byteLength;v!=P&&c.Utils.warning(`Expected ${P} bytes when decoding a set of keypoints, found ${v}`),t+i>0&&(e=new Uint8Array(e));for(let n=0;n<v&&(u=e[n+1]<<8|e[n],g=e[n+3]<<8|e[n+2],m=e[n+5]<<8|e[n+4],f=e[n+7]<<8|e[n+6],65535!=u||65535!=g);n+=r)u+g+m+f!=0?i>0&&(E=e.subarray(8+n,8+n+i),E.byteLength<i)?c.Utils.warning(`KeypointSink: expected ${i} extra bytes when decoding the ${n/r}-th keypoint, found ${E.byteLength} instead`):t>0&&(C=e.subarray(8+n+i,8+n+i+t),C.byteLength<t)?c.Utils.warning(`KeypointSink: expected ${t} descriptor bytes when decoding the ${n/r}-th keypoint, found ${C.byteLength} instead`):(u/=h.FIX_RESOLUTION,g/=h.FIX_RESOLUTION,y=e[n+4]<255?-o+(o+a)*e[n+4]/255:0,S=(2*e[n+5]-255)*l,_=c.Utils.decodeFloat16(f),x=this._createKeypoint(u,g,y,S,_,C,E),A.push(x)):d&&A.push(null);return A}_createKeypoint(e,t,i,n,s,r,o){throw new p.AbstractMethodError}_allocateExtra(e,t,i,n,r,o,a){c.Utils.assert(0===r),c.Utils.assert(o===n&&a>0&&a%4==0);const p=i.width,l=s.SpeedyPipelineNodeKeypointDetector.encoderCapacity(n,r,p),A=s.SpeedyPipelineNodeKeypointDetector.encoderLength(l,o,a);return e.programs.keypoints.allocateExtra.outputs(A,A,t)(i,n,r,p,o,a,A)}}class f extends m{constructor(e="keypoints"){super(e,0,[(0,o.InputPort)().expects(r.SpeedyPipelineMessageType.Keypoints)])}_createKeypoint(e,t,i,n,s,r,o){const a=r.byteLength>0?new d.SpeedyKeypointDescriptor(r):null;return new A.SpeedyKeypoint(e,t,i,n,s,a)}}class y extends m{constructor(e="keypoints"){super(e,2,[(0,o.InputPort)().expects(r.SpeedyPipelineMessageType.Keypoints).satisfying((e=>0==e.extraSize)),(0,o.InputPort)("flow").expects(r.SpeedyPipelineMessageType.Vector2)])}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:s}=this.input().read(),{vectors:r}=this.input("flow").read(),o=i,a=this._allocateExtra(e,this._tex[0],t,i,n,o,4),c=a.width,p=e.programs.keypoints.transferToExtra.outputs(c,c,this._tex[1])(r,r.width,a,o,4,c);return this._download(e,p,o,4,c)}_createKeypoint(e,t,i,n,s,r,o){const a=r.byteLength,p=(o.byteLength,a>0?new d.SpeedyKeypointDescriptor(r):null),l=c.Utils.decodeFloat16(o[1]<<8|o[0]),u=c.Utils.decodeFloat16(o[3]<<8|o[2]),h=new g.SpeedyVector2(l,u);return new A.SpeedyTrackedKeypoint(e,t,i,n,s,p,h)}}class S extends m{constructor(e="keypoints"){super(e,2,[(0,o.InputPort)().expects(r.SpeedyPipelineMessageType.Keypoints).satisfying((e=>0==e.extraSize)),(0,o.InputPort)("matches").expects(r.SpeedyPipelineMessageType.KeypointMatches)])}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:s}=this.input().read(),{encodedMatches:r,matchesPerKeypoint:o}=this.input("matches").read(),a=i,c=4*o,p=this._allocateExtra(e,this._tex[0],t,i,n,a,c),l=p.width,A=e.programs.keypoints.transferToExtra.outputs(l,l,this._tex[1])(r,r.width,p,a,c,l);return this._download(e,A,a,c,l)}_createKeypoint(e,t,i,n,s,r,o){const a=r.byteLength,c=o.byteLength,p=a>0?new d.SpeedyKeypointDescriptor(r):null,l=c/4,g=new Array(l);for(let e=0;e<l;e++){const t=4*e,i=o[t]|o[t+1]<<8|o[t+2]<<16|o[t+3]<<24,n=new u.SpeedyKeypointMatch(i&h.MATCH_INDEX_MASK,i>>>h.MATCH_INDEX_BITS);g[e]=n}return new A.SpeedyMatchedKeypoint(e,t,i,n,s,p,g)}}},"./src/core/pipeline/nodes/keypoints/source.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointSource:()=>d});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),r=i("./src/core/pipeline/pipeline-message.js"),o=i("./src/core/pipeline/pipeline-portbuilder.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js")),c=i("./src/utils/errors.js"),p=(i("./src/core/speedy-promise.js"),i("./src/core/speedy-keypoint.js"),i("./src/utils/globals.js"));const l=1024,A=4*Float32Array.BYTES_PER_ELEMENT;class d extends n.SpeedyPipelineSourceNode{constructor(e){super(e,2,[(0,o.OutputPort)().expects(r.SpeedyPipelineMessageType.Keypoints)]),this._keypoints=[],this._buffer=d._createUploadBuffer(l),this._capacity=p.DEFAULT_ENCODER_CAPACITY}get keypoints(){return this._keypoints}set keypoints(e){if(!Array.isArray(e))throw new c.IllegalArgumentError("Not an array of keypoints");this._keypoints=e}get capacity(){return this._capacity}set capacity(e){this._capacity=Math.min(Math.max(0,0|e),p.MAX_ENCODER_CAPACITY)}_run(e){const t=this._keypoints,i=this._capacity,n=Math.min(t.length,i),r=Math.max(1,Math.ceil(n/l)),o=this._buffer,a=e.programs.keypoints.uploadKeypoints,c=s.SpeedyPipelineNodeKeypointDetector.encoderLength(i,0,0);a.outputs(c,c,this._tex[0],this._tex[1]);let p=0,A=a.clear();for(let e=0;e<r;e++){const e=p+Math.min(l,n-p);a.setUBO("KeypointBuffer",d._fillUploadBuffer(o,t,p,e)),A=a(A,p,e,0,0,c),p=e}this.output().swrite(A,0,0,c)}static _createUploadBuffer(e){const t=new ArrayBuffer(A*e);return a.Utils.assert(t.byteLength<=16384),new Float32Array(t)}static _fillUploadBuffer(e,t,i,n){const s=n-i;for(let n=0;n<s;n++){const s=t[i+n],r=void 0!==s.position,o=4*n;e[o]=+(r?s.position.x:s.x)||0,e[o+1]=+(r?s.position.y:s.y)||0,e[o+2]=+s.lod||0,e[o+3]=+s.score||0}return e}}},"./src/core/pipeline/nodes/keypoints/subpixel.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointSubpixelRefiner:()=>l});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),r=i("./src/core/pipeline/pipeline-message.js"),o=i("./src/core/pipeline/pipeline-portbuilder.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/types.js")),c=(i("./src/utils/utils.js"),i("./src/utils/errors.js"));i("./src/core/speedy-promise.js");const p=Object.freeze({quadratic1d:"subpixelQuadratic1d",taylor2d:"subpixelTaylor2d","bicubic-upsample":"subpixelBicubic","bilinear-upsample":"subpixelBilinear"});class l extends n.SpeedyPipelineNode{constructor(e){super(e,2,[(0,o.InputPort)("image").expects(r.SpeedyPipelineMessageType.Image).satisfying((e=>e.format===a.ImageFormat.GREY)),(0,o.InputPort)("keypoints").expects(r.SpeedyPipelineMessageType.Keypoints),(0,o.OutputPort)().expects(r.SpeedyPipelineMessageType.Keypoints),(0,o.OutputPort)("displacements").expects(r.SpeedyPipelineMessageType.Vector2)]),this._method="quadratic1d",this._maxIterations=6,this._epsilon=.1}get method(){return this._method}set method(e){if(!Object.prototype.hasOwnProperty.call(p,e))throw new c.IllegalArgumentError(`Invalid method: "${e}"`);this._method=e}get maxIterations(){return this._maxIterations}set maxIterations(e){this._maxIterations=Math.max(0,+e)}get epsilon(){return this._epsilon}set epsilon(e){this._epsilon=Math.max(0,+e)}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:r}=this.input("keypoints").read(),{image:o,format:a}=this.input("image").read(),c=this._tex,l=p[this._method],A=this._maxIterations,d=this._epsilon,u=s.SpeedyPipelineNodeKeypointDetector.encoderCapacity(i,n,r),g=Math.max(1,Math.ceil(Math.sqrt(u))),h=e.programs.keypoints[l].outputs(g,g,c[0])(o,t,i,n,r,A,d),I=e.programs.keypoints.transferFlow.outputs(r,r,c[1])(h,t,i,n,r);this.output().swrite(I,i,n,r),this.output("displacements").swrite(h)}}},"./src/core/pipeline/nodes/keypoints/trackers/lk.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeLKKeypointTracker:()=>h});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/nodes/keypoints/detectors/detector.js"),r=i("./src/core/pipeline/pipeline-message.js"),o=i("./src/core/pipeline/pipeline-portbuilder.js"),a=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/types.js")),c=i("./src/core/speedy-size.js"),p=i("./src/utils/utils.js"),l=i("./src/utils/errors.js"),A=(i("./src/core/speedy-promise.js"),i("./src/utils/globals.js"));const d=new c.SpeedySize(11,11),u=Math.min(3,A.PYRAMID_MAX_LEVELS),g={3:"lk3",5:"lk5",7:"lk7",9:"lk9",11:"lk11",13:"lk13",15:"lk15",17:"lk17",19:"lk19",21:"lk21"};class h extends n.SpeedyPipelineNode{constructor(e){super(e,3,[(0,o.InputPort)("previousImage").expects(r.SpeedyPipelineMessageType.Image).satisfying((e=>e.format===a.ImageFormat.GREY)),(0,o.InputPort)("nextImage").expects(r.SpeedyPipelineMessageType.Image).satisfying((e=>e.format===a.ImageFormat.GREY)),(0,o.InputPort)("previousKeypoints").expects(r.SpeedyPipelineMessageType.Keypoints),(0,o.OutputPort)().expects(r.SpeedyPipelineMessageType.Keypoints),(0,o.OutputPort)("flow").expects(r.SpeedyPipelineMessageType.Vector2)]),this._windowSize=d,this._levels=u,this._discardThreshold=1e-4,this._numberOfIterations=30,this._epsilon=.01}get windowSize(){return this._windowSize}set windowSize(e){if(e.width!=e.height)throw new l.NotSupportedError(`LK: window ${this._windowSize.toString()} is not square!`);if(!Object.prototype.hasOwnProperty.call(g,e.width)){const e=Object.keys(g).sort(((e,t)=>e-t)).map((e=>e+"x"+e)).join(", ");throw new l.NotSupportedError(`LK: window of size ${this._windowSize.toString()} is not supported! Supported sizes: ${e}`)}this._windowSize=e}get levels(){return this._levels}set levels(e){p.Utils.assert(e>=1&&e<=A.PYRAMID_MAX_LEVELS),this._levels=0|e}get discardThreshold(){return this._discardThreshold}set discardThreshold(e){p.Utils.assert(e>=0),this._discardThreshold=+e}get numberOfIterations(){return this._numberOfIterations}set numberOfIterations(e){p.Utils.assert(e>=1),this._numberOfIterations=0|e}get epsilon(){return this._epsilon}set epsilon(e){p.Utils.assert(e>=0),this._epsilon=+e}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:r}=this.input("previousKeypoints").read(),o=this.input("previousImage").read().image,a=this.input("nextImage").read().image,c=t,p=this._levels,A=this._windowSize.width,d=this._numberOfIterations,u=this._discardThreshold,h=this._epsilon,I=e.programs.keypoints,m=this._tex;if(!(1==p||o.hasMipmaps()&&a.hasMipmaps()))throw new l.IllegalOperationError("LK: a pyramid is required if levels > 1");if(o.width!==a.width||o.height!==a.height)throw new l.IllegalOperationError("LK: can't use input images of different size");const f=I[g[A]],y=s.SpeedyPipelineNodeKeypointDetector.encoderCapacity(i,n,r),S=Math.max(1,Math.ceil(Math.sqrt(y)));f.outputs(S,S,m[0],m[1]);let _=f.clear();for(let e=p-1;e>=0;e--)_=f(_,c,a,o,e,p,d,u,h,i,n,r);I.transferFlow.outputs(r,r,m[2]);const x=I.transferFlow(_,c,i,n,r);this.output().swrite(x,i,n,r),this.output("flow").swrite(_)}}},"./src/core/pipeline/nodes/keypoints/transformer.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeKeypointTransformer:()=>c});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/core/speedy-promise.js"),i("./src/core/speedy-matrix.js")),a=i("./src/utils/errors.js");class c extends n.SpeedyPipelineNode{constructor(e){super(e,1,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Keypoints),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Keypoints)]),this._transform=o.SpeedyMatrix.Create(3,3,[1,0,0,0,1,0,0,0,1])}get transform(){return this._transform}set transform(e){if(3!=e.rows||3!=e.columns)throw new a.IllegalArgumentError(`Not a 3x3 transformation matrix: ${e}`);this._transform=e}_run(e){const{encodedKeypoints:t,descriptorSize:i,extraSize:n,encoderLength:s}=this.input().read(),r=this._tex[0],o=this._transform.read();e.programs.keypoints.applyHomography.outputs(t.width,t.height,r)(o,t,i,n,s),this.output().swrite(r,i,n,s)}}},"./src/core/pipeline/nodes/transforms/perspective-warp.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodePerspectiveWarp:()=>p});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/types.js"),i("./src/core/speedy-promise.js"),i("./src/utils/errors.js")),a=i("./src/core/speedy-matrix.js");const c=[0,0,0,0,0,0,0,0,1];class p extends n.SpeedyPipelineNode{constructor(e){super(e,1,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._transform=a.SpeedyMatrix.Create(3,3,[1,0,0,0,1,0,0,0,1])}get transform(){return this._transform}set transform(e){if(3!=e.rows||3!=e.columns)throw new o.IllegalArgumentError(`Not a 3x3 transformation matrix: ${e}`);this._transform=e}_run(e){const{image:t,format:i}=this.input().read(),n=t.width,s=t.height,r=this._tex[0],o=this._transform.read(),a=this._inverse3(o),p=!Number.isNaN(a[0]);e.programs.transforms.warpPerspective.outputs(n,s,r),e.programs.transforms.warpPerspective(t,p?a:c),this.output().swrite(r,i)}_inverse3(e,t=1e-6){const i=e[0],n=e[1],s=e[2],r=e[3],o=e[4],a=e[5],c=e[6],p=e[7],l=e[8],A=l*o-a*p,d=l*r-a*c,u=p*r-o*c,g=i*A-n*d+s*u;if(Math.abs(g)<t)e.fill(Number.NaN,0,9);else{const t=1/g;e[0]=A*t,e[1]=-(l*n-s*p)*t,e[2]=(a*n-s*o)*t,e[3]=-d*t,e[4]=(l*i-s*c)*t,e[5]=-(a*i-s*r)*t,e[6]=u*t,e[7]=-(p*i-n*c)*t,e[8]=(o*i-n*r)*t}return e}}},"./src/core/pipeline/nodes/transforms/resize.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeResize:()=>p});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js"),i("./src/utils/errors.js")),a=(i("./src/utils/types.js"),i("./src/core/speedy-size.js")),c=i("./src/core/speedy-vector.js");i("./src/core/speedy-promise.js");class p extends n.SpeedyPipelineNode{constructor(e){super(e,1,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Image),(0,r.OutputPort)().expects(s.SpeedyPipelineMessageType.Image)]),this._size=new a.SpeedySize(0,0),this._scale=new c.SpeedyVector2(1,1),this._method="bilinear"}get size(){return this._size}set size(e){this._size=e}get scale(){return this._scale}set scale(e){this._scale=e}get method(){return this._method}set method(e){if("nearest"!==e&&"bilinear"!==e)throw new o.IllegalArgumentError(`Invalid method method: "${e}"`);this._method=e}_run(e){const{image:t,format:i}=this.input().read(),n=t.width,s=t.height,r=this._tex[0],o=this._method,a=this._size.width||Math.max(1,this._scale.x*n),c=this._size.height||Math.max(1,this._scale.y*s);"bilinear"==o?e.programs.transforms.resizeBilinear.outputs(a,c,r)(t):"nearest"==o&&e.programs.transforms.resizeNearest.outputs(a,c,r)(t),this.output().swrite(r,i)}}},"./src/core/pipeline/nodes/vector2/sink.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNodeVector2Sink:()=>A});var n=i("./src/core/pipeline/pipeline-node.js"),s=i("./src/core/pipeline/pipeline-message.js"),r=i("./src/core/pipeline/pipeline-portbuilder.js"),o=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture-reader.js")),a=(i("./src/gpu/speedy-texture.js"),i("./src/utils/utils.js")),c=i("./src/core/speedy-promise.js"),p=i("./src/core/speedy-vector.js");const l=e=>e>1?1<<Math.ceil(Math.log2(e)):1;class A extends n.SpeedyPipelineSinkNode{constructor(e="vec2"){super(e,2,[(0,r.InputPort)().expects(s.SpeedyPipelineMessageType.Vector2)]),this._vectors=[],this._textureReader=new o.SpeedyTextureReader,this._page=0,this._turbo=!1}get turbo(){return this._turbo}set turbo(e){this._turbo=Boolean(e)}init(e){super.init(e),this._textureReader.init(e)}release(e){this._textureReader.release(e),super.release(e)}export(){return c.SpeedyPromise.resolve(this._vectors)}_run(e){const{vectors:t}=this.input().read(),i=this._turbo,n=t.width,s=l(n),r=l(Math.ceil(n*n/s)),o=this._tex[this._page];return e.programs.utils.copy2DVectors.outputs(s,r,o)(t),this._page=1-this._page,this._textureReader.readPixelsAsync(o,0,0,o.width,o.height,i).then((e=>{this._vectors=A._decode(e,s,r)}))}static _decode(e,t,i){const n=[];let s=0,r=0,o=0,c=0;const l=t*i*4,A=Math.min(e.length,l);for(let t=0;t<A&&(r=e[t+1]<<8|e[t],s=e[t+3]<<8|e[t+2],65535!=r||65535!=s);t+=4)65280==r&&65280==s||(o=a.Utils.decodeFloat16(r),c=a.Utils.decodeFloat16(s),n.push(new p.SpeedyVector2(o,c)));return n}}},"./src/core/pipeline/pipeline-message.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineMessageType:()=>o,SpeedyPipelineMessage:()=>a,SpeedyPipelineMessageWithNothing:()=>c,SpeedyPipelineMessageWithImage:()=>p,SpeedyPipelineMessageWithKeypoints:()=>l,SpeedyPipelineMessageWith2DVectors:()=>A,SpeedyPipelineMessageWithLSHTables:()=>d,SpeedyPipelineMessageWithKeypointMatches:()=>u});var n=i("./src/utils/utils.js"),s=i("./src/utils/types.js"),r=i("./src/utils/errors.js");i("./src/gpu/speedy-texture.js"),i("./src/gpu/speedy-lsh.js");const o=Object.freeze({Nothing:Symbol("Nothing"),Image:Symbol("Image"),Keypoints:Symbol("Keypoints"),Vector2:Symbol("Vector2"),LSHTables:Symbol("LSHTables"),KeypointMatches:Symbol("KeypointMatches")});class a{constructor(e){this._type=e}get type(){return this._type}hasType(e){return this._type===e}isEmpty(){return this.hasType(o.Nothing)}toString(){return`message of type ${Object.keys(o).find((e=>o[e]===this.type))}`}set(...e){throw new r.AbstractMethodError}static create(e){return function(e){return new g[e]}(e)}}class c extends a{constructor(){super(o.Nothing)}set(){return this}}class p extends a{constructor(){super(o.Image),this._image=null,this._format=s.ImageFormat.RGBA}set(e,t=s.ImageFormat.RGBA){return this._image=e,this._format=t,this}get image(){return this._image}get format(){return this._format}}class l extends a{constructor(){super(o.Keypoints),this._encodedKeypoints=null,this._descriptorSize=0,this._extraSize=0,this._encoderLength=1}set(e,t,i,s){return this._encodedKeypoints=e,this._descriptorSize=0|t,this._extraSize=0|i,this._encoderLength=0|s,n.Utils.assert(this._descriptorSize>=0&&this._extraSize>=0),n.Utils.assert(this._encoderLength===this._encodedKeypoints.width,"Invalid encoderLength"),n.Utils.assert(this._encodedKeypoints.width===this._encodedKeypoints.height,"Invalid encodedKeypoints texture"),this}get encodedKeypoints(){return this._encodedKeypoints}get descriptorSize(){return this._descriptorSize}get extraSize(){return this._extraSize}get encoderLength(){return this._encoderLength}}class A extends a{constructor(){super(o.Vector2),this._vectors=null}set(e){return this._vectors=e,this}get vectors(){return this._vectors}}class d extends a{constructor(){super(o.LSHTables),this._lsh=null}set(e){return this._lsh=e,this}get lsh(){return this._lsh}}class u extends a{constructor(){super(o.KeypointMatches),this._encodedMatches=null,this._matchesPerKeypoint=1}set(e,t){return this._encodedMatches=e,this._matchesPerKeypoint=0|t,n.Utils.assert(this._matchesPerKeypoint>0),this}get encodedMatches(){return this._encodedMatches}get matchesPerKeypoint(){return this._matchesPerKeypoint}}const g=Object.freeze({[o.Nothing]:c,[o.Image]:p,[o.Keypoints]:l,[o.Vector2]:A,[o.LSHTables]:d,[o.KeypointMatches]:u})},"./src/core/pipeline/pipeline-node.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelineNode:()=>A,SpeedyPipelineSourceNode:()=>d,SpeedyPipelineSinkNode:()=>u});var n=i("./src/utils/utils.js"),s=i("./src/utils/globals.js"),r=(i("./src/core/speedy-promise.js"),i("./src/utils/errors.js")),o=i("./src/core/pipeline/pipeline-port.js"),a=(i("./src/core/pipeline/pipeline-portbuilder.js"),i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/gpu/speedy-texture-reader.js"));function c(e){return e.reduce(((e,t)=>(e[t.name]=t,e)),Object.create(null))}function p(e){return e.reduce(((e,t)=>(e[t.name]=t,e)),Object.create(null))}let l=!1;class A{constructor(e=(()=>Math.random().toString(16).substr(2))(),t=0,i=[]){this._name=String(e),this._tex=new Array(t).fill(null);const n=i.map((e=>e.build(this))),s=n.filter((e=>e.isInputPort())),o=n.filter((e=>e.isOutputPort()));if(this._inputPorts=c(s),this._outputPorts=p(o),0==this._name.length)throw new r.IllegalArgumentError(`Invalid name "${this._name}" for node ${this.fullName}`);if(0==i.length)throw new r.IllegalArgumentError(`No ports have been found in node ${this.fullName}`)}get name(){return this._name}get fullName(){return`${this.constructor.name}[${this.name}]`}input(e=o.SpeedyPipelineInputPort.DEFAULT_NAME){if(e in this._inputPorts)return this._inputPorts[e];throw new r.IllegalArgumentError(`Can't find input port ${e} in node ${this.fullName}`)}output(e=o.SpeedyPipelineOutputPort.DEFAULT_NAME){if(e in this._outputPorts)return this._outputPorts[e];throw new r.IllegalArgumentError(`Can't find output port ${e} in node ${this.fullName}`)}execute(e){let t;for(t in this._outputPorts)this._outputPorts[t].clearMessage();for(t in this._inputPorts)this._inputPorts[t].pullMessage(this.fullName);const i=this._run(e);if(void 0!==i)return i.then((()=>{for(t in this._outputPorts)n.Utils.assert(this._outputPorts[t].hasMessage(),`Did you forget to write data to the output port ${t} of ${this.fullName}?`)}));for(t in this._outputPorts)n.Utils.assert(this._outputPorts[t].hasMessage(),`Did you forget to write data to the output port ${t} of ${this.fullName}?`)}_run(e){throw new r.AbstractMethodError}init(e){e.subscribe(this._allocateWorkTextures,this,e),this._allocateWorkTextures(e)}release(e){this._deallocateWorkTextures(e),e.unsubscribe(this._allocateWorkTextures,this)}clearPorts(){let e;for(e in this._inputPorts)this._inputPorts[e].clearMessage();for(e in this._outputPorts)this._outputPorts[e].clearMessage()}inputNodes(){const e=[];for(const t in this._inputPorts){const i=this._inputPorts[t];null!=i.incomingLink&&e.push(i.incomingLink.node)}return e}isSource(){return!1}isSink(){return!1}_allocateWorkTextures(e){for(let t=0;t<this._tex.length;t++)this._tex[t]=e.texturePool.allocate()}_deallocateWorkTextures(e){for(let t=this._tex.length-1;t>=0;t--)this._tex[t]=e.texturePool.free(this._tex[t])}_inspect(e,t){const i=new a.SpeedyTextureReader;i.init(e);const n=i.readPixelsSync(t);return i.release(e),new Uint8Array(n)}_inspect32(e,t){return n.Utils.assert(s.LITTLE_ENDIAN),new Uint32Array(this._inspect(e,t).buffer)}_visualize(e,t){const i=e.renderToCanvas(t);l||(document.body.appendChild(i),l=!0)}}class d extends A{constructor(e,t,i){super(e,t,i),n.Utils.assert(0==Object.keys(this._inputPorts).length)}isSource(){return!0}}class u extends A{constructor(e,t,i){super(e,t,i),n.Utils.assert(0==Object.keys(this._outputPorts).length)}export(){throw new r.AbstractMethodError}isSink(){return!0}}},"./src/core/pipeline/pipeline-port.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelinePort:()=>c,SpeedyPipelineOutputPort:()=>p,SpeedyPipelineInputPort:()=>l});var n=i("./src/utils/utils.js"),s=i("./src/utils/errors.js"),r=(i("./src/core/pipeline/pipeline-portspec.js"),i("./src/core/pipeline/pipeline-message.js"));i("./src/core/pipeline/pipeline-node.js");const o=/^[a-z][a-zA-Z0-9]*$/,a=new r.SpeedyPipelineMessageWithNothing;class c{constructor(e,t,i){this._name=String(e),this._spec=t,this._node=i,this._message=a,n.Utils.assert(o.test(this._name),`Port name "${this._name}" is not acceptable`)}get name(){return this._name}get node(){return this._node}connectTo(e){throw new s.AbstractMethodError}isInputPort(){throw new s.AbstractMethodError}isOutputPort(){return!this.isInputPort()}clearMessage(){this._message=a}hasMessage(){return!this._message.isEmpty()}read(){if(this._message.isEmpty())throw new s.IllegalOperationError(`Can't read from port ${this.name}: nothing to read`);return this._message}write(e){throw new s.NotSupportedError(`Can't write ${e} to port ${this.name}: unsupported operation`)}static get DEFAULT_NAME(){throw new s.AbstractMethodError}}class p extends c{constructor(e,t,i){super(e,t,i),this._cachedMessage=null}connectTo(e){if(!e.isInputPort())throw new s.IllegalArgumentError(`Can't connect output port ${this.name} to port ${e.name}: expected an input port`);e.connectTo(this)}isInputPort(){return!1}write(e){if(!this._spec.accepts(e))throw new s.IllegalArgumentError(`Can't write ${e} to port ${this.name}. ${this._spec}`);this._message=e}swrite(...e){null==this._cachedMessage&&(this._cachedMessage=r.SpeedyPipelineMessage.create(this._spec.expectedMessageType)),this.write(this._cachedMessage.set(...e))}static get DEFAULT_NAME(){return"out"}}class l extends c{constructor(e,t,i){super(e,t,i),this._incomingLink=null}get incomingLink(){return this._incomingLink}connectTo(e){if(!e.isOutputPort())throw new s.IllegalArgumentError(`Can't connect input port ${this.name} of "${this.node.fullName}" to input port ${e.name} of "${e.node.fullName}": expected an output port`);if(!this._spec.isCompatibleWith(e._spec))throw new s.IllegalArgumentError(`Can't connect port ${this.name} of "${this.node.fullName}" to port ${e.name} of "${e.node.fullName}": incompatible types`);this._incomingLink=e}disconnect(){this._incomingLink=null}isInputPort(){return!0}pullMessage(e=""){const t=e.length>0?`${this.name} of ${e}`:this.name;if(null==this._incomingLink)throw new s.IllegalOperationError(`No incoming link for input port ${t}`);const i=this._incomingLink.read();if(!this._spec.accepts(i))throw new s.IllegalArgumentError(`Can't receive ${i} at port ${t}: ${this._spec}`);return this._message=i}static get DEFAULT_NAME(){return"in"}}},"./src/core/pipeline/pipeline-portbuilder.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelinePortBuilder:()=>a,InputPort:()=>c,OutputPort:()=>p});var n=i("./src/utils/utils.js"),s=i("./src/core/pipeline/pipeline-port.js"),r=i("./src/core/pipeline/pipeline-portspec.js"),o=i("./src/core/pipeline/pipeline-message.js");i("./src/core/pipeline/pipeline-node.js");class a{constructor(e,t){this._class=e,this._name=String(t),this._type=o.SpeedyPipelineMessageType.Nothing,this._messageConstraint=void 0}expects(e){return n.Utils.assert(this._type==o.SpeedyPipelineMessageType.Nothing),n.Utils.assert(e!=o.SpeedyPipelineMessageType.Nothing),this._type=e,this}satisfying(e){return n.Utils.assert(this._type!=o.SpeedyPipelineMessageType.Nothing,"You must first declare what type of message this port expects"),n.Utils.assert(void 0===this._messageConstraint),n.Utils.assert("function"==typeof e),this._messageConstraint=e,this}build(e){const t=new r.SpeedyPipelinePortSpec(this._type,this._messageConstraint);return Reflect.construct(this._class,[this._name,t,e])}}function c(e=s.SpeedyPipelineInputPort.DEFAULT_NAME){return new a(s.SpeedyPipelineInputPort,e)}function p(e=s.SpeedyPipelineOutputPort.DEFAULT_NAME){return new a(s.SpeedyPipelineOutputPort,e)}},"./src/core/pipeline/pipeline-portspec.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipelinePortSpec:()=>o});var n=i("./src/core/pipeline/pipeline-message.js"),s=i("./src/utils/utils.js");const r=e=>!0;class o{constructor(e,t=r){this._expectedMessageType=e,this._isValidMessage="function"==typeof t?t:r,s.Utils.assert(this._expectedMessageType!=n.SpeedyPipelineMessageType.Nothing)}isCompatibleWith(e){return this._expectedMessageType==e._expectedMessageType}accepts(e){return e.hasType(this._expectedMessageType)&&this._isValidMessage(e)}toString(){return`Port expects ${Object.keys(n.SpeedyPipelineMessageType).find((e=>n.SpeedyPipelineMessageType[e]===this._expectedMessageType))} satisfying ${this._isValidMessage}`}get expectedMessageType(){return this._expectedMessageType}}},"./src/core/pipeline/pipeline.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPipeline:()=>p});var n=i("./src/utils/utils.js"),s=i("./src/core/speedy-promise.js"),r=i("./src/utils/errors.js"),o=(i("./src/core/pipeline/pipeline-node.js"),i("./src/core/pipeline/pipeline-port.js"),i("./src/gpu/speedy-gpu.js"));i("./src/core/speedy-media.js"),i("./src/core/speedy-keypoint.js");let a=null,c=0;class p{constructor(){this._nodes=[],this._sequence=[],this._busy=!1}node(e){for(let t=0,i=this._nodes.length;t<i;t++)if(this._nodes[t].name===e)return this._nodes[t];return null}init(...e){if(this._nodes.length>0)throw new r.IllegalOperationError("The pipeline has already been initialized");if(0==e.length)throw new r.IllegalArgumentError("Can't initialize the pipeline. Please specify its nodes");0==c++&&(n.Utils.assert(!a,"Duplicate SpeedyGPU instance"),a=new o.SpeedyGPU);for(let t=0;t<e.length;t++){const i=e[t];this._nodes.includes(i)||this._nodes.push(i)}this._sequence=p._tsort(this._nodes),p._validateSequence(this._sequence);for(let e=0;e<this._sequence.length;e++)this._sequence[e].init(a);return this}release(){if(0==this._nodes.length)throw new r.IllegalOperationError("The pipeline has already been released or has never been initialized");for(let e=this._sequence.length-1;e>=0;e--)this._sequence[e].release(a);return this._sequence.length=0,this._nodes.length=0,0==--c&&(a=a.release()),null}run(){if(n.Utils.assert(this._sequence.length>0,"The pipeline has not been initialized or has been released"),this._busy)return new s.SpeedyPromise(((e,t)=>{setTimeout((()=>this.run().then(e,t)),0)}));this._busy=!0;const e=this._sequence.filter((e=>e.isSink())),t=p._createOutputTemplate(e);return p._runSequence(this._sequence).then((()=>s.SpeedyPromise.all(e.map((e=>e.export().turbocharge()))).then((i=>i.reduce(((t,i,n)=>(t[e[n].name]=i,t)),t))))).finally((()=>{for(let e=this._sequence.length-1;e>=0;e--)this._sequence[e].clearPorts();this._busy=!1})).turbocharge()}get _gpu(){return a}static _runSequence(e,t=0,i=e.length){for(;t<i;t++){const n=e[t].execute(a);if(a.gl.flush(),void 0!==n)return n.then((()=>p._runSequence(e,t+1,i)))}return s.SpeedyPromise.resolve()}static _tsort(e){const t=p._outlinks(e),i=e.map((e=>[e,!1])),n=new Set,s=new Array(e.length);let o=s.length;for(;i.length>0;){const[e,a]=i.pop();if(a)s[--o]=e;else if(!n.has(e)){const o=t.get(e);if(n.add(e),i.push([e,!0]),i.push(...o.map((e=>[e,!1]))),o.some((e=>n.has(e)&&!s.includes(e))))throw new r.IllegalOperationError("Pipeline networks cannot have cycles!")}}return s}static _outlinks(e){const t=new Map;for(let i=0;i<e.length;i++)t.set(e[i],[]);for(let i=0;i<e.length;i++){const n=e[i],s=n.inputNodes();for(let e=0;e<s.length;e++){const i=s[e],o=t.get(i);if(!o)throw new r.IllegalOperationError(`Can't initialize the pipeline. Missing node: ${i.fullName}. Did you forget to add it to the initialization list?`);o.includes(n)||o.push(n)}}return t}static _createOutputTemplate(e=[]){const t=Object.create(null);for(let i=e.length-1;i>=0;i--)t[e[i].name]=null;return t}static _validateSequence(e){if(0==e.length)throw new r.IllegalOperationError("Pipeline doesn't have nodes");if(!e[0].isSource())throw new r.IllegalOperationError("Pipeline doesn't have a source");if(!e.find((e=>e.isSink())))throw new r.IllegalOperationError("Pipeline doesn't have a sink")}}},"./src/core/settings.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{Settings:()=>a});var n=i("./src/core/speedy-namespace.js"),s=i("./src/gpu/speedy-gl.js"),r=i("./src/utils/errors.js");let o="raf";class a extends n.SpeedyNamespace{static get powerPreference(){return s.SpeedyGL.powerPreference}static set powerPreference(e){s.SpeedyGL.powerPreference=e}static get gpuPollingMode(){return o}static set gpuPollingMode(e){if("raf"!==e&&"asap"!==e)throw new r.IllegalArgumentError(`Invalid GPU polling mode: "${e}"`);o=e}}},"./src/core/speedy-keypoint-descriptor.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyKeypointDescriptor:()=>n});class n{constructor(e){return this._data=e,Object.freeze(this)}get data(){return this._data}get size(){return this._data.byteLength}toString(){return`SpeedyKeypointDescriptor(${this._data.join(",")})`}}},"./src/core/speedy-keypoint-match.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyKeypointMatch:()=>s});var n=i("./src/utils/globals.js");class s{constructor(e,t){const i=t<n.MATCH_MAX_DISTANCE;return this._index=i?0|e:-1,this._distance=i?+t:Number.POSITIVE_INFINITY,Object.freeze(this)}get index(){return this._index}get distance(){return this._distance}toString(){return`SpeedyKeypointMatch(${this.index},${this.distance})`}}},"./src/core/speedy-keypoint.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyKeypoint:()=>r,SpeedyTrackedKeypoint:()=>o,SpeedyMatchedKeypoint:()=>a}),i("./src/core/speedy-keypoint-descriptor.js"),i("./src/core/speedy-keypoint-match.js");var n=i("./src/core/speedy-point.js"),s=i("./src/core/speedy-vector.js");class r{constructor(e,t,i=0,s=0,r=0,o=null){this._position=new n.SpeedyPoint2(+e,+t),this._lod=+i,this._rotation=+s,this._score=+r,this._descriptor=o}toString(){return`SpeedyKeypoint(${this.x},${this.y})`}get position(){return this._position}get x(){return this._position.x}set x(e){this._position.x=+e}get y(){return this._position.y}set y(e){this._position.y=+e}get lod(){return this._lod}get scale(){return Math.pow(2,this._lod)}get rotation(){return this._rotation}get score(){return this._score}get descriptor(){return this._descriptor}}class o extends r{constructor(e,t,i=0,n=0,r=0,o=null,a=new s.SpeedyVector2(0,0)){super(e,t,i,n,r,o),this._flow=a}get flow(){return this._flow}}class a extends r{constructor(e,t,i=0,n=0,s=0,r=null,o=[]){super(e,t,i,n,s,r),this._matches=o}get matches(){return this._matches}}},"./src/core/speedy-matrix-expr.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyMatrixExpr:()=>a});var n=i("./src/core/speedy-matrix-wasm.js"),s=i("./src/utils/utils.js"),r=i("./src/utils/errors.js");const o=Object.freeze({float32:Float32Array});class a{constructor(e,t,i){s.Utils.assert(e>0&&t>0),s.Utils.assert(i===a.DEFAULT_DTYPE),this._rows=0|e,this._columns=0|t,this._dtype=i}get rows(){return this._rows}get columns(){return this._columns}get dtype(){return this._dtype}static get DEFAULT_DTYPE(){return"float32"}static get BUFFER_TYPE(){return o}plus(e){return new h(this,e)}minus(e){return new I(this,e)}times(e){return"number"==typeof e?new g(this,e):new m(this,e)}transpose(){return new d(this)}inverse(){return new u(this)}compMult(e){return new f(this,e)}ldiv(e){return new y(this,e)}toString(){return`SpeedyMatrixExpr(rows=${this.rows}, columns=${this.columns})`}_evaluate(e,t){throw new r.AbstractMethodError}}const{SpeedyMatrix:c}=i("./src/core/speedy-matrix.js");class p extends a{constructor(e,t,i){super(e,t,i),this._tempMatrix=c.Zeros(this.rows,this.columns,this.dtype)}}class l extends p{constructor(e,t,i){super(e,t,i.dtype),this._operand=i}_evaluate(e,t){const i=this._operand._evaluate(e,t),s=this._tempMatrix,r=n.SpeedyMatrixWASM.allocateMat32(e,t,s),o=n.SpeedyMatrixWASM.allocateMat32(e,t,i);return n.SpeedyMatrixWASM.copyToMat32(e,t,o,i),this._compute(e,t,r,o),n.SpeedyMatrixWASM.copyFromMat32(e,t,r,s),n.SpeedyMatrixWASM.deallocateMat32(e,t,o),n.SpeedyMatrixWASM.deallocateMat32(e,t,r),s}_compute(e,t,i,n){throw new r.AbstractMethodError}}class A extends p{constructor(e,t,i,n){s.Utils.assert(i.dtype===n.dtype),super(e,t,i.dtype),this._left=i,this._right=n}_evaluate(e,t){const i=this._left._evaluate(e,t),s=this._right._evaluate(e,t),r=this._tempMatrix,o=n.SpeedyMatrixWASM.allocateMat32(e,t,r),a=n.SpeedyMatrixWASM.allocateMat32(e,t,i),c=n.SpeedyMatrixWASM.allocateMat32(e,t,s);return n.SpeedyMatrixWASM.copyToMat32(e,t,a,i),n.SpeedyMatrixWASM.copyToMat32(e,t,c,s),this._compute(e,t,o,a,c),n.SpeedyMatrixWASM.copyFromMat32(e,t,o,r),n.SpeedyMatrixWASM.deallocateMat32(e,t,c),n.SpeedyMatrixWASM.deallocateMat32(e,t,a),n.SpeedyMatrixWASM.deallocateMat32(e,t,o),r}_compute(e,t,i,n,s){throw new r.AbstractMethodError}}class d extends l{constructor(e){super(e.columns,e.rows,e)}_compute(e,t,i,n){e.exports.Mat32_transpose(i,n)}}class u extends l{constructor(e){s.Utils.assert(e.rows===e.columns),super(e.rows,e.columns,e),this._size=e.rows}_compute(e,t,i,n){switch(this._size){case 0:break;case 1:e.exports.Mat32_inverse1(i,n);break;case 2:e.exports.Mat32_inverse2(i,n);break;case 3:e.exports.Mat32_inverse3(i,n);break;default:e.exports.Mat32_qr_inverse(i,n)}}}class g extends l{constructor(e,t){super(e.rows,e.columns,e),this._scalar=+t}_compute(e,t,i,n){e.exports.Mat32_scale(i,n,this._scalar)}}class h extends A{constructor(e,t){s.Utils.assert(e.rows===t.rows&&e.columns===t.columns),super(e.rows,e.columns,e,t)}_compute(e,t,i,n,s){e.exports.Mat32_add(i,n,s)}}class I extends A{constructor(e,t){s.Utils.assert(e.rows===t.rows&&e.columns===t.columns),super(e.rows,e.columns,e,t)}_compute(e,t,i,n,s){e.exports.Mat32_subtract(i,n,s)}}class m extends A{constructor(e,t){s.Utils.assert(e.columns===t.rows),super(e.rows,t.columns,e,t)}_compute(e,t,i,n,s){e.exports.Mat32_multiply(i,n,s)}}class f extends A{constructor(e,t){s.Utils.assert(e.rows===t.rows&&e.columns===t.columns),super(t.rows,t.columns,e,t)}_compute(e,t,i,n,s){e.exports.Mat32_compmult(i,n,s)}}class y extends A{constructor(e,t){const i=e.rows,n=e.columns;s.Utils.assert(i>=n&&t.rows===i&&1===t.columns),super(n,1,e,t)}_compute(e,t,i,n,s){e.exports.Mat32_qr_ols(i,n,s,2)}}},"./src/core/speedy-matrix-factory.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyMatrixFactory:()=>a}),i("./src/core/speedy-matrix-expr.js");var n=i("./src/core/speedy-matrix-wasm.js"),s=i("./src/core/speedy-matrix.js"),r=(i("./src/core/speedy-promise.js"),i("./src/utils/utils.js")),o=i("./src/utils/errors.js");class a extends Function{constructor(){return super("...args","return args.length > 1 ? this._create(...args) : this._from(args[0])"),this.bind(this)}_create(e,t=e,i=[]){return s.SpeedyMatrix.Create(e,t,i)}_from(e){return s.SpeedyMatrix.From(e)}Zeros(e,t=e){return s.SpeedyMatrix.Zeros(e,t)}Ones(e,t=e){return s.SpeedyMatrix.Ones(e,t)}Eye(e,t=e){return s.SpeedyMatrix.Eye(e,t)}ready(){return s.SpeedyMatrix.ready()}qr(e,t,i,{mode:s="reduced"}={}){const r=i,a=i.rows,c=i.columns;if("reduced"==s){if(e.rows!=a||e.columns!=c||t.rows!=c||t.columns!=c)throw new o.IllegalArgumentError("Invalid shape for reduced QR")}else{if("full"!=s)throw new o.IllegalArgumentError(`Invalid mode for QR: "${s}"`);if(e.rows!=a||e.columns!=a||t.rows!=a||t.columns!=c)throw new o.IllegalArgumentError("Invalid shape for full QR")}return n.SpeedyMatrixWASM.ready().then((({wasm:i,memory:o})=>{const a=n.SpeedyMatrixWASM.allocateMat32(i,o,e),c=n.SpeedyMatrixWASM.allocateMat32(i,o,t),p=n.SpeedyMatrixWASM.allocateMat32(i,o,r);return n.SpeedyMatrixWASM.copyToMat32(i,o,p,r),"reduced"==s?i.exports.Mat32_qr_reduced(a,c,p):i.exports.Mat32_qr_full(a,c,p),n.SpeedyMatrixWASM.copyFromMat32(i,o,a,e),n.SpeedyMatrixWASM.copyFromMat32(i,o,c,t),n.SpeedyMatrixWASM.deallocateMat32(i,o,p),n.SpeedyMatrixWASM.deallocateMat32(i,o,c),n.SpeedyMatrixWASM.deallocateMat32(i,o,a),[e,t]}))}ols(e,t,i,{method:s="qr"}={}){const r=t.rows,a=t.columns,c=e;if(r<a||0==a)throw new o.IllegalArgumentError("Can't solve an underdetermined system of equations");if(i.rows!=r||1!=i.columns||c.rows!=a||1!=c.columns)throw new o.IllegalArgumentError("Invalid shapes");return n.SpeedyMatrixWASM.ready().then((({wasm:r,memory:a})=>{const p=n.SpeedyMatrixWASM.allocateMat32(r,a,t),l=n.SpeedyMatrixWASM.allocateMat32(r,a,i),A=n.SpeedyMatrixWASM.allocateMat32(r,a,c);if(n.SpeedyMatrixWASM.copyToMat32(r,a,p,t),n.SpeedyMatrixWASM.copyToMat32(r,a,l,i),"qr"!==s)throw new o.IllegalArgumentError(`Invalid method: "${s}"`);return r.exports.Mat32_qr_ols(A,p,l,2),n.SpeedyMatrixWASM.copyFromMat32(r,a,A,c),n.SpeedyMatrixWASM.deallocateMat32(r,a,A),n.SpeedyMatrixWASM.deallocateMat32(r,a,l),n.SpeedyMatrixWASM.deallocateMat32(r,a,p),e}))}solve(e,t,i,{method:s="qr"}={}){const r=t.rows,a=t.columns,c=e;if(r!=a)throw new o.IllegalArgumentError("Can't solve an over or underdetermined system of equations");if(i.rows!=r||1!=i.columns||c.rows!=r||1!=c.columns)throw new o.IllegalArgumentError("Invalid shapes");return n.SpeedyMatrixWASM.ready().then((({wasm:e,memory:n})=>{if("qr"===s)return this.ols(c,t,i,{method:s});throw new o.IllegalArgumentError(`Invalid method: "${s}"`)}))}perspective(e,t,i){if(2!=t.rows||4!=t.columns||2!=i.rows||4!=i.columns)throw new o.IllegalArgumentError("You need two 2x4 input matrices to compute a perspective transformation");if(3!=e.rows||3!=e.columns)throw new o.IllegalArgumentError("The output of perspective() is a 3x3 homography");return n.SpeedyMatrixWASM.ready().then((({wasm:s,memory:r})=>{const o=n.SpeedyMatrixWASM.allocateMat32(s,r,e),a=n.SpeedyMatrixWASM.allocateMat32(s,r,t),c=n.SpeedyMatrixWASM.allocateMat32(s,r,i);return n.SpeedyMatrixWASM.copyToMat32(s,r,a,t),n.SpeedyMatrixWASM.copyToMat32(s,r,c,i),s.exports.Mat32_homography_ndlt4(o,a,c),n.SpeedyMatrixWASM.copyFromMat32(s,r,o,e),n.SpeedyMatrixWASM.deallocateMat32(s,r,c),n.SpeedyMatrixWASM.deallocateMat32(s,r,a),n.SpeedyMatrixWASM.deallocateMat32(s,r,o),e}))}findHomography(e,t,i,{method:s="default",mask:a=null,reprojectionError:c=3,numberOfHypotheses:p=512,bundleSize:l=128}={}){if(2!=t.rows||t.columns<4||2!=i.rows||i.columns!=t.columns)throw new o.IllegalArgumentError("You need two 2 x n (n >= 4) input matrices to compute a homography");if(3!=e.rows||3!=e.columns)throw new o.IllegalArgumentError("The output of findHomography() is a 3x3 homography");if(null!=a&&(1!=a.rows||a.columns!=t.columns))throw new o.IllegalArgumentError("Invalid shape of the inliers mask");return n.SpeedyMatrixWASM.ready().then((({wasm:A,memory:d})=>{const u=n.SpeedyMatrixWASM.allocateMat32(A,d,e),g=n.SpeedyMatrixWASM.allocateMat32(A,d,t),h=n.SpeedyMatrixWASM.allocateMat32(A,d,i),I=null!=a?n.SpeedyMatrixWASM.allocateMat32(A,d,a):0;switch(n.SpeedyMatrixWASM.copyToMat32(A,d,g,t),n.SpeedyMatrixWASM.copyToMat32(A,d,h,i),s){case"pransac":r.Utils.assert(c>=0&&p>0&&l>0),A.exports.Mat32_pransac_homography(u,I,g,h,p,l,c);break;case"default":case"dlt":A.exports.Mat32_homography_ndlt(u,g,h);break;default:throw new o.IllegalArgumentError(`Illegal method for findHomography(): "${s}"`)}return n.SpeedyMatrixWASM.copyFromMat32(A,d,u,e),null!=a&&n.SpeedyMatrixWASM.copyFromMat32(A,d,I,a),null!=a&&n.SpeedyMatrixWASM.deallocateMat32(A,d,I),n.SpeedyMatrixWASM.deallocateMat32(A,d,h),n.SpeedyMatrixWASM.deallocateMat32(A,d,g),n.SpeedyMatrixWASM.deallocateMat32(A,d,u),e}))}applyPerspectiveTransform(e,t,i){if(2!=t.rows||2!=e.rows||t.columns!=e.columns)throw new o.IllegalArgumentError("Invalid shapes");if(3!=i.rows||3!=i.columns)throw new o.IllegalArgumentError("The perspective transformation must be a 3x3 matrix");return n.SpeedyMatrixWASM.ready().then((({wasm:s,memory:r})=>{const o=n.SpeedyMatrixWASM.allocateMat32(s,r,i),a=n.SpeedyMatrixWASM.allocateMat32(s,r,t),c=n.SpeedyMatrixWASM.allocateMat32(s,r,e);return n.SpeedyMatrixWASM.copyToMat32(s,r,a,t),n.SpeedyMatrixWASM.copyToMat32(s,r,o,i),s.exports.Mat32_transform_perspective(c,a,o),n.SpeedyMatrixWASM.copyFromMat32(s,r,c,e),n.SpeedyMatrixWASM.deallocateMat32(s,r,c),n.SpeedyMatrixWASM.deallocateMat32(s,r,a),n.SpeedyMatrixWASM.deallocateMat32(s,r,o),e}))}affine(e,t,i){if(2!=t.rows||3!=t.columns||2!=i.rows||3!=i.columns)throw new o.IllegalArgumentError("You need two 2x3 input matrices to compute an affine transform");if(2!=e.rows||3!=e.columns)throw new o.IllegalArgumentError("The output of affine() is a 2x3 matrix");return n.SpeedyMatrixWASM.ready().then((({wasm:s,memory:r})=>{const o=n.SpeedyMatrixWASM.allocateMat32(s,r,e),a=n.SpeedyMatrixWASM.allocateMat32(s,r,t),c=n.SpeedyMatrixWASM.allocateMat32(s,r,i);return n.SpeedyMatrixWASM.copyToMat32(s,r,a,t),n.SpeedyMatrixWASM.copyToMat32(s,r,c,i),s.exports.Mat32_affine_direct3(o,a,c),n.SpeedyMatrixWASM.copyFromMat32(s,r,o,e),n.SpeedyMatrixWASM.deallocateMat32(s,r,c),n.SpeedyMatrixWASM.deallocateMat32(s,r,a),n.SpeedyMatrixWASM.deallocateMat32(s,r,o),e}))}findAffineTransform(e,t,i,{method:s="default",mask:a=null,reprojectionError:c=3,numberOfHypotheses:p=512,bundleSize:l=128}={}){if(2!=t.rows||t.columns<3||2!=i.rows||i.columns!=t.columns)throw new o.IllegalArgumentError("You need two 2 x n (n >= 3) input matrices to compute an affine transform");if(2!=e.rows||3!=e.columns)throw new o.IllegalArgumentError("The output of findAffineTransform() is a 2x3 matrix");if(null!=a&&(1!=a.rows||a.columns!=t.columns))throw new o.IllegalArgumentError("Invalid shape of the inliers mask");return n.SpeedyMatrixWASM.ready().then((({wasm:A,memory:d})=>{const u=n.SpeedyMatrixWASM.allocateMat32(A,d,e),g=n.SpeedyMatrixWASM.allocateMat32(A,d,t),h=n.SpeedyMatrixWASM.allocateMat32(A,d,i),I=null!=a?n.SpeedyMatrixWASM.allocateMat32(A,d,a):0;switch(n.SpeedyMatrixWASM.copyToMat32(A,d,g,t),n.SpeedyMatrixWASM.copyToMat32(A,d,h,i),s){case"pransac":r.Utils.assert(c>=0&&p>0&&l>0),A.exports.Mat32_pransac_affine(u,I,g,h,p,l,c);break;case"default":A.exports.Mat32_affine_direct(u,g,h);break;default:throw new o.IllegalArgumentError(`Illegal method for findAffineTransform(): "${s}"`)}return n.SpeedyMatrixWASM.copyFromMat32(A,d,u,e),null!=a&&n.SpeedyMatrixWASM.copyFromMat32(A,d,I,a),null!=a&&n.SpeedyMatrixWASM.deallocateMat32(A,d,I),n.SpeedyMatrixWASM.deallocateMat32(A,d,h),n.SpeedyMatrixWASM.deallocateMat32(A,d,g),n.SpeedyMatrixWASM.deallocateMat32(A,d,u),e}))}applyAffineTransform(e,t,i){if(2!=t.rows||2!=e.rows||t.columns!=e.columns)throw new o.IllegalArgumentError("Invalid shapes");if(2!=i.rows||3!=i.columns)throw new o.IllegalArgumentError("The affine transformation must be a 2x3 matrix");return n.SpeedyMatrixWASM.ready().then((({wasm:s,memory:r})=>{const o=n.SpeedyMatrixWASM.allocateMat32(s,r,i),a=n.SpeedyMatrixWASM.allocateMat32(s,r,t),c=n.SpeedyMatrixWASM.allocateMat32(s,r,e);return n.SpeedyMatrixWASM.copyToMat32(s,r,a,t),n.SpeedyMatrixWASM.copyToMat32(s,r,o,i),s.exports.Mat32_transform_affine(c,a,o),n.SpeedyMatrixWASM.copyFromMat32(s,r,c,e),n.SpeedyMatrixWASM.deallocateMat32(s,r,c),n.SpeedyMatrixWASM.deallocateMat32(s,r,a),n.SpeedyMatrixWASM.deallocateMat32(s,r,o),e}))}}},"./src/core/speedy-matrix-wasm.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyMatrixWASM:()=>d});var n=i("./src/core/speedy-promise.js"),s=i("./src/utils/errors.js"),r=i("./src/utils/utils.js"),o=i("./src/utils/globals.js");const a=i("./src/core/wasm/speedy-matrix.wasm.txt");let c=null,p=null;const l={as:{object:A=new WebAssembly.Memory({initial:16,maximum:256}),uint8:new Uint8Array(A.buffer),int32:new Int32Array(A.buffer),uint32:new Uint32Array(A.buffer),float32:new Float32Array(A.buffer),float64:new Float64Array(A.buffer)}};var A;class d{static ready(){return new n.SpeedyPromise(((e,t)=>{d._ready(e,t)}))}static get handle(){if(!c||!p)throw new s.WebAssemblyError("Can't get WASM handle: routines not yet loaded");return{wasm:c,memory:l,module:p}}static imports(e){const t=new u(e);return Object.getOwnPropertyNames(u.prototype).filter((e=>"function"==typeof t[e]&&"constructor"!==e)).reduce(((e,i)=>(e[i]=t[i],e)),Object.create(null))}static allocateMat32(e,t,i){const n=e.exports.malloc(i.data.byteLength);return e.exports.Mat32_create(i.rows,i.columns,i.step0,i.step1,i._data.length,n)}static deallocateMat32(e,t,i){const n=e.exports.Mat32_data(i);return e.exports.free(i),e.exports.free(n),0}static copyToMat32(e,t,i,n){r.Utils.assert(n.data.byteLength===e.exports.Mat32_dataSize(i));const s=e.exports.Mat32_data(i);return t.as.float32.set(n.data,s/Float32Array.BYTES_PER_ELEMENT),i}static copyFromMat32(e,t,i,n){r.Utils.assert(n.data.byteLength===e.exports.Mat32_dataSize(i));const s=e.exports.Mat32_data(i)/Float32Array.BYTES_PER_ELEMENT;for(let e=n.data.length-1;e>=0;e--)n.data[e]=t.as.float32[s+e];return i}static _ready(e,t,i=1e3){null!==c&&null!==p?e({wasm:c,memory:l,module:p}):i<=0?t(new s.TimeoutError("Can't load WASM routines")):setTimeout(d._ready,0,e,t,i-1)}}class u{constructor(e){return Object.getOwnPropertyNames(this.constructor.prototype).filter((e=>"function"==typeof this[e])).filter((e=>"constructor"!==e)).forEach((e=>{this[e]=this[e].bind(this)})),this.memory=e,this.cstring=new g(e),Object.freeze(this)}print(e){r.Utils.log(this.cstring.get(e))}fatal(e){throw new s.WebAssemblyError(this.cstring.get(e))}bytefill(e,t,i){this.memory.as.uint8.fill(e,t,i)}copyWithin(e,t,i){this.memory.as.uint8.copyWithin(e,t,i)}}class g{constructor(e){this._decoder=new TextDecoder("utf-8"),this._memory=e}get(e){const t=this._memory.as.uint8,i=this._memory.as.uint8.byteLength;let n=e;for(;n<i&&0!==t[n];)++n;return this._decoder.decode(t.subarray(e,n))}}!function(e){if(!o.LITTLE_ENDIAN)throw new s.NotSupportedError("Can't run WebAssembly code: not in a little-endian machine!");n.SpeedyPromise.resolve(a).then((e=>(e=>Uint8Array.from(atob(e),(e=>e.charCodeAt(0))))(e))).then((t=>WebAssembly.instantiate(t,{env:{memory:e.as.object,...d.imports(e)}}))).then((e=>{c=e.instance,p=e.module,e.instance.exports.srand(.001*Date.now()&4294967295),r.Utils.log("The WebAssembly routines have been loaded!")})).catch((e=>{throw new s.WebAssemblyError(`Can't load the WebAssembly routines: ${e}`,e)}))}(l)},"./src/core/speedy-matrix.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyMatrix:()=>a});var n=i("./src/core/speedy-matrix-expr.js"),s=i("./src/core/speedy-matrix-wasm.js"),r=i("./src/core/speedy-promise.js"),o=i("./src/utils/utils.js");class a extends n.SpeedyMatrixExpr{constructor(e,t,i,s,r){super(e,t,n.SpeedyMatrixExpr.DEFAULT_DTYPE),o.Utils.assert(r.constructor===n.SpeedyMatrixExpr.BUFFER_TYPE[this.dtype]),o.Utils.assert(i>0&&s>=i),o.Utils.assert(r.length+e*t===0||r.length===1+i*(e-1)+s*(t-1)),this._step0=0|i,this._step1=0|s,this._data=r}static Create(e,t,i,s=n.SpeedyMatrixExpr.DEFAULT_DTYPE){return o.Utils.assert(e*t>0,"Can't create a matrix without a shape"),o.Utils.assert(e*t===i.length,`Can't create matrix: expected ${e*t} entries, but found ${i.length}`),o.Utils.assert(Object.prototype.hasOwnProperty.call(n.SpeedyMatrixExpr.BUFFER_TYPE,s),`Invalid dtype: "${s}"`),new a(e,t,1,e,Reflect.construct(n.SpeedyMatrixExpr.BUFFER_TYPE[s],[i]))}static Zeros(e,t=e,i=n.SpeedyMatrixExpr.DEFAULT_DTYPE){return o.Utils.assert(e*t>0,"Can't create a matrix without a shape"),o.Utils.assert(Object.prototype.hasOwnProperty.call(n.SpeedyMatrixExpr.BUFFER_TYPE,i),`Invalid dtype: "${i}"`),new a(e,t,1,e,Reflect.construct(n.SpeedyMatrixExpr.BUFFER_TYPE[i],[e*t]))}static Ones(e,t=e,i=n.SpeedyMatrixExpr.DEFAULT_DTYPE){return o.Utils.assert(e*t>0,"Can't create a matrix without a shape"),o.Utils.assert(Object.prototype.hasOwnProperty.call(n.SpeedyMatrixExpr.BUFFER_TYPE,i),`Invalid dtype: "${i}"`),new a(e,t,1,e,Reflect.construct(n.SpeedyMatrixExpr.BUFFER_TYPE[i],[e*t]).fill(1))}static Eye(e,t=e,i=n.SpeedyMatrixExpr.DEFAULT_DTYPE){o.Utils.assert(e*t>0,"Can't create a matrix without a shape"),o.Utils.assert(Object.prototype.hasOwnProperty.call(n.SpeedyMatrixExpr.BUFFER_TYPE,i),`Invalid dtype: "${i}"`);const s=Reflect.construct(n.SpeedyMatrixExpr.BUFFER_TYPE[i],[e*t]);for(let i=Math.min(e,t)-1;i>=0;i--)s[i*e+i]=1;return new a(e,t,1,e,s)}static From(e){return a.Zeros(e.rows,e.columns,e.dtype).setToSync(e)}static ready(){return s.SpeedyMatrixWASM.ready().then((e=>{}))}get data(){return this._data}get step0(){return this._step0}get step1(){return this._step1}block(e,t,i,n){o.Utils.assert(e<=t&&i<=n,`Invalid indices: [${e}:${t},${i}:${n}]`),e=Math.max(e,0),t=Math.min(t,this._rows-1),i=Math.max(i,0);const s=t-e+1,r=(n=Math.min(n,this._columns-1))-i+1,c=this._step0,p=this._step1,l=e*c+i*p,A=1+t*c+n*p;return new a(s,r,c,p,this._data.subarray(l,A))}row(e){return this.block(e,e,0,this._columns-1)}column(e){return this.block(0,this._rows-1,e,e)}diagonal(){const e=Math.min(this._rows,this._columns),t=e,i=this._step0+this._step1,n=1+(e-1)*i;return new a(t,1,i,i,this._data.subarray(0,n))}at(e,t){return e>=0&&e<this._rows&&t>=0&&t<this._columns?this._data[this._step0*e+this._step1*t]:Number.NaN}read(){const e=new Array(this._rows*this._columns),t=this._step0,i=this._step1;let n=0;for(let s=0;s<this._columns;s++)for(let r=0;r<this._rows;r++)e[n++]=this._data[r*t+s*i];return e}toString(){const e=this.rows,t=this.columns,i=this.read(),n=new Array(e);for(let s=0;s<e;s++){n[s]=new Array(t);for(let r=0;r<t;r++)n[s][r]=i[r*e+s]}const s=e=>e.toFixed(5);return`SpeedyMatrix(rows=${e}, columns=${t}, data=[\n${n.map((e=>"    "+e.map(s).join(", "))).join(",\n")}\n])`}setTo(e){return s.SpeedyMatrixWASM.ready().then((t=>this.setToSync(e)))}setToSync(e){const{wasm:t,memory:i}=s.SpeedyMatrixWASM.handle,n=e._evaluate(t,i);o.Utils.assert(this._rows===n._rows&&this._columns===n._columns&&this.dtype===n.dtype,`Can't set the values of a ${this.rows} x ${this.columns} ${this.dtype} matrix to those of a ${n.rows} x ${n.columns} ${n.dtype} matrix`);const r=this._step0,a=this._step1,c=n._step0,p=n._step1;if(r===c&&a===p&&this._data.length===n._data.length)this._data.set(n._data);else for(let e=this._columns-1;e>=0;e--)for(let t=this._rows-1;t>=0;t--)this._data[t*r+e*a]=n._data[t*c+e*p];return this}fill(e){return this.fillSync(e),r.SpeedyPromise.resolve(this)}fillSync(e){if(e=+e,this._rows*this._columns===this._data.length)return this._data.fill(e),this;for(let t=0;t<this._columns;t++)for(let i=0;i<this._rows;i++)this._data[i*this._step0+t*this._step1]=e;return this}_evaluate(e,t){return this}}},"./src/core/speedy-media-source.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyMediaSource:()=>c});var n=i("./src/utils/utils.js"),s=i("./src/core/speedy-promise.js"),r=i("./src/utils/errors.js"),o=i("./src/utils/types.js");const a=Symbol();class c{constructor(e){if(e!==a)throw new r.IllegalOperationError;this._data=null}static load(e){if(e instanceof HTMLImageElement)return p.load(e);if(e instanceof HTMLVideoElement)return l.load(e);if(e instanceof HTMLCanvasElement)return A.load(e);if(e instanceof ImageBitmap)return d.load(e);throw new r.IllegalArgumentError(`Unsupported media type: ${e}`)}get data(){return this._data}isLoaded(){return null!==this._data}get type(){throw new r.AbstractMethodError}get width(){throw new r.AbstractMethodError}get height(){throw new r.AbstractMethodError}clone(){throw new r.AbstractMethodError}release(){return this._data=null}_load(e){throw new r.AbstractMethodError}static _waitUntil(e,t,i=3e4){return new s.SpeedyPromise(((s,o)=>{n.Utils.log(`Waiting for ${t} to be triggered in ${e}...`);const a=setTimeout((()=>{o(new r.TimeoutError(`${t} has not been triggered in ${e}: timeout (${i}ms)`))}),i);e.addEventListener(t,(()=>{clearTimeout(a),s(e)}),!1)}))}}class p extends c{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return o.MediaType.Image}get width(){return this._data?this._data.naturalWidth:0}get height(){return this._data?this._data.naturalHeight:0}clone(){if(null==this._data)throw new r.IllegalOperationError("Media not loaded");const e=this._data.cloneNode(!0);return p.load(e)}_load(e){return this.isLoaded()&&this.release(),e.complete&&0!==e.naturalWidth?new s.SpeedyPromise((t=>{this._data=e,t(this)})):c._waitUntil(e,"load").then((()=>(this._data=e,this)))}static load(e){return new p(a)._load(e)}}class l extends c{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return o.MediaType.Video}get width(){return this._data?this._data.videoWidth:0}get height(){return this._data?this._data.videoHeight:0}clone(){if(null==this._data)throw new r.IllegalOperationError("Media not loaded");const e=this._data.cloneNode(!0);return l.load(e)}_load(e){return this.isLoaded()&&this.release(),e.readyState>=4?new s.SpeedyPromise((t=>{this._data=e,t(this)})):c._waitUntil(e,"canplaythrough").then((()=>(this._data=e,this)))}static load(e){return new l(a)._load(e)}}class A extends c{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return o.MediaType.Canvas}get width(){return this._data?this._data.width:0}get height(){return this._data?this._data.height:0}clone(){if(null==this._data)throw new r.IllegalOperationError("Media not loaded");const e=n.Utils.createCanvas(this.width,this.height);return e.getContext("2d").drawImage(this._data,0,0),A.load(e)}_load(e){return this.isLoaded()&&this.release(),new s.SpeedyPromise((t=>{this._data=e,t(this)}))}static load(e){return new A(a)._load(e)}}class d extends c{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return o.MediaType.Bitmap}get width(){return this._data?this._data.width:0}get height(){return this._data?this._data.height:0}clone(){if(null==this._data)throw new r.IllegalOperationError("Media not loaded");return new s.SpeedyPromise(((e,t)=>{createImageBitmap(this._data).then((i=>{new d(a)._load(i).then(e,t)}),t)}))}release(){return null!=this._data&&this._data.close(),super.release()}_load(e){return this.isLoaded()&&this.release(),new s.SpeedyPromise((t=>{this._data=e,t(this)}))}static load(e){return new d(a)._load(e)}}},"./src/core/speedy-media.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyMedia:()=>l}),i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js");var n=i("./src/utils/types.js"),s=i("./src/utils/errors.js"),r=i("./src/utils/utils.js"),o=i("./src/core/speedy-media-source.js"),a=i("./src/core/speedy-promise.js"),c=i("./src/core/speedy-size.js");const p=Symbol();class l{constructor(e,t,i={}){if(e!==p)throw new s.IllegalOperationError;if(this._source=t,this._format=void 0!==i.format?i.format:n.ImageFormat.RGBA,this._options=Object.freeze({...i,format:this._format}),!t.isLoaded())throw new s.IllegalOperationError(`Source not loaded: ${t}`);if(this._format!==n.ImageFormat.RGBA&&this._format!==n.ImageFormat.GREY)throw new s.IllegalArgumentError(`Invalid format: ${this._format}`)}static load(e,t={},i=!0){return o.SpeedyMediaSource.load(e).then((n=>{r.Utils.assert(0!==n.width&&0!==n.height);const s=new l(p,n,t);return i&&r.Utils.log(`Loaded SpeedyMedia with a ${e}.`),s}))}get source(){return this._source?this._source.data:null}get type(){if(this.isReleased())return"unknown";switch(this._source.type){case n.MediaType.Image:return"image";case n.MediaType.Video:return"video";case n.MediaType.Canvas:return"canvas";case n.MediaType.Bitmap:return"bitmap";default:return"unknown"}}get width(){return this._source?this._source.width:0}get height(){return this._source?this._source.height:0}get size(){return this._source?new c.SpeedySize(this._source.width,this._source.height):new c.SpeedySize(0,0)}get options(){return this._options}release(){return this.isReleased()||(r.Utils.log("Releasing SpeedyMedia object..."),this._source=this._source.release()),null}isReleased(){return null==this._source}clone(){if(this.isReleased())throw new s.IllegalOperationError("Can't clone a SpeedyMedia that has been released");const e=new l(p,this._source,this._options);return a.SpeedyPromise.resolve(e)}toBitmap(){if(this.isReleased())throw new s.IllegalOperationError("Can't convert SpeedyMedia to ImageBitmap: the media has been released");if(this._source.isLoaded())return this._source.type==n.MediaType.Bitmap?a.SpeedyPromise.resolve(this._source.data):new a.SpeedyPromise(((e,t)=>createImageBitmap(this._source.data).then(e,t)));throw new s.IllegalOperationError("Can't convert SpeedyMedia to bitmap: the media hasn't been loaded")}}},"./src/core/speedy-namespace.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyNamespace:()=>s});var n=i("./src/utils/errors.js");class s{constructor(){throw new n.AbstractMethodError("Namespaces can't be instantiated")}}},"./src/core/speedy-point.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPoint2:()=>s});var n=i("./src/core/speedy-vector.js");class s{constructor(e,t){this._x=+e,this._y=+t}get x(){return this._x}set x(e){this._x=+e}get y(){return this._y}set y(e){this._y=+e}toString(){return`SpeedyPoint2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`}plus(e){return new s(this.x+e.x,this.y+e.y)}minus(e){return new n.SpeedyVector2(this.x-e.x,this.y-e.y)}equals(e){return this.x===e.x&&this.y===e.y}}},"./src/core/speedy-promise.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyPromise:()=>s});const n="undefined"!=typeof queueMicrotask&&queueMicrotask||"undefined"!=typeof process&&process.nextTick||(e=>Promise.resolve().then((()=>e())));class s{constructor(e){this._state=0,this._value=void 0,this._onFulfillment=null,this._onRejection=null,this._children=0,this[0]=this,this._parent=void 0,this._flags=0,this._fulfill=this._fulfill.bind(this),this._reject=this._reject.bind(this),this._resolve=this._resolve.bind(this),this._broadcastIfAsync=this._broadcastIfAsync.bind(this),e(this._fulfill,this._reject)}then(e,t=null){const i=new s(this._nop);return i._onFulfillment="function"==typeof e&&e,i._onRejection="function"==typeof t&&t,i._parent=this,this[this._children++]=i,this._flags&=-2,this._notify(),i}catch(e){return this.then(null,e)}finally(e){const t=t=>(e(),t);return this.then(t,t)}turbocharge(){let e=this;for(this._flags|=1;void 0!==e._parent;)e=e._parent,e._flags|=1;return e._notify(),this}toString(){switch(this._state){case 0:return"SpeedyPromise { <pending> }";case 1:return`SpeedyPromise { <fulfilled> ${this._value} }`;case 2:return`SpeedyPromise { <rejected> ${this._value} }`;default:return""}}get[Symbol.toStringTag](){return"SpeedyPromise"}static resolve(e){const t=new s(this._snop);return"object"==typeof e&&null!==e&&"then"in e||"function"==typeof e&&"then"in e?t._resolve(e):(t._value=e,t._state=1),t}static reject(e){const t=new s(this._snop);return t._value=e,t._state=2,t}static all(e){return new s(((t,i)=>{const n=[];for(const t of e)n.push(t);const r=n.length;if(0==r)return void t([]);let o=r;const a=new Array(r),c=e=>i=>{a[e]=i,0==--o&&t(a)};for(let e=0;e<r;e++){const t=n[e];t.__proto__===s.prototype||t.__proto__===Promise.prototype?t.then(c(e),i):s.resolve(t).then(c(e),i)}}))}static race(e){return new s(((t,i)=>{const n=[];for(const t of e)n.push(t);const r=n.length;for(let e=0;e<r;e++){const r=n[e];r.__proto__===s.prototype||r.__proto__===Promise.prototype?r.then(t,i):s.resolve(r).then(t,i)}}))}_fulfill(e){this._setState(1,e)}_reject(e){this._setState(2,e)}_setState(e,t){0==this._state&&(this._state=e,this._value=t,this._notify())}_notify(){0!=this._state&&(1&this._flags?this._broadcast():n(this._broadcastIfAsync))}_broadcastIfAsync(){1&this._flags||this._broadcast()}_broadcast(){const e=this._children,t=this._state;if(1===t)for(let t=0;t<e;t++){const e=this[t],i=e._onFulfillment;try{i?i!==e._nop&&(e._resolve(i(this._value)),e._onFulfillment=e._nop):e._fulfill(this._value)}catch(t){e._reject(t)}}else if(2===t)for(let t=0;t<e;t++){const e=this[t],i=e._onRejection;try{i?i!==e._nop&&(e._resolve(i(this._value)),e._onRejection=e._nop):e._reject(this._value)}catch(t){e._reject(t)}}}_resolve(e){if("object"!=typeof e&&"function"!=typeof e||null===e)this._fulfill(e);else{if(e===this)throw new TypeError;if(e.__proto__!==s.prototype&&e.__proto__!==Promise.prototype)try{const t=e.then;if("function"==typeof t){let i=this._resolve,n=this._reject;try{t.call(e,(e=>{i(e),i=n=this._nop}),(e=>{n(e),i=n=this._nop}))}catch(e){i!==this._nop&&n!==this._nop&&this._reject(e)}}else this._fulfill(e)}catch(e){this._reject(e)}else e.then(this._resolve,this._reject)}}_nop(){}static _snop(){}}},"./src/core/speedy-size.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedySize:()=>n});class n{constructor(e,t){this._width=Math.max(0,+e),this._height=Math.max(0,+t)}get width(){return this._width}set width(e){this._width=Math.max(0,+e)}get height(){return this._height}set height(e){this._height=Math.max(0,+e)}toString(){return`SpeedySize(${this.width}, ${this.height})`}equals(e){return this.width===e.width&&this.height===e.height}area(){return this.width*this.height}}},"./src/core/speedy-vector.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyVector2:()=>n});class n{constructor(e,t){this._x=+e,this._y=+t}get x(){return this._x}set x(e){this._x=+e}get y(){return this._y}set y(e){this._y=+e}toString(){return`SpeedyVector2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`}equals(e){return this.x===e.x&&this.y===e.y}dot(e){return this.x*e.x+this.y*e.y}distanceTo(e){const t=this.x-e.x,i=this.y-e.y;return Math.sqrt(t*t+i*i)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalized(){const e=this.length();return e>0?new n(this.x/e,this.y/e):new n(0,0)}plus(e){return new n(this.x+e.x,this.y+e.y)}minus(e){return new n(this.x-e.x,this.y-e.y)}times(e){return new n(this.x*e,this.y*e)}}},"./src/gpu/programs/filters.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyProgramGroupFilters:()=>f}),i("./src/gpu/speedy-gpu.js");var n=i("./src/gpu/speedy-program-group.js"),s=i("./src/gpu/shader-declaration.js"),r=i("./src/gpu/shaders/filters/convolution.js"),o=i("./src/utils/utils.js");const a=(0,s.importShader)("filters/rgb2grey.glsl").withArguments("image"),c=[3,5,7].reduce(((e,t)=>(e[t]=(0,s.importShader)("filters/convolution2d.glsl").withDefines({KERNEL_SIZE_SQUARED:t*t}).withArguments("image","kernel"),e)),{}),p=[3,5,7,9,11,13,15].reduce(((e,t)=>(e[t]=(0,s.importShader)("filters/convolution1d.glsl").withDefines({KERNEL_SIZE:t,AXIS:0}).withArguments("image","kernel"),e)),{}),l=[3,5,7,9,11,13,15].reduce(((e,t)=>(e[t]=(0,s.importShader)("filters/convolution1d.glsl").withDefines({KERNEL_SIZE:t,AXIS:1}).withArguments("image","kernel"),e)),{}),A=[3,5,7].reduce(((e,t)=>(e[t]=(0,s.importShader)("filters/fast-median.glsl").withDefines({KERNEL_SIZE:t}).withArguments("image"),e)),{}),d=(0,s.importShader)("filters/normalize-image.glsl").withDefines({GREYSCALE:1}).withArguments("minmax2d","minValue","maxValue"),u=(0,s.importShader)("filters/normalize-image.glsl").withDefines({GREYSCALE:0}).withArguments("minmax2dRGB","minValue","maxValue"),g=(0,s.importShader)("filters/nightvision.glsl").withDefines({GREYSCALE:0}).withArguments("image","illuminationMap","gain","offset","decay"),h=(0,s.importShader)("filters/nightvision.glsl").withDefines({GREYSCALE:1}).withArguments("image","illuminationMap","gain","offset","decay"),I=e=>o.Utils.gaussianKernel((e=>Math.max(1,e/6))(e),e),m=e=>new Array(e).fill(1/e);class f extends n.SpeedyProgramGroup{constructor(e){super(e),this.declare("rgb2grey",a).declare("median3",A[3]).declare("median5",A[5]).declare("median7",A[7]).declare("convolution3",c[3]).declare("convolution5",c[5]).declare("convolution7",c[7]).declare("convolution3x",p[3]).declare("convolution3y",l[3]).declare("convolution5x",p[5]).declare("convolution5y",l[5]).declare("convolution7x",p[7]).declare("convolution7y",l[7]).declare("convolution9x",p[9]).declare("convolution9y",l[9]).declare("convolution11x",p[11]).declare("convolution11y",l[11]).declare("convolution13x",p[13]).declare("convolution13y",l[13]).declare("convolution15x",p[15]).declare("convolution15y",l[15]).declare("normalizeGreyscale",d).declare("normalizeColored",u).declare("nightvision",g).declare("nightvisionGreyscale",h).declare("illuminationMapLoX",(0,r.convX)(o.Utils.gaussianKernel(80,31))).declare("illuminationMapLoY",(0,r.convY)(o.Utils.gaussianKernel(80,31))).declare("illuminationMapX",(0,r.convX)(o.Utils.gaussianKernel(80,63))).declare("illuminationMapY",(0,r.convY)(o.Utils.gaussianKernel(80,63))).declare("illuminationMapHiX",(0,r.convX)(o.Utils.gaussianKernel(80,255))).declare("illuminationMapHiY",(0,r.convY)(o.Utils.gaussianKernel(80,255))).declare("gaussian3x",(0,r.convX)([.25,.5,.25])).declare("gaussian3y",(0,r.convY)([.25,.5,.25])).declare("gaussian5x",(0,r.convX)([.05,.25,.4,.25,.05])).declare("gaussian5y",(0,r.convY)([.05,.25,.4,.25,.05])).declare("gaussian7x",(0,r.convX)(I(7))).declare("gaussian7y",(0,r.convY)(I(7))).declare("gaussian9x",(0,r.convX)(I(9))).declare("gaussian9y",(0,r.convY)(I(9))).declare("gaussian11x",(0,r.convX)(I(11))).declare("gaussian11y",(0,r.convY)(I(11))).declare("box3x",(0,r.convX)(m(3))).declare("box3y",(0,r.convY)(m(3))).declare("box5x",(0,r.convX)(m(5))).declare("box5y",(0,r.convY)(m(5))).declare("box7x",(0,r.convX)(m(7))).declare("box7y",(0,r.convY)(m(7))).declare("box9x",(0,r.convX)(m(9))).declare("box9y",(0,r.convY)(m(9))).declare("box11x",(0,r.convX)(m(11))).declare("box11y",(0,r.convY)(m(11)))}}},"./src/gpu/programs/keypoints.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyProgramGroupKeypoints:()=>le}),i("./src/gpu/speedy-gpu.js");var n=i("./src/gpu/speedy-program-group.js"),s=(i("./src/gpu/speedy-texture.js"),i("./src/gpu/speedy-lsh.js")),r=i("./src/gpu/shader-declaration.js");const o=(0,r.importShader)("keypoints/fast.glsl","keypoints/fast.vs.glsl").withDefines({FAST_TYPE:916}).withArguments("corners","pyramid","lod","threshold"),a=[1,3,5,7].reduce(((e,t)=>(e[t]=(0,r.importShader)("keypoints/harris.glsl").withDefines({WINDOW_SIZE:t}).withArguments("corners","pyramid","derivatives","lod","lodStep","gaussian"),e)),{}),c=(0,r.importShader)("keypoints/score-findmax.glsl").withArguments("corners","iterationNumber"),p=(0,r.importShader)("keypoints/harris-cutoff.glsl").withArguments("corners","maxScore","quality"),l=(0,r.importShader)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:0}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),A=(0,r.importShader)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:1}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),d=(0,r.importShader)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:2}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),u=(0,r.importShader)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:3}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),g=(0,r.importShader)("keypoints/refine-scale.glsl").withDefines({METHOD:0}).withArguments("pyramid","lodStep","encodedKeypoints","descriptorSize","extraSize","encoderLength"),h=(0,r.importShader)("keypoints/refine-scale.glsl").withDefines({METHOD:1}).withArguments("pyramid","lodStep","encodedKeypoints","descriptorSize","extraSize","encoderLength","threshold"),I=(0,r.importShader)("keypoints/allocate-descriptors.glsl").withArguments("inputEncodedKeypoints","inputDescriptorSize","inputExtraSize","inputEncoderLength","outputDescriptorSize","outputExtraSize","outputEncoderLength"),m=(0,r.importShader)("keypoints/allocate-extra.glsl").withArguments("inputEncodedKeypoints","inputDescriptorSize","inputExtraSize","inputEncoderLength","outputDescriptorSize","outputExtraSize","outputEncoderLength"),f=(0,r.importShader)("keypoints/transfer-to-extra.glsl").withArguments("encodedData","strideOfEncodedData","encodedKeypoints","descriptorSize","extraSize","encoderLength"),y=(0,r.importShader)("keypoints/orb-descriptor.glsl").withArguments("image","encodedCorners","extraSize","encoderLength"),S=(0,r.importShader)("keypoints/orb-orientation.glsl").withArguments("image","encodedKeypoints","descriptorSize","extraSize","encoderLength"),_=(0,r.importShader)("keypoints/nonmax-suppression.glsl").withDefines({MULTISCALE:0}).withArguments("image","lodStep"),x=(0,r.importShader)("keypoints/nonmax-suppression.glsl").withDefines({MULTISCALE:1}).withArguments("image","lodStep"),C=(0,r.importShader)("keypoints/nonmax-space.glsl").withArguments("corners"),E=(0,r.importShader)("keypoints/nonmax-scale.glsl").withDefines({USE_LAPLACIAN:1}).withArguments("corners","pyramid","pyrLaplacian","lodStep"),P=(0,r.importShader)("keypoints/nonmax-scale.glsl").withDefines({USE_LAPLACIAN:0}).withArguments("corners","pyramid","lodStep"),v=(0,r.importShader)("keypoints/laplacian.glsl").withArguments("corners","pyramid","lodStep","lodOffset"),B=[3,5,7,9,11,13,15,17,19,21].reduce(((e,t)=>(e[t]=(0,r.importShader)("keypoints/lk.glsl").withDefines({WINDOW_SIZE:t}).withArguments("encodedFlow","prevKeypoints","nextPyramid","prevPyramid","level","depth","numberOfIterations","discardThreshold","epsilon","descriptorSize","extraSize","encoderLength"),e)),{}),M=(0,r.importShader)("keypoints/transfer-flow.glsl").withArguments("encodedFlow","encodedKeypoints","descriptorSize","extraSize","encoderLength"),w=(0,r.importShader)("keypoints/knn-init.glsl").withDefines({ENCODE_FILTERS:0}),b=(0,r.importShader)("keypoints/knn-init.glsl").withDefines({ENCODE_FILTERS:1}),Q=(0,r.importShader)("keypoints/knn-transfer.glsl").withArguments("encodedMatches","encodedKthMatches","numberOfMatchesPerKeypoint","kthMatch"),k=(0,r.importShader)("keypoints/bf-knn.glsl").withDefines({DESCRIPTOR_SIZE:32,NUMBER_OF_KEYPOINTS_PER_PASS:16}).withArguments("encodedMatches","encodedFilters","matcherLength","dbEncodedKeypoints","dbDescriptorSize","dbExtraSize","dbEncoderLength","encodedKeypoints","descriptorSize","extraSize","encoderLength","passId"),D=(0,r.importShader)("keypoints/bf-knn.glsl").withDefines({DESCRIPTOR_SIZE:64,NUMBER_OF_KEYPOINTS_PER_PASS:8}).withArguments("encodedMatches","encodedFilters","matcherLength","dbEncodedKeypoints","dbDescriptorSize","dbExtraSize","dbEncoderLength","encodedKeypoints","descriptorSize","extraSize","encoderLength","passId"),K=(0,r.importShader)("keypoints/knn-init.glsl").withDefines({ENCODE_FILTERS:0}),T=(0,r.importShader)("keypoints/knn-init.glsl").withDefines({ENCODE_FILTERS:1}),N=s.LSH_ACCEPTABLE_DESCRIPTOR_SIZES.reduce(((e,t)=>(e[t]=s.LSH_ACCEPTABLE_HASH_SIZES.reduce(((e,i)=>(e[i]=[0,1,2].reduce(((e,n)=>(e[n]=(0,r.importShader)("keypoints/lsh-knn.glsl").withDefines({DESCRIPTOR_SIZE:t,HASH_SIZE:i,LEVEL:n,SEQUENCE_MAXLEN:s.LSH_SEQUENCE_MAXLEN,SEQUENCE_COUNT:s.LSH_SEQUENCE_COUNT}).withArguments("candidates","filters","matcherLength","tables","descriptorDB","tableIndex","bucketCapacity","bucketsPerTable","tablesStride","descriptorDBStride","encodedKeypoints","descriptorSize","extraSize","encoderLength"),e)),{}),e)),{}),e)),{}),L=(0,r.importShader)("keypoints/knn-transfer.glsl").withArguments("encodedMatches","encodedKthMatches","numberOfMatchesPerKeypoint","kthMatch"),z=(0,r.importShader)("keypoints/sort-keypoints.glsl").withDefines({STAGE:1}).withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength"),R=(0,r.importShader)("keypoints/sort-keypoints.glsl").withDefines({STAGE:2}).withArguments("permutation","blockSize","dblLog2BlockSize"),O=(0,r.importShader)("keypoints/sort-keypoints.glsl").withDefines({STAGE:3}).withArguments("permutation","maxKeypoints","encodedKeypoints","descriptorSize","extraSize"),F=(0,r.importShader)("keypoints/mix-keypoints.glsl").withDefines({STAGE:1}).withArguments("encodedKeypointsA","encodedKeypointsB","encoderLengthA","encoderLengthB","encoderCapacityA","encoderCapacityB","descriptorSize","extraSize","encoderLength"),j=(0,r.importShader)("keypoints/mix-keypoints.glsl").withDefines({STAGE:2}).withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength","maxKeypoints"),X=(0,r.importShader)("keypoints/mix-keypoints.glsl").withDefines({STAGE:3}).withArguments("array","blockSize"),U=(0,r.importShader)("keypoints/mix-keypoints.glsl").withDefines({STAGE:5}).withArguments("array"),G=(0,r.importShader)("keypoints/mix-keypoints.glsl").withDefines({STAGE:4}).withArguments("array","encodedKeypoints","descriptorSize","extraSize","encoderLength"),H=(0,r.importShader)("keypoints/lookup-of-locations.glsl").withDefines({FS_OUTPUT_TYPE:2,STAGE:1}).withArguments("corners"),W=(0,r.importShader)("keypoints/lookup-of-locations.glsl","keypoints/lookup-of-locations.vs.glsl").withDefines({FS_OUTPUT_TYPE:2,FS_USE_CUSTOM_PRECISION:1,STAGE:2}).withArguments("lookupTable","blockSize","width","height"),q=(0,r.importShader)("keypoints/lookup-of-locations.glsl").withDefines({STAGE:-1}).withArguments("lookupTable"),Y=(0,r.importShader)("keypoints/encode-keypoints.glsl").withArguments("corners","lookupTable","stride","descriptorSize","extraSize","encoderLength","encoderCapacity"),J=(0,r.importShader)("keypoints/encode-keypoint-offsets.glsl").withArguments("corners","imageSize"),Z=(0,r.importShader)("keypoints/encode-keypoint-long-offsets.glsl").withDefines({MAX_ITERATIONS:6}).withArguments("offsetsImage","imageSize"),$=(0,r.importShader)("keypoints/encode-keypoint-positions.glsl").withArguments("offsetsImage","imageSize","passId","numPasses","keypointLimit","encodedKeypoints","descriptorSize","extraSize","encoderLength"),V=(0,r.importShader)("keypoints/encode-keypoint-properties.glsl").withArguments("corners","encodedKeypoints","descriptorSize","extraSize","encoderLength"),ee=(0,r.importShader)("keypoints/encode-null-keypoints.glsl").withArguments(),te=(0,r.importShader)("keypoints/transfer-orientation.glsl").withArguments("encodedOrientations","encodedKeypoints","descriptorSize","extraSize","encoderLength"),ie=(0,r.importShader)("keypoints/upload-keypoints.glsl").withDefines({BUFFER_SIZE:1024}).withArguments("encodedKeypoints","startIndex","endIndex","descriptorSize","extraSize","encoderLength"),ne=(0,r.importShader)("keypoints/apply-homography.glsl").withArguments("homography","encodedKeypoints","descriptorSize","extraSize","encoderLength"),se=(0,r.importShader)("keypoints/clip-border.glsl").withArguments("imageWidth","imageHeight","borderTop","borderRight","borderBottom","borderLeft","encodedKeypoints","descriptorSize","extraSize","encoderLength"),re=(0,r.importShader)("keypoints/distance-filter.glsl").withArguments("encodedKeypointsA","encoderLengthA","encodedKeypointsB","encoderLengthB","descriptorSize","extraSize","encoderLength","threshold"),oe=(0,r.importShader)("keypoints/hamming-distance-filter.glsl").withDefines({DESCRIPTOR_SIZE:32}).withArguments("encodedKeypointsA","encoderLengthA","encodedKeypointsB","encoderLengthB","descriptorSize","extraSize","encoderLength","threshold"),ae=(0,r.importShader)("keypoints/hamming-distance-filter.glsl").withDefines({DESCRIPTOR_SIZE:64}).withArguments("encodedKeypointsA","encoderLengthA","encodedKeypointsB","encoderLengthB","descriptorSize","extraSize","encoderLength","threshold"),ce=(0,r.importShader)("keypoints/shuffle.glsl").withDefines({PERMUTATION_MAXLEN:2048}).withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength"),pe=(0,r.importShader)("keypoints/clip.glsl").withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength","maxKeypoints");class le extends n.SpeedyProgramGroup{constructor(e){super(e),this.declare("fast9_16",o,{...this.program.usesPingpongRendering()}).declare("harris1",a[1],{...this.program.usesPingpongRendering()}).declare("harris3",a[3],{...this.program.usesPingpongRendering()}).declare("harris5",a[5],{...this.program.usesPingpongRendering()}).declare("harris7",a[7],{...this.program.usesPingpongRendering()}).declare("harrisScoreFindMax",c,{...this.program.usesPingpongRendering()}).declare("harrisScoreCutoff",p).declare("subpixelQuadratic1d",l).declare("subpixelTaylor2d",A).declare("subpixelBicubic",u).declare("subpixelBilinear",d).declare("refineScaleLoG",g).declare("refineScaleFAST916",h).declare("allocateDescriptors",I).declare("allocateExtra",m).declare("transferToExtra",f).declare("orbDescriptor",y).declare("orbOrientation",S).declare("nonmax",_).declare("pyrnonmax",x).declare("nonmaxSpace",C).declare("nonmaxScale",E).declare("nonmaxScaleSimple",P).declare("laplacian",v).declare("lk21",B[21],{...this.program.usesPingpongRendering()}).declare("lk19",B[19],{...this.program.usesPingpongRendering()}).declare("lk17",B[17],{...this.program.usesPingpongRendering()}).declare("lk15",B[15],{...this.program.usesPingpongRendering()}).declare("lk13",B[13],{...this.program.usesPingpongRendering()}).declare("lk11",B[11],{...this.program.usesPingpongRendering()}).declare("lk9",B[9],{...this.program.usesPingpongRendering()}).declare("lk7",B[7],{...this.program.usesPingpongRendering()}).declare("lk5",B[5],{...this.program.usesPingpongRendering()}).declare("lk3",B[3],{...this.program.usesPingpongRendering()}).declare("transferFlow",M).declare("bfMatcherInitCandidates",w).declare("bfMatcherInitFilters",b).declare("bfMatcherTransfer",Q,{...this.program.usesPingpongRendering()}).declare("bfMatcher32",k,{...this.program.usesPingpongRendering()}).declare("bfMatcher64",D,{...this.program.usesPingpongRendering()}).declare("lshKnnInitCandidates",K).declare("lshKnnInitFilters",T).declare("lshKnnTransfer",L,{...this.program.usesPingpongRendering()}).declare("sortCreatePermutation",z).declare("sortMergePermutation",R,{...this.program.usesPingpongRendering()}).declare("sortApplyPermutation",O).declare("mixKeypointsPreInit",F).declare("mixKeypointsInit",j).declare("mixKeypointsSort",X,{...this.program.usesPingpongRendering()}).declare("mixKeypointsView",U).declare("mixKeypointsApply",G).declare("encodeNullKeypoints",ee).declare("encodeKeypoints",Y).declare("initLookupTable",H).declare("sortLookupTable",W,{...this.program.usesPingpongRendering()}).declare("viewLookupTable",q).declare("encodeKeypointSkipOffsets",J).declare("encodeKeypointLongSkipOffsets",Z,{...this.program.usesPingpongRendering()}).declare("encodeKeypointPositions",$,{...this.program.usesPingpongRendering()}).declare("encodeKeypointProperties",V).declare("transferOrientation",te).declare("uploadKeypoints",ie,{...this.program.usesPingpongRendering()}).declare("applyHomography",ne).declare("clipBorder",se).declare("distanceFilter",re).declare("hammingDistanceFilter32",oe).declare("hammingDistanceFilter64",ae).declare("shuffle",ce).declare("clip",pe);for(const e of Object.keys(N))for(const t of Object.keys(N[e]))for(const i of Object.keys(N[e][t])){const n=`lshKnn${e}h${t}lv${i}`;this.declare(n,N[e][t][i],{...this.program.usesPingpongRendering()})}}}},"./src/gpu/programs/pyramids.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyProgramGroupPyramids:()=>c}),i("./src/gpu/speedy-gpu.js");var n=i("./src/gpu/speedy-program-group.js"),s=(i("./src/gpu/speedy-texture.js"),i("./src/gpu/shader-declaration.js")),r=i("./src/gpu/shaders/filters/convolution.js");const o=(0,s.importShader)("pyramids/upsample2.glsl").withArguments("image"),a=(0,s.importShader)("pyramids/downsample2.glsl").withArguments("image");class c extends n.SpeedyProgramGroup{constructor(e){super(e),this.declare("upsample2",o).declare("downsample2",a).declare("smoothX",(0,r.convX)([.05,.25,.4,.25,.05])).declare("smoothY",(0,r.convY)([.05,.25,.4,.25,.05])).declare("smoothX2",(0,r.convX)([.1,.5,.8,.5,.1])).declare("smoothY2",(0,r.convY)([.1,.5,.8,.5,.1],.5))}}},"./src/gpu/programs/transforms.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyProgramGroupTransforms:()=>p}),i("./src/gpu/speedy-gpu.js");var n=i("./src/gpu/speedy-program-group.js"),s=i("./src/gpu/shader-declaration.js");i("./src/utils/errors.js");const r=(0,s.importShader)("transforms/warp-perspective.glsl").withArguments("image","inverseHomography"),o=(0,s.importShader)("transforms/resize.glsl").withDefines({INTERPOLATION_METHOD:0}).withArguments("image"),a=(0,s.importShader)("transforms/resize.glsl").withDefines({INTERPOLATION_METHOD:1}).withArguments("image"),c=(0,s.importShader)("transforms/additive-mix.glsl").withArguments("image0","image1","alpha","beta","gamma");class p extends n.SpeedyProgramGroup{constructor(e){super(e),this.declare("warpPerspective",r).declare("resizeNearest",o).declare("resizeBilinear",a).declare("additiveMix",c)}}},"./src/gpu/programs/utils.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyProgramGroupUtils:()=>g}),i("./src/gpu/speedy-gpu.js");var n=i("./src/gpu/speedy-program-group.js"),s=(i("./src/gpu/speedy-texture.js"),i("./src/gpu/shader-declaration.js"));i("./src/utils/utils.js");const r=(0,s.importShader)("utils/copy.glsl").withArguments("image"),o=(0,s.importShader)("utils/copy-raster.glsl").withDefines({TYPE:1}).withArguments("image"),a=(0,s.importShader)("utils/copy-raster.glsl").withDefines({TYPE:2}).withArguments("image"),c=(0,s.importShader)("utils/copy.glsl","utils/flip-y.vs.glsl").withArguments("image"),p=(0,s.importShader)("utils/fill.glsl").withArguments("value"),l=(0,s.importShader)("utils/fill-components.glsl").withArguments("image","pixelComponents","value"),A=(0,s.importShader)("utils/copy-components.glsl").withArguments("dest","src","destComponents","srcComponentId"),d=(0,s.importShader)("utils/scan-minmax2d.glsl").withArguments("image","iterationNumber"),u=(0,s.importShader)("utils/sobel-derivatives.glsl","utils/sobel-derivatives.vs.glsl").withArguments("pyramid","lod");class g extends n.SpeedyProgramGroup{constructor(e){super(e),this.declare("renderToCanvas",c,{...this.program.rendersToCanvas()}).declare("copy",r).declare("copyKeypoints",o).declare("copy2DVectors",a).declare("fill",p).declare("fillComponents",l).declare("copyComponents",A).declare("scanMinMax2D",d,{...this.program.usesPingpongRendering()}).declare("sobelDerivatives",u)}}},"./src/gpu/shader-declaration.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{ShaderDeclaration:()=>d,importShader:()=>u,createShader:()=>g});var n=i("./src/gpu/shader-preprocessor.js"),s=i("./src/utils/errors.js");const r=Object.freeze({position:"a_position",texCoord:"a_texCoord"}),o=Object.freeze({position:0,texCoord:1}),a=`#version 300 es\nprecision highp float;\nprecision highp int;\n\nlayout (location=${o.position}) in vec2 ${r.position};\nlayout (location=${o.texCoord}) in vec2 ${r.texCoord};\nout highp vec2 texCoord;\nuniform highp vec2 texSize;\n\n#define vsinit() gl_Position = vec4(${r.position}, 0.0f, 1.0f); texCoord = ${r.texCoord};\n\n\n`,c="#define vsmain() ;",p="\n\nvoid main() { vsinit(); vsmain(); }\n",l='#version 300 es\n\n#if @FS_USE_CUSTOM_PRECISION@ == 0\nprecision mediump float; // ~float16\nprecision mediump sampler2D;\nprecision highp int; // int32\n#endif\n\n#if @FS_OUTPUT_TYPE@ == 0\n#define OUT_TYPE mediump vec4\n#elif @FS_OUTPUT_TYPE@ == 1\n#define OUT_TYPE mediump ivec4\n#elif @FS_OUTPUT_TYPE@ == 2\n#define OUT_TYPE mediump uvec4\n#else\n#error Unknown FS_OUTPUT_TYPE\n#endif\n\nout OUT_TYPE color;\nin highp vec2 texCoord;\nuniform highp vec2 texSize;\n\n@include "global.glsl"\n\n',A=Symbol();class d{constructor(e,t){if(t!==A)throw new s.IllegalOperationError;this._source=(()=>{switch(e.type){case"filepath":return i("./src/gpu/shaders sync recursive ^\\.\\/.*$")("./"+e.filepath);case"source":return e.source;default:return""}})(),this._vssource=(()=>{switch(e.type){case"filepath":return e.vsfilepath?i("./src/gpu/shaders sync recursive ^\\.\\/.*$")("./"+e.vsfilepath):c;case"source":return e.vssource?e.vssource:c;default:return""}})(),this._fragmentSource=n.ShaderPreprocessor.run(l+this._source),this._vertexSource=n.ShaderPreprocessor.run(a+this._vssource+p),this._filepath="filepath"===e.type?e.filepath:"<in-memory>",this._vsfilepath="filepath"===e.type&&e.vsfilepath?e.vsfilepath:"<in-memory>",this._arguments=[],this._uniforms=this._autodetectUniforms(this._fragmentSource+"\n"+this._vertexSource),this._defines=new Map}static create(e,t=null){return new d({type:"source",source:e,vssource:t},A)}static import(e,t=null){if(!String(e).match(/^[a-zA-Z0-9_\-/]+\.glsl$/))throw new s.FileNotFoundError(`Can't import fragment shader at "${e}"`);if(null!=t&&!String(t).match(/^[a-zA-Z0-9_\-/]+\.vs\.glsl$/))throw new s.FileNotFoundError(`Can't import vertex shader at "${t}"`);return new d({type:"filepath",filepath:e,vsfilepath:t},A)}withArguments(...e){if(this._arguments.length>0)throw new s.IllegalOperationError("Redefinition of shader arguments");this._arguments=e.map((e=>String(e)));for(const e of this._arguments)if(!this._uniforms.has(e)&&!this._uniforms.has(e+"[0]"))throw new s.IllegalArgumentError(`Argument "${e}" has not been declared in the shader`);return this}withDefines(e){if(this._defines.size>0)throw new s.IllegalOperationError("Redefinition of externally defined constants of a shader");const t=[],i=Object.keys(e);for(const n of i){const i=Number(e[n]);this._defines.set(n,i),t.push(`#define ${n} ${i}\n`)}const r=l+t.join("")+this._source,o=a+t.join("")+this._vssource+p;return this._fragmentSource=n.ShaderPreprocessor.run(r,this._defines),this._vertexSource=n.ShaderPreprocessor.run(o,this._defines),this._uniforms=this._autodetectUniforms(this._fragmentSource+"\n"+this._vertexSource),this}get fragmentSource(){return this._fragmentSource}get vertexSource(){return this._vertexSource}get attributes(){return r}get locationOfAttributes(){return o}get arguments(){return this._arguments}get uniforms(){return Array.from(this._uniforms.keys())}uniformType(e){if(!this._uniforms.has(e))throw new s.IllegalArgumentError(`Unrecognized uniform variable: "${e}"`);return this._uniforms.get(e)}definedConstant(e){if(!this._defines.has(e))throw new s.IllegalArgumentError(`Unrecognized externally defined constant: "${e}"`);return this._defines.get(e)}_autodetectUniforms(e){const t=e,i=/^\s*uniform\s+(highp\s+|mediump\s+|lowp\s+)?(\w+)\s+([^;]+)/gm,n=new Map;let r;for(;null!==(r=i.exec(t));){const e=r[2],t=r[3].split(",").map((e=>e.trim())).filter((e=>e));for(const i of t)if(i.endsWith("]")){if(!(r=i.match(/(\w+)\s*\[\s*(\d+)\s*\]$/)))throw new s.ParseError(`Unspecified array length for uniform "${i}" in the shader`);const[t,o]=[r[1],Number(r[2])];for(let i=0;i<o;i++)n.set(`${t}[${i}]`,e)}else{if(n.has(i)&&n.get(i)!==e)throw new s.IllegalOperationError(`Redefinition of uniform "${i}" in the shader`);n.set(i,e)}}return n}}function u(e,t=null){return d.import(e,t)}function g(e,t=null){return d.create(e,t)}},"./src/gpu/shader-preprocessor.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{ShaderPreprocessor:()=>u});var n=i("./src/utils/utils.js"),s=i("./src/utils/types.js"),r=i("./src/utils/errors.js");const o=i("./src/utils/globals.js"),a=Object.keys(o).filter((e=>"number"==typeof o[e])).reduce(((e,t)=>(e[t]=o[t],e)),{}),c=Object.freeze({...a,FS_USE_CUSTOM_PRECISION:0,FS_OUTPUT_TYPE:0,PIXELCOMPONENT_RED:s.PixelComponent.RED,PIXELCOMPONENT_GREEN:s.PixelComponent.GREEN,PIXELCOMPONENT_BLUE:s.PixelComponent.BLUE,PIXELCOMPONENT_ALPHA:s.PixelComponent.ALPHA}),p=[/\/\*(.|\s)*?\*\//g,/\/\/.*$/gm],l=/^\s*@\s*include\s+"(.*?)"/gm,A=/@(\w+)@/g,d=[/@\s*unroll\s+?for\s*\(\s*(int|)\s*(?<counter>\w+)\s*=\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*(<=?)\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*\+\+()\s*\)\s*\{\s*([\s\S]+?)\s*\}/g,/@\s*unroll\s+?for\s*\(\s*(int|)\s*(?<counter>\w+)\s*=\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*(<=?)\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*\+=\s*(-?\d+)\s*\)\s*\{\s*([\s\S]+?)\s*\}/g];class u{static run(e,t=new Map){const n=[];return function(e,t){const i=g.bind(t),n=d.length;for(let t=0;t<n;t++)e=e.replace(d[t],i);return e}(String(e).replace(p[0],"").replace(p[1],"").replace(l,((e,n)=>u.run(function(e){if(String(e).match(/^[a-zA-Z0-9_-]+\.glsl$/))return i("./src/gpu/shaders/include sync recursive ^\\.\\/.*$")("./"+e);throw new r.FileNotFoundError(`Shader preprocessor: can't read file "${e}"`)}(n),t))).replace(A,((e,i)=>String(t.has(i)?Number(t.get(i)):void 0!==c[i]?Number(c[i]):(n.push(`Undefined constant: ${i}`),0)))),t)+(n.length>0?n.map((e=>`\n#error ${e}\n`)).join(""):"")}}function g(e,t,i,s,o,a,c,p){const l=this,A=Number.isFinite(+s)||l.has(s),d=Number.isFinite(+a)||l.has(a);if(!A||!d){if(l.size>0)throw new r.ParseError(`Can't unroll loop: unknown limits (start=${s}, end=${a}). Code:\n\n${e}`);return e}let u=l.has(s)?l.get(s):parseInt(s),g=l.has(a)?l.get(a):parseInt(a),h=0==c.length?1:parseInt(c);n.Utils.assert(u<=g&&h>0);let I=null!==p.match(/\bbreak\s*;/)?"switch(1) { default:\n":"{\n";I+=`${t} ${i};\n`,g+="<="==o?1:0;for(let e=u;e<g;e+=h)I+=`{\n${i} = ${e};\n${p}\n}\n`;return I+="}\n",I}},"./src/gpu/shaders/filters/convolution.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{conv2D:()=>o,convX:()=>a,convY:()=>c});var n=i("./src/gpu/shader-declaration.js"),s=i("./src/utils/utils.js"),r=i("./src/utils/errors.js");function o(e,t=1){const i=new Float32Array(e.map((e=>+e*+t))),o=0|Math.sqrt(i.length),a=o>>1;if(o<1||o%2==0)throw new r.IllegalArgumentError(`Can't perform a 2D convolution with an invalid kSize of ${o}`);if(o*o!=i.length)throw new r.IllegalArgumentError(`Invalid 2D convolution kernel of ${i.length} elements (expected: square)`);const c=a<=7?"pixelAtShortOffset":"pixelAtLongOffset",p=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 result = vec4(0.0f);\n\n        ${l=(e,t,i)=>`\n        result += ${c}(image, ivec2(${0|-i}, ${0|-t})) * float(${+e});\n    `,s.Utils.cartesian(s.Utils.symmetricRange(a),s.Utils.symmetricRange(a)).map((e=>l(i[(e[0]+a)*o+(e[1]+a)],e[0],e[1]))).join("\n")}\n\n        color = vec4(result.rgb, alpha);\n    }\n    `;var l;return(0,n.createShader)(p).withArguments("image")}function a(e,t=1){return p("x",e,t)}function c(e,t=1){return p("y",e,t)}function p(e,t,i=1){const o=new Float32Array(t.map((e=>+e*+i))),a=o.length,c=a>>1;if(a<1||a%2==0)throw new r.IllegalArgumentError(`Can't perform a 1D convolution with an invalid kSize of ${a}`);if("x"!=e&&"y"!=e)throw new r.IllegalArgumentError(`Can't perform 1D convolution: invalid axis "${e}"`);const p=c<=7?"pixelAtShortOffset":"pixelAtLongOffset",l=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f);\n\n        ${A=(t,i)=>"x"==e?`\n        pixel += ${p}(image, ivec2(${0|-i}, 0)) * float(${+t});\n    `:`\n        pixel += ${p}(image, ivec2(0, ${0|-i})) * float(${+t});\n    `,s.Utils.symmetricRange(c).reduce(((e,t)=>e+A(o[t+c],t)),"")}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;var A;return(0,n.createShader)(l).withArguments("image")}},"./src/gpu/shaders/include sync recursive ^\\.\\/.*$":(e,t,i)=>{var n={"./colors.glsl":"./src/gpu/shaders/include/colors.glsl","./filters.glsl":"./src/gpu/shaders/include/filters.glsl","./fixed-point.glsl":"./src/gpu/shaders/include/fixed-point.glsl","./float16.glsl":"./src/gpu/shaders/include/float16.glsl","./global.glsl":"./src/gpu/shaders/include/global.glsl","./int32.glsl":"./src/gpu/shaders/include/int32.glsl","./keypoint-descriptors.glsl":"./src/gpu/shaders/include/keypoint-descriptors.glsl","./keypoint-matches.glsl":"./src/gpu/shaders/include/keypoint-matches.glsl","./keypoints.glsl":"./src/gpu/shaders/include/keypoints.glsl","./math.glsl":"./src/gpu/shaders/include/math.glsl","./pyramids.glsl":"./src/gpu/shaders/include/pyramids.glsl","./subpixel.glsl":"./src/gpu/shaders/include/subpixel.glsl"};function s(e){var t=r(e);return i(t)}function r(e){if(!i.o(n,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n[e]}s.keys=function(){return Object.keys(n)},s.resolve=r,e.exports=s,s.id="./src/gpu/shaders/include sync recursive ^\\.\\/.*$"},"./src/gpu/shaders sync recursive ^\\.\\/.*$":(e,t,i)=>{var n={"./filters/convolution":"./src/gpu/shaders/filters/convolution.js","./filters/convolution.js":"./src/gpu/shaders/filters/convolution.js","./filters/convolution1d.glsl":"./src/gpu/shaders/filters/convolution1d.glsl","./filters/convolution2d.glsl":"./src/gpu/shaders/filters/convolution2d.glsl","./filters/fast-median.glsl":"./src/gpu/shaders/filters/fast-median.glsl","./filters/nightvision.glsl":"./src/gpu/shaders/filters/nightvision.glsl","./filters/normalize-image.glsl":"./src/gpu/shaders/filters/normalize-image.glsl","./filters/rgb2grey.glsl":"./src/gpu/shaders/filters/rgb2grey.glsl","./include/colors.glsl":"./src/gpu/shaders/include/colors.glsl","./include/filters.glsl":"./src/gpu/shaders/include/filters.glsl","./include/fixed-point.glsl":"./src/gpu/shaders/include/fixed-point.glsl","./include/float16.glsl":"./src/gpu/shaders/include/float16.glsl","./include/global.glsl":"./src/gpu/shaders/include/global.glsl","./include/int32.glsl":"./src/gpu/shaders/include/int32.glsl","./include/keypoint-descriptors.glsl":"./src/gpu/shaders/include/keypoint-descriptors.glsl","./include/keypoint-matches.glsl":"./src/gpu/shaders/include/keypoint-matches.glsl","./include/keypoints.glsl":"./src/gpu/shaders/include/keypoints.glsl","./include/math.glsl":"./src/gpu/shaders/include/math.glsl","./include/pyramids.glsl":"./src/gpu/shaders/include/pyramids.glsl","./include/subpixel.glsl":"./src/gpu/shaders/include/subpixel.glsl","./keypoints/allocate-descriptors.glsl":"./src/gpu/shaders/keypoints/allocate-descriptors.glsl","./keypoints/allocate-extra.glsl":"./src/gpu/shaders/keypoints/allocate-extra.glsl","./keypoints/apply-homography.glsl":"./src/gpu/shaders/keypoints/apply-homography.glsl","./keypoints/bf-knn.glsl":"./src/gpu/shaders/keypoints/bf-knn.glsl","./keypoints/clip-border.glsl":"./src/gpu/shaders/keypoints/clip-border.glsl","./keypoints/clip.glsl":"./src/gpu/shaders/keypoints/clip.glsl","./keypoints/distance-filter.glsl":"./src/gpu/shaders/keypoints/distance-filter.glsl","./keypoints/encode-keypoint-long-offsets.glsl":"./src/gpu/shaders/keypoints/encode-keypoint-long-offsets.glsl","./keypoints/encode-keypoint-offsets.glsl":"./src/gpu/shaders/keypoints/encode-keypoint-offsets.glsl","./keypoints/encode-keypoint-positions.glsl":"./src/gpu/shaders/keypoints/encode-keypoint-positions.glsl","./keypoints/encode-keypoint-properties.glsl":"./src/gpu/shaders/keypoints/encode-keypoint-properties.glsl","./keypoints/encode-keypoints.glsl":"./src/gpu/shaders/keypoints/encode-keypoints.glsl","./keypoints/encode-null-keypoints.glsl":"./src/gpu/shaders/keypoints/encode-null-keypoints.glsl","./keypoints/fast.glsl":"./src/gpu/shaders/keypoints/fast.glsl","./keypoints/fast.vs.glsl":"./src/gpu/shaders/keypoints/fast.vs.glsl","./keypoints/hamming-distance-filter.glsl":"./src/gpu/shaders/keypoints/hamming-distance-filter.glsl","./keypoints/harris-cutoff.glsl":"./src/gpu/shaders/keypoints/harris-cutoff.glsl","./keypoints/harris.glsl":"./src/gpu/shaders/keypoints/harris.glsl","./keypoints/knn-init.glsl":"./src/gpu/shaders/keypoints/knn-init.glsl","./keypoints/knn-transfer.glsl":"./src/gpu/shaders/keypoints/knn-transfer.glsl","./keypoints/laplacian.glsl":"./src/gpu/shaders/keypoints/laplacian.glsl","./keypoints/lk.glsl":"./src/gpu/shaders/keypoints/lk.glsl","./keypoints/lookup-of-locations.glsl":"./src/gpu/shaders/keypoints/lookup-of-locations.glsl","./keypoints/lookup-of-locations.vs.glsl":"./src/gpu/shaders/keypoints/lookup-of-locations.vs.glsl","./keypoints/lsh-knn.glsl":"./src/gpu/shaders/keypoints/lsh-knn.glsl","./keypoints/mix-keypoints.glsl":"./src/gpu/shaders/keypoints/mix-keypoints.glsl","./keypoints/nonmax-scale.glsl":"./src/gpu/shaders/keypoints/nonmax-scale.glsl","./keypoints/nonmax-space.glsl":"./src/gpu/shaders/keypoints/nonmax-space.glsl","./keypoints/nonmax-suppression.glsl":"./src/gpu/shaders/keypoints/nonmax-suppression.glsl","./keypoints/orb-descriptor.glsl":"./src/gpu/shaders/keypoints/orb-descriptor.glsl","./keypoints/orb-orientation.glsl":"./src/gpu/shaders/keypoints/orb-orientation.glsl","./keypoints/refine-scale.glsl":"./src/gpu/shaders/keypoints/refine-scale.glsl","./keypoints/score-findmax.glsl":"./src/gpu/shaders/keypoints/score-findmax.glsl","./keypoints/shuffle.glsl":"./src/gpu/shaders/keypoints/shuffle.glsl","./keypoints/sort-keypoints.glsl":"./src/gpu/shaders/keypoints/sort-keypoints.glsl","./keypoints/subpixel-refinement.glsl":"./src/gpu/shaders/keypoints/subpixel-refinement.glsl","./keypoints/transfer-flow.glsl":"./src/gpu/shaders/keypoints/transfer-flow.glsl","./keypoints/transfer-orientation.glsl":"./src/gpu/shaders/keypoints/transfer-orientation.glsl","./keypoints/transfer-to-extra.glsl":"./src/gpu/shaders/keypoints/transfer-to-extra.glsl","./keypoints/upload-keypoints.glsl":"./src/gpu/shaders/keypoints/upload-keypoints.glsl","./pyramids/downsample2.glsl":"./src/gpu/shaders/pyramids/downsample2.glsl","./pyramids/upsample2.glsl":"./src/gpu/shaders/pyramids/upsample2.glsl","./transforms/additive-mix.glsl":"./src/gpu/shaders/transforms/additive-mix.glsl","./transforms/resize.glsl":"./src/gpu/shaders/transforms/resize.glsl","./transforms/warp-perspective.glsl":"./src/gpu/shaders/transforms/warp-perspective.glsl","./utils/copy-components.glsl":"./src/gpu/shaders/utils/copy-components.glsl","./utils/copy-raster.glsl":"./src/gpu/shaders/utils/copy-raster.glsl","./utils/copy.glsl":"./src/gpu/shaders/utils/copy.glsl","./utils/fill-components.glsl":"./src/gpu/shaders/utils/fill-components.glsl","./utils/fill.glsl":"./src/gpu/shaders/utils/fill.glsl","./utils/flip-y.vs.glsl":"./src/gpu/shaders/utils/flip-y.vs.glsl","./utils/scan-minmax2d.glsl":"./src/gpu/shaders/utils/scan-minmax2d.glsl","./utils/sobel-derivatives.glsl":"./src/gpu/shaders/utils/sobel-derivatives.glsl","./utils/sobel-derivatives.vs.glsl":"./src/gpu/shaders/utils/sobel-derivatives.vs.glsl"};function s(e){var t=r(e);return i(t)}function r(e){if(!i.o(n,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n[e]}s.keys=function(){return Object.keys(n)},s.resolve=r,e.exports=s,s.id="./src/gpu/shaders sync recursive ^\\.\\/.*$"},"./src/gpu/speedy-descriptordb.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyDescriptorDB:()=>o}),i("./src/gpu/speedy-texture.js");var n=i("./src/core/speedy-namespace.js"),s=i("./src/utils/utils.js"),r=i("./src/utils/errors.js");class o extends n.SpeedyNamespace{static create(e,t,i){s.Utils.assert(i%4==0,`Invalid descriptorSize: ${i}`);const n=t.length,o=i/4,a=Math.log2(o*Math.max(n,1))/2,c=1<<Math.min(11,Math.ceil(a)),p=c,l=c,A=p*l/o;if(n>A)throw new r.NotSupportedError(`The capacity of the descriptorDB (${A} for ${8*i}-bit descriptors) has been exceeded`);const d=new Uint8Array(p*l*4);for(let e=0;e<n;e++){const n=e*i,r=t[e];s.Utils.assert(r.byteLength===i),s.Utils.assert(n+i<=d.byteLength),d.set(r,n)}const u=n*i;return s.Utils.log(`Creating a ${p}x${l} database of ${n} `+8*i+"-bit descriptors "+`(total size: ${(u/1048576).toFixed(2)} MB)`),e.resize(p,l),e.upload(d),e}}},"./src/gpu/speedy-gl.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyGL:()=>l});var n=i("./src/utils/utils.js"),s=i("./src/utils/observable.js"),r=i("./src/core/speedy-promise.js"),o=i("./src/utils/errors.js");const a=Symbol();let c=null,p="default";class l extends s.Observable{constructor(e){n.Utils.assert(e===a),super(),this._reinitializeOnContextLoss=!0,this._canvas=this._createCanvas(this._reinitialize.bind(this)),this._gl=null,this._gl=this._createContext(this._canvas)}static get instance(){return c||(c=new l(a))}get gl(){return this._gl}get canvas(){return this._canvas}_createCanvas(e){const t=n.Utils.createCanvas(16,16);return t.addEventListener("webglcontextlost",(t=>{n.Utils.warning("Lost WebGL2 context"),setTimeout(e,0),t.preventDefault()}),!1),t}_createContext(e){if(n.Utils.log(`Creating a ${p} WebGL2 rendering context...`),"undefined"==typeof WebGL2RenderingContext)throw new o.NotSupportedError("This application requires WebGL2. Please use a different browser.");const t=e.getContext("webgl2",{premultipliedAlpha:!1,preserveDrawingBuffer:!1,powerPreference:p,alpha:!0,antialias:!1,depth:!1,stencil:!1,desynchronized:!0});if(!t)throw new o.NotSupportedError("Can't create a WebGL2 Rendering Context. Try a different browser!");return t}_reinitialize(){this._reinitializeOnContextLoss&&(n.Utils.warning("Reinitializing WebGL2..."),this._canvas.remove(),this._canvas=this._createCanvas(this._reinitialize.bind(this)),this._gl=this._createContext(this._canvas),this._notify())}loseContext(){const e=this._gl;if(e.isContextLost())return;const t=e.getExtension("WEBGL_lose_context");if(!t)throw new o.NotSupportedError("WEBGL_lose_context extension is unavailable");return this._reinitializeOnContextLoss=!1,t.loseContext(),t}loseAndRestoreContext(e=1){const t=1e3*Math.max(e,0),i=this.loseContext();return new r.SpeedyPromise((e=>{setTimeout((()=>{this._reinitializeOnContextLoss=!0,this._reinitialize(),setTimeout((()=>e(i)),0)}),t)}))}static get powerPreference(){return p}static set powerPreference(e){if("default"!==e&&"low-power"!==e&&"high-performance"!==e)throw new o.IllegalArgumentError(`Invalid powerPreference: "${e}"`);null!=c&&p===e||(p=e,null!=c&&c.loseAndRestoreContext())}}},"./src/gpu/speedy-gpu.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyGPU:()=>p});var n=i("./src/gpu/speedy-gl.js"),s=(i("./src/gpu/speedy-texture.js"),i("./src/gpu/speedy-program-center.js")),r=i("./src/gpu/speedy-texture-pool.js"),o=i("./src/gpu/speedy-texture-uploader.js"),a=(i("./src/core/speedy-media-source.js"),i("./src/core/speedy-promise.js"),i("./src/utils/utils.js")),c=i("./src/utils/observable.js");class p extends c.Observable{constructor(){super(),this._speedyGL=n.SpeedyGL.instance,this._programs=new s.SpeedyProgramCenter(this),this._texturePool=new r.SpeedyTexturePool(this),this._textureUploader=new o.SpeedyTextureUploader(this),this._speedyGL.subscribe(this._reset,this)}get programs(){return this._programs}get gl(){return this._speedyGL.gl}get canvas(){return this._speedyGL.canvas}get texturePool(){return this._texturePool}renderToCanvas(e){const t=e.width,i=e.height,n=this.canvas;return(t>n.width||i>n.height)&&(a.Utils.warning(`Resizing the canvas to ${t} x ${i}`),n.width=t,n.height=i),this.programs.utils.renderToCanvas.outputs(t,i,null),this.programs.utils.renderToCanvas(e),n}upload(e,t){return this._textureUploader.upload(e,t)}release(){return a.Utils.assert(!this.isReleased()),this._programs=this._programs.release(),this._texturePool=this._texturePool.release(),this._textureUploader=this._textureUploader.release(),this._speedyGL.unsubscribe(this._reset),null}isReleased(){return null==this._programs}loseAndRestoreWebGLContext(){return this._speedyGL.loseAndRestoreContext().then((()=>{}))}_reset(){this.isReleased()||(this._programs=new s.SpeedyProgramCenter(this),this._texturePool=new r.SpeedyTexturePool(this),this._textureUploader=new o.SpeedyTextureUploader(this),this._notify())}}},"./src/gpu/speedy-lsh.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{LSH_DEFAULT_NUMBER_OF_TABLES:()=>o,LSH_DEFAULT_HASH_SIZE:()=>a,LSH_ACCEPTABLE_NUMBER_OF_TABLES:()=>c,LSH_ACCEPTABLE_HASH_SIZES:()=>p,LSH_ACCEPTABLE_DESCRIPTOR_SIZES:()=>l,LSH_SEQUENCE_MAXLEN:()=>A,LSH_SEQUENCE_COUNT:()=>d,SpeedyLSH:()=>I}),i("./src/gpu/speedy-texture.js");var n=i("./src/gpu/speedy-descriptordb.js"),s=i("./src/utils/utils.js"),r=i("./src/utils/globals.js");const o=8,a=15,c=[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],p=[10,11,12,13,14,15,16,17,18,19,20],l=[32,64],A=Math.max(...p),d=Math.max(...c),u=e=>(s.Utils.range(d).forEach((t=>e.subarray(t*A,(t+1)*A).sort())),e),g=(e,t)=>(s.Utils.range(d).forEach((i=>t.subarray((i+1)*A-e,(i+1)*A).fill(195939070))),t),h=p.reduce(((e,t)=>{return e[t]={32:u(g(A-(i=t),new Uint32Array([...s.Utils.shuffle(s.Utils.range(256)),...s.Utils.shuffle(s.Utils.range(256)),...s.Utils.shuffle(s.Utils.range(256))].slice(0,d*A)))),64:u(g(A-i,new Uint32Array([...s.Utils.shuffle(s.Utils.range(512)),...s.Utils.shuffle(s.Utils.range(512))].slice(0,d*A))))},e;var i}),{});class I{constructor(e,t,i,A=o,d=a,u=.95){const g=i.length,h=g>0?i[0].byteLength:0,I=(m=A,y=d,S=u,p.includes(y)&&c.includes(m)?[{name:"x-small",bucketCapacity:1,tableCount:m,hashSize:y,capacity:f(y,1,S)},{name:"small",bucketCapacity:2,tableCount:m,hashSize:y,capacity:f(y,2,S)},{name:"small-plus",bucketCapacity:3,tableCount:m,hashSize:y,capacity:f(y,3,S)},{name:"medium",bucketCapacity:4,tableCount:m,hashSize:y,capacity:f(y,4,S)},{name:"medium-plus",bucketCapacity:5,tableCount:m,hashSize:y,capacity:f(y,5,S)},{name:"large",bucketCapacity:6,tableCount:m,hashSize:y,capacity:f(y,6,S)},{name:"x-large",bucketCapacity:8,tableCount:m,hashSize:y,capacity:f(y,8,S)}]:null);var m,y,S;s.Utils.assert(g>0,"Can't build LSH tables without descriptors!"),s.Utils.assert(l.includes(h),`Can't build LSH tables: unacceptable descriptor size of ${h} bytes`),s.Utils.assert(i.findIndex((e=>e.byteLength!==h))<0,`Can't build LSH tables: incorrectly sized descriptors. Expected ${h} bytes for each`),s.Utils.assert(g<r.MATCH_MAX_INDEX,`Can't build LSH tables: too many descriptors (${i.length})`),s.Utils.assert(null!=I,`Can't build LSH tables: unacceptable number of tables (${A}) x hash size (${d})`),this._profile=I.find((e=>g<=e.capacity))||I[I.length-1],this._descriptorSize=h,this._descriptorCount=g,this._sequences=this._pickSequences(this._descriptorSize),this._tables=this._createStaticTables(e,this._sequences,i,h),this._descriptorDB=n.SpeedyDescriptorDB.create(t,i,h)}get descriptorSize(){return this._descriptorSize}get descriptorCount(){return this._descriptorCount}get sequences(){return this._sequences}get hashSize(){return this._profile.hashSize}get bucketCapacity(){return this._profile.bucketCapacity}get bucketsPerTable(){return 1<<this._profile.hashSize}get tableCount(){return this._profile.tableCount}get tableSize(){return this.bucketsPerTable*this.bucketCapacity*4}get totalSize(){return this.tableCount*this.tableSize}get tables(){return this._tables}get descriptorDB(){return this._descriptorDB}_pickSequences(e){return s.Utils.assert(Object.prototype.hasOwnProperty.call(h,this.hashSize)),s.Utils.assert(Object.prototype.hasOwnProperty.call(h[this.hashSize],e)),h[this.hashSize][e]}_createStaticTables(e,t,i,n){const r=4294967295,o=this._profile.name,a=this._profile.capacity,c=this.tableCount,p=this.bucketsPerTable,l=4*this.bucketCapacity,u=this.hashSize,g=this.tableCount*this.bucketsPerTable*this.bucketCapacity,h=Math.min((I=Math.sqrt(g))>1?1<<Math.ceil(Math.log2(I)):1,4096);var I;const m=Math.ceil(g/h),f=i.length;s.Utils.assert(u<=A),s.Utils.assert(c<=d),s.Utils.assert(g<=h*m);const y=1048576;if(s.Utils.log(`Building ${c} ${o} LSH tables with ${f} ${8*n}-bit descriptors each and hashSize = ${u} bits (${h}x${m}, with ${(this.tableSize/y).toFixed(2)} MB per table and total size = ${(this.totalSize/y).toFixed(2)} MB), `),f>a){const e=100*f/a;s.Utils.warning(`There are too many descriptors (${f}) for a ${o} LSH table. That's ${e.toFixed(2)}% of its theoretical capacity. Consider increasing the hashSize (currently set to ${u}) or reducing the number of descriptors to avoid degradation.`)}const S=new ArrayBuffer(h*m*4),_=new Uint8Array(S).fill(255),x=new DataView(S),C=s.Utils.shuffle(s.Utils.range(f)),E=new Array(c).fill(0);for(let e=0;e<f;e++){const n=C[e],s=this._hashCodes(i[n],t);for(let e=0;e<c;e++){const t=e*p*l+s[e]*l;let i=r;for(let e=0;e<l;e+=4){const s=t+e;if(i=x.getUint32(s,!0),i==r){x.setUint32(s,n,!0);break}}i!=r&&E[e]++}}const P=E.reduce(((e,t)=>e+t),0),v=E.map((e=>100*e/f));return s.Utils.log(`When building ${c} ${o} LSH tables with ${f} ${8*n}-bit descriptors each and hashSize = ${u} bits, I got the following discard profile: `+v.map((e=>e.toFixed(2)+"%")).join(", ")+". "+`Average: ${(100*P/(c*f)).toFixed(2)}%. `+`Minimum: ${Math.min(...v).toFixed(2)}%. `+`Table capacity: ${a}.`),e.resize(h,m),e.upload(_),e}_hashCodes(e,t){const i=this.tableCount,n=this.hashSize,r=this.bucketsPerTable,o=new Array(i);s.Utils.assert(n<=A&&t.length>=A*i);for(let a=0;a<i;a++){const i=A*a;let c=0;for(let s=0;s<n;s++){let n=t[i+s],r=1<<(7&n);c=c<<1|0!=(e[n>>>3]&r)}s.Utils.assert(c>=0&&c<r),o[a]=c}return o}}function m(e,t){const i=Math.exp(-e);let n=1,s=1,r=1;for(let i=1;i<=t;i++)n+=(r*=e)/(s*=i);return n*i}function f(e,t,i=.99){const n=1<<e,s=t,r=i;let o=1,a=n*s,c=0,p=0;for(;o<a;)c=Math.floor((o+a)/2),p=m(c/n,s),p>r?o=c+1:a=c;return c}},"./src/gpu/speedy-program-center.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyProgramCenter:()=>p}),i("./src/gpu/speedy-gpu.js");var n=i("./src/gpu/programs/utils.js"),s=i("./src/gpu/programs/filters.js"),r=i("./src/gpu/programs/keypoints.js"),o=i("./src/gpu/programs/pyramids.js"),a=i("./src/gpu/programs/transforms.js"),c=i("./src/gpu/speedy-program-group.js");class p{constructor(e){this._gpu=e,this._filters=null,this._transforms=null,this._pyramids=null,this._keypoints=null,this._utils=null}get filters(){return this._filters||(this._filters=new s.SpeedyProgramGroupFilters(this._gpu))}get transforms(){return this._transforms||(this._transforms=new a.SpeedyProgramGroupTransforms(this._gpu))}get pyramids(){return this._pyramids||(this._pyramids=new o.SpeedyProgramGroupPyramids(this._gpu))}get keypoints(){return this._keypoints||(this._keypoints=new r.SpeedyProgramGroupKeypoints(this._gpu))}get utils(){return this._utils||(this._utils=new n.SpeedyProgramGroupUtils(this._gpu))}release(){for(const e in this)if(Object.prototype.hasOwnProperty.call(this,e)&&null!=this[e]){const t=this[e];t instanceof c.SpeedyProgramGroup&&t.release()}return null}}},"./src/gpu/speedy-program-group.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyProgramGroup:()=>r}),i("./src/gpu/shader-declaration.js");var n=i("./src/gpu/speedy-program.js");i("./src/gpu/speedy-gpu.js");const s=Object.freeze({usesPingpongRendering:()=>({pingpong:!0}),rendersToCanvas:()=>({renderToTexture:!1})});class r{constructor(e){this._gpu=e,this._programs=[]}declare(e,t,i={}){return Object.defineProperty(this,e,{get:(()=>{const n=Symbol(e);return()=>this[n]||(this[n]=this._createProgram(t,i))})()}),this}get program(){return s}release(){for(let e=0;e<this._programs.length;e++)this._programs[e].release();return null}_createProgram(e,t={}){const i=new n.SpeedyProgram(this._gpu.gl,e,t);return this._programs.push(i),i}}},"./src/gpu/speedy-program.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyProgram:()=>o}),i("./src/gpu/speedy-texture.js"),i("./src/core/speedy-promise.js"),i("./src/gpu/shader-declaration.js");var n=i("./src/utils/utils.js"),s=i("./src/utils/errors.js");const r=Object.freeze({sampler2D:"uniform1i",isampler2D:"uniform1i",usampler2D:"uniform1i",float:"uniform1f",int:"uniform1i",uint:"uniform1ui",bool:"uniform1i",vec2:"uniform2f",vec3:"uniform3f",vec4:"uniform4f",ivec2:"uniform2i",ivec3:"uniform3i",ivec4:"uniform4i",uvec2:"uniform2ui",uvec3:"uniform3ui",uvec4:"uniform4ui",bvec2:"uniform2i",bvec3:"uniform3i",bvec4:"uniform4i",mat2:"uniformMatrix2fv",mat3:"uniformMatrix3fv",mat4:"uniformMatrix4fv"});class o extends Function{constructor(e,t,i={}){return super("...args","return this._self._call(...args)"),this._self=this.bind(this),this._self._init(e,t,i),this._self}_init(e,t,i){if(e.isContextLost())throw new s.IllegalOperationError("Can't initialize SpeedyProgram: lost context");i=Object.assign({renderToTexture:!0,pingpong:!1},i),this._gl=e,this._program=o._compile(e,t.vertexSource,t.fragmentSource),this._geometry=new a(e,{position:t.locationOfAttributes.position,texCoord:t.locationOfAttributes.texCoord}),this._argnames=t.arguments,this._argIsArray=new Array(this._argnames.length).fill(!1),this._ubo=null,this._renderToTexture=Boolean(i.renderToTexture),this._width=1,this._height=1,this._texture=new Array(i.pingpong?2:1).fill(null),this._textureIndex=0,this._uniform=new Map,this._shaderdecl=t,e.useProgram(this._program);for(const i of t.uniforms){const n=t.uniformType(i),s=e.getUniformLocation(this._program,i);this._uniform.set(i,new c(n,s))}for(let e=0;e<this._argnames.length;e++){const t=this._argnames[e];if(!this._uniform.has(t)&&(this._argIsArray[e]=this._uniform.has(t+"[0]"),!this._argIsArray[e]))throw new s.IllegalOperationError(`Expected uniform "${t}", as declared in the argument list`)}}_call(...e){const t=this._gl,i=this._argnames;if(e.length!=i.length)throw new s.IllegalArgumentError(`Can't run shader: incorrect number of arguments (expected ${i.length}, got ${e.length})`);const r=n.Utils.flatten(e);for(let e=r.length-1;e>=0;e--)if(r[e]===this._texture[this._textureIndex])throw new s.NotSupportedError("Can't run shader: don't use its output texture as an input to itself. Consider using pingpong rendering!");if(t.isContextLost())return this._texture[this._textureIndex];t.useProgram(this._program),t.bindVertexArray(this._geometry.vao);const o=this._texture[this._textureIndex],a=this._renderToTexture?o.glFbo:null,c=this._width,p=this._height;this._uniform.get("texSize").setValue(t,[c,p]);for(let n=0,r=0;n<e.length;n++){const o=i[n];if(this._argIsArray[n]){const i=e[n];if(!Array.isArray(i))throw new s.IllegalArgumentError(`Can't run shader: expected an array for "${o}"`);if(this._uniform.has(`${o}[${i.length}]`))throw new s.IllegalArgumentError(`Can't run shader: too few elements in the "${o}" array`);for(let e,n=0;void 0!==(e=this._uniform.get(`${o}[${n}]`));n++)r=e.setValue(t,i[n],r)}else r=this._uniform.get(o).setValue(t,e[n],r)}return null!==this._ubo&&this._ubo.update(),t.bindFramebuffer(t.FRAMEBUFFER,a),t.viewport(0,0,c,p),t.drawArrays(t.TRIANGLES,0,6),t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindVertexArray(null),null!=o&&o.discardMipmaps(),this._pingpong(),o}outputs(e,t,...i){return this._setOutputTexture(...i),this._setOutputSize(e,t),this}_setOutputSize(e,t){n.Utils.assert(e>0&&t>0),this._width=0|e,this._height=0|t;for(let e=0;e<this._texture.length;e++)null!=this._texture[e]&&this._texture[e].resize(this._width,this._height);return this}_setOutputTexture(...e){n.Utils.assert(e.length===this._texture.length,`Incorrect number of textures (expected ${this._texture.length})`);for(let t=0;t<this._texture.length;t++)this._texture[t]=e[t];return this._textureIndex=0,this}clear(){const e=this._texture[this._textureIndex];for(let e=0;e<this._texture.length;e++)this._texture[e].clear();return this._pingpong(),e}setUBO(e,t){return null===this._ubo&&(this._ubo=new p(this._gl,this._program)),this._ubo.set(e,t),this}release(){const e=this._gl;return null!=this._ubo&&(this._ubo=this._ubo.release()),this._texture.fill(null),this._geometry=this._geometry.release(),e.deleteProgram(this._program),this._program=null,null}definedConstant(e){return this._shaderdecl.definedConstant(e)}_pingpong(){this._texture.length>1&&(this._textureIndex=1-this._textureIndex)}static _compile(e,t,i){const n=e.createProgram(),r=e.createShader(e.VERTEX_SHADER),o=e.createShader(e.FRAGMENT_SHADER);if(e.shaderSource(r,t),e.compileShader(r),e.attachShader(n,r),e.shaderSource(o,i),e.compileShader(o),e.attachShader(n,o),e.linkProgram(n),e.validateProgram(n),e.getProgramParameter(n,e.LINK_STATUS))return n;const a=[e.getShaderInfoLog(o),e.getShaderInfoLog(r),e.getProgramInfoLog(n)];e.deleteProgram(n),e.deleteShader(o),e.deleteShader(r);const c=e=>{return new Array((t=e,Math.max(0,2-Math.floor(Math.log10(t))))).fill(" ").join("")+e+". ";var t},p=(a[0]?i:t).split("\n").map(((e,t)=>c(1+t)+e)).join("\n");throw new s.GLError("\n\n---------- ERROR ----------\n\n"+a.filter((e=>e)).join("\n")+"\n\n---------- SOURCE CODE ----------\n\n"+p+"\n")}}function a(e,t){return this.vao=e.createVertexArray(),this.vbo=Object.freeze({position:e.createBuffer(),texCoord:e.createBuffer()}),this._gl=e,e.bindVertexArray(this.vao),e.bindBuffer(e.ARRAY_BUFFER,this.vbo.position),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),e.STATIC_DRAW),e.enableVertexAttribArray(t.position),e.vertexAttribPointer(t.position,2,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,this.vbo.texCoord),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),e.STATIC_DRAW),e.enableVertexAttribArray(t.texCoord),e.vertexAttribPointer(t.texCoord,2,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,null),e.bindVertexArray(null),Object.freeze(this)}function c(e,t){if(this.type=String(e),!Object.prototype.hasOwnProperty.call(r,this.type))throw new s.NotSupportedError(`Unsupported uniform type: ${this.type}`);this.location=t,this.setter=r[this.type];const i=0|Number(this.setter.match(/^uniform(Matrix)?(\d)/)[2]);this.dim=this.type.startsWith("mat")?2:this.type.indexOf("vec")>=0?1:0,this.length=2==this.dim?i*i:i,this._value=null}function p(e,t){this._gl=e,this._program=t,this._nextIndex=0,this._ubo=Object.create(null)}a.prototype.release=function(){const e=this._gl;return e.deleteVertexArray(this.vao),e.deleteBuffer(this.vbo.position),e.deleteBuffer(this.vbo.texCoord),null},c.prototype.setValue=function(e,t,i=-1){const n=e[this.setter];if("object"==typeof t&&this.type.endsWith("sampler2D")){if(i>=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS)throw new s.NotSupportedError(`Can't activate texture unit ${i}: max is ${e.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);if(Array.isArray(t))throw new s.NotSupportedError("Can't pass arrays of textures to shaders");if(null==t)throw new s.IllegalArgumentError(`Can't run shader: cannot use ${t} as an input texture`);if(i<0)throw new s.IllegalArgumentError("Missing texNo");const n=t;e.activeTexture(e.TEXTURE0+i),e.bindTexture(e.TEXTURE_2D,n.glTexture),e.uniform1i(this.location,i),i++}else if(t===this._value);else if("number"==typeof t||"boolean"==typeof t)n.call(e,this.location,t);else{if(!Array.isArray(t))throw new s.IllegalArgumentError(`Can't run shader: unrecognized argument "${t}"`);if(t.length!==this.length)throw new s.IllegalArgumentError(`Can't run shader: incorrect number of values for ${this.type}: "${t}"`);2==this.dim?n.call(e,this.location,!1,t):n.call(e,this.location,...t)}return this._value=t,i},p.prototype.set=function(e,t){const i=this._gl;void 0===this._ubo[e]&&(this._ubo[e]={buffer:i.createBuffer(),blockBindingIndex:this._nextIndex++,blockIndex:-1,data:null});const n=this._ubo[e];if(n.blockIndex<0){const t=i.getUniformBlockIndex(this._program,e);i.uniformBlockBinding(this._program,t,n.blockBindingIndex),n.blockIndex=t}n.data=t},p.prototype.update=function(){const e=this._gl;for(const t in this._ubo){const i=this._ubo[t];e.bindBuffer(e.UNIFORM_BUFFER,i.buffer),e.bufferData(e.UNIFORM_BUFFER,i.data,e.DYNAMIC_DRAW),e.bindBufferBase(e.UNIFORM_BUFFER,i.blockBindingIndex,i.buffer),e.bindBuffer(e.UNIFORM_BUFFER,null)}},p.prototype.release=function(){const e=this._gl;for(const t in this._ubo){const i=this._ubo[t];e.deleteBuffer(i.buffer),i.data=null}return null}},"./src/gpu/speedy-texture-pool.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyTexturePool:()=>c});var n=i("./src/utils/utils.js"),s=(i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js")),r=i("./src/utils/errors.js");const o=Symbol("Bucket");class a{constructor(e,t,i){this.texture=e,this.index=t,this.next=i,this.free=!0}}class c{constructor(e,t=1024){n.Utils.assert(t>0),this._bucket=Array.from({length:t},((e,t)=>new a(null,t,t-1))),this._head=t-1,this._gpu=e}allocate(){if(this._head<0)throw new r.OutOfMemoryError(`Exhausted pool (capacity: ${this._bucket.length})`);const e=this._bucket[this._head];return e.free=!1,this._head=e.next,null==e.texture&&(e.texture=c._createManagedTexture(this._gpu.gl,e)),e.texture}free(e){const t=e[o];return n.Utils.assert(void 0!==t&&!t.free,"Unmanaged texture or double free"),t.next=this._head,t.free=!0,this._head=t.index,null}release(){for(let e=0;e<this._bucket.length;e++)null!=this._bucket[e].texture&&(this._bucket[e].texture=this._bucket[e].texture.release());return null}static _createManagedTexture(e,t){const i=new s.SpeedyDrawableTexture(e,1,1);return Object.defineProperty(i,o,{configurable:!1,enumerable:!1,writable:!1,value:t})}}},"./src/gpu/speedy-texture-reader.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyTextureReader:()=>p});var n=i("./src/utils/utils.js"),s=i("./src/core/settings.js"),r=(i("./src/gpu/speedy-gpu.js"),i("./src/core/speedy-promise.js")),o=(i("./src/gpu/speedy-texture.js"),i("./src/utils/asap.js")),a=i("./src/utils/errors.js");const c=navigator.userAgent.includes("Firefox")?(e,...t)=>setTimeout(e,10,...t):(e,...t)=>requestAnimationFrame((()=>e.apply(void 0,t)));class p{constructor(e=2){n.Utils.assert(e>0),this._initialized=!1,this._pixelBuffer=new Array(e).fill(null).map((()=>new Uint8Array(0))),this._pbo=new Array(e).fill(null),this._consumerIndex=0,this._producerIndex=e-1,this._promise=Array.from({length:e},(()=>r.SpeedyPromise.resolve())),this._busy=new Array(e).fill(!1),this._ready=new Array(e).fill(!0)}init(e){this._allocatePBOs(e),e.subscribe(this._allocatePBOs,this,e),this._initialized=!0}release(e){return e.unsubscribe(this._allocatePBOs,this),this._deallocatePBOs(e),this._initialized=!1,null}readPixelsSync(e,t=0,i=0,s=e.width,r=e.height){n.Utils.assert(this._initialized);const o=e.gl,a=e.glFbo;s=Math.max(0,Math.min(s,e.width)),r=Math.max(0,Math.min(r,e.height)),t=Math.max(0,Math.min(t,e.width-s)),i=Math.max(0,Math.min(i,e.height-r));const c=s*r*4;return this._reallocate(c),o.isContextLost()||(o.bindFramebuffer(o.FRAMEBUFFER,a),o.readPixels(t,i,s,r,o.RGBA,o.UNSIGNED_BYTE,this._pixelBuffer[0]),o.bindFramebuffer(o.FRAMEBUFFER,null)),this._pixelBuffer[0].subarray(0,c)}readPixelsAsync(e,t=0,i=0,s=e.width,o=e.height,a=!1){n.Utils.assert(this._initialized);const c=e.gl,l=e.glFbo;s=Math.max(0,Math.min(s,e.width)),o=Math.max(0,Math.min(o,e.height)),t=Math.max(0,Math.min(t,e.width-s)),i=Math.max(0,Math.min(i,e.height-o));const A=s*o*4;if(this._reallocate(A),c.isContextLost())return r.SpeedyPromise.resolve(this._pixelBuffer[0].subarray(0,A));if(!a){const e=this._pixelBuffer[0].subarray(0,A);return p._readPixelsViaPBO(c,this._pbo[0],e,l,t,i,s,o).then((()=>e))}const d=this._pixelBuffer.length,u=this._producerIndex;if(!this._busy[u]){const e=this._pbo[u],n=this._pixelBuffer[u].subarray(0,A);this._producerIndex=(u+1)%d,this._ready[u]=!1,this._busy[u]=!0,this._promise[u]=p._readPixelsViaPBO(c,e,n,l,t,i,s,o).then((()=>{this._busy[u]=!1,this._ready[u]=!0}))}const g=this._consumerIndex;return this._consumerIndex=(g+1)%d,this._ready[g]?(this._ready[g]=!1,r.SpeedyPromise.resolve(this._pixelBuffer[g])):this._promise[g].then((()=>(this._ready[g]=!1,this._pixelBuffer[g])))}_reallocate(e){if(!(e<=this._pixelBuffer[0].byteLength))for(let t=0;t<this._pixelBuffer.length;t++){const i=new Uint8Array(e);this._pixelBuffer[t]=i}}_allocatePBOs(e){const t=e.gl;for(let e=0;e<this._pbo.length;e++)this._pbo[e]=t.createBuffer()}_deallocatePBOs(e){const t=e.gl;for(let e=this._pbo.length-1;e>=0;e--)t.deleteBuffer(this._pbo[e]),this._pbo[e]=null}static _readPixelsViaPBO(e,t,i,l,A,d,u,g){const h=u*g*4;n.Utils.assert(i.byteLength>=h,"Invalid buffer size"),e.bindBuffer(e.PIXEL_PACK_BUFFER,t),e.bufferData(e.PIXEL_PACK_BUFFER,h,e.DYNAMIC_READ),e.bindFramebuffer(e.FRAMEBUFFER,l),e.readPixels(A,d,u,g,e.RGBA,e.UNSIGNED_BYTE,0),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindBuffer(e.PIXEL_PACK_BUFFER,null);const I=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),new r.SpeedyPromise(((t,i)=>{"asap"!=s.Settings.gpuPollingMode?c(p._clientWaitAsync,e,I,0,t,i):(0,o.asap)(p._clientWaitAsync,e,I,0,t,i)})).then((()=>{e.bindBuffer(e.PIXEL_PACK_BUFFER,t),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,i),e.bindBuffer(e.PIXEL_PACK_BUFFER,null)})).catch((e=>{throw new a.IllegalOperationError("Can't getBufferSubDataAsync(): error in clientWaitAsync()",e)})).finally((()=>{e.deleteSync(I)}))}static _clientWaitAsync(e,t,i,n,r,c=10,p=1e3){!function c(){const l=e.clientWaitSync(t,i,0);p--<=0?r(new a.TimeoutError("GPU polling timeout",a.GLError.from(e))):l===e.CONDITION_SATISFIED||l===e.ALREADY_SIGNALED?n():"asap"!=s.Settings.gpuPollingMode?requestAnimationFrame(c):(0,o.asap)(c)}()}}},"./src/gpu/speedy-texture-uploader.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyTextureUploader:()=>n}),i("./src/gpu/speedy-gpu.js"),i("./src/gpu/speedy-texture.js"),i("./src/core/speedy-media-source.js");class n{constructor(e){this._gpu=e}upload(e,t){const i=e.data;return i instanceof HTMLVideoElement&&i.readyState<2?t:t.upload(i,e.width,e.height)}release(){return null}}},"./src/gpu/speedy-texture.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyTexture:()=>o,SpeedyDrawableTexture:()=>a}),i("./src/gpu/speedy-gpu.js");var n=i("./src/utils/utils.js"),s=i("./src/utils/errors.js"),r=i("./src/utils/globals.js");class o{constructor(e,t,i,n=e.RGBA,s=e.RGBA8,r=e.UNSIGNED_BYTE,a=e.NEAREST,c=e.MIRRORED_REPEAT){this._gl=e,this._width=Math.max(1,0|t),this._height=Math.max(1,0|i),this._hasMipmaps=!1,this._format=n,this._internalFormat=s,this._dataType=r,this._filter=a,this._wrap=c,this._glTexture=o._createTexture(this._gl,this._width,this._height,this._format,this._internalFormat,this._dataType,this._filter,this._wrap)}release(){const e=this._gl;if(null==this._glTexture)throw new s.IllegalOperationError("The SpeedyTexture has already been released");return this.discardMipmaps(),e.deleteTexture(this._glTexture),this._glTexture=null,this._width=this._height=0,null}upload(e,t=this._width,i=this._height){const s=this._gl;return n.Utils.assert(t>0&&i>0),this.discardMipmaps(),this._width=t,this._height=i,this._internalFormat=s.RGBA8,this._format=s.RGBA,this._dataType=s.UNSIGNED_BYTE,o._upload(s,this._glTexture,this._width,this._height,e,0,this._format,this._internalFormat,this._dataType),this}clear(){const e=this._gl;return e.isContextLost()||(e.bindTexture(e.TEXTURE_2D,this._glTexture),e.texImage2D(e.TEXTURE_2D,0,this._internalFormat,this._width,this._height,0,this._format,this._dataType,null),e.bindTexture(e.TEXTURE_2D,null),this.discardMipmaps()),this}resize(e,t){const i=this._gl;if(this._width===e&&this._height===t)return this;if(t|=0,(e|=0)>r.MAX_TEXTURE_LENGTH||t>r.MAX_TEXTURE_LENGTH)throw new s.NotSupportedError(`Maximum texture size exceeded. Using ${e} x ${t}, expected up to ${r.MAX_TEXTURE_LENGTH} x ${r.MAX_TEXTURE_LENGTH}.`);if(e<1||t<1)throw new s.IllegalArgumentError(`Invalid texture size: ${e} x ${t}`);return i.isContextLost()||(this._width=e,this._height=t,i.bindTexture(i.TEXTURE_2D,this._glTexture),i.texImage2D(i.TEXTURE_2D,0,this._internalFormat,this._width,this._height,0,this._format,this._dataType,null),i.bindTexture(i.TEXTURE_2D,null),this.discardMipmaps()),this}generateMipmaps(e=[]){const t=this._gl;if(this._hasMipmaps)return this;if(t.bindTexture(t.TEXTURE_2D,this._glTexture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST_MIPMAP_LINEAR),t.generateMipmap(t.TEXTURE_2D),t.bindTexture(t.TEXTURE_2D,null),e.length>0){const t=this.width,i=this.height,s=1+Math.floor(Math.log2(Math.max(t,i)));n.Utils.assert(e.length<=s);for(let s=1;s<e.length;s++){const r=Math.max(1,t>>>s),o=Math.max(1,i>>>s);n.Utils.assert(e[s].width===r&&e[s].height===o),e[s].copyTo(this,s)}}return this._hasMipmaps=!0,this}discardMipmaps(){const e=this._gl;this._hasMipmaps&&(e.bindTexture(e.TEXTURE_2D,this._glTexture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,this._filter),e.bindTexture(e.TEXTURE_2D,null),this._hasMipmaps=!1)}hasMipmaps(){return this._hasMipmaps}isReleased(){return null==this._glTexture}get glTexture(){return this._glTexture}get width(){return this._width}get height(){return this._height}get gl(){return this._gl}static _createTexture(e,t,i,s,r,o,a,c){n.Utils.assert(t>0&&i>0);const p=e.createTexture();return e.bindTexture(e.TEXTURE_2D,p),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,a),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,a),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,c),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,c),e.texImage2D(e.TEXTURE_2D,0,r,t,i,0,s,o,null),e.bindTexture(e.TEXTURE_2D,null),p}static _upload(e,t,i,n,s,r,o,a,c){return e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,r,a,i,n,0,o,c,s),e.bindTexture(e.TEXTURE_2D,null),t}}class a extends o{constructor(e,t,i,n,s,r,o,c){super(e,t,i,n,s,r,o,c),this._glFbo=a._createFramebuffer(e,this._glTexture)}release(){const e=this._gl;if(null==this._glFbo)throw new s.IllegalOperationError("The SpeedyDrawableTexture has already been released");return e.deleteFramebuffer(this._glFbo),this._glFbo=null,super.release()}get glFbo(){return this._glFbo}copyTo(e,t=0){const i=this._gl;if(i.isContextLost())return;const s=1<<(t|=0),r=Math.max(1,Math.floor(e.width/s)),o=Math.max(1,Math.floor(e.height/s));n.Utils.assert(this._width===r&&this._height===o),a._copyToTexture(i,this._glFbo,e.glTexture,0,0,this._width,this._height,t)}clear(){return this.clearToColor(0,0,0,0)}clearToColor(e,t,i,n){const s=this._gl;return s.isContextLost()||(e=Math.max(0,Math.min(+e,1)),t=Math.max(0,Math.min(+t,1)),i=Math.max(0,Math.min(+i,1)),n=Math.max(0,Math.min(+n,1)),this.discardMipmaps(),s.bindFramebuffer(s.FRAMEBUFFER,this._glFbo),s.viewport(0,0,this._width,this._height),s.clearColor(e,t,i,n),s.clear(s.COLOR_BUFFER_BIT),s.bindFramebuffer(s.FRAMEBUFFER,null)),this}static _createFramebuffer(e,t){const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const n=e.checkFramebufferStatus(e.FRAMEBUFFER);if(n!=e.FRAMEBUFFER_COMPLETE){const t=["FRAMEBUFFER_UNSUPPORTED","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"].filter((t=>e[t]===n))[0]||"unknown error";throw new s.GLError(`Can't create framebuffer: ${t} (${n})`)}return e.bindFramebuffer(e.FRAMEBUFFER,null),i}static _copyToTexture(e,t,i,n,s,r,o,a=0){return e.bindTexture(e.TEXTURE_2D,i),e.bindFramebuffer(e.FRAMEBUFFER,t),e.copyTexSubImage2D(e.TEXTURE_2D,a,0,0,n,s,r,o),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),i}}},"./src/utils/asap.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{asap:()=>o});const n=[],s=[],r="asap"+Math.random().toString(36).substr(1);function o(e,...t){n.unshift(e),s.unshift(t),window.postMessage(r,"*")}window.addEventListener("message",(e=>{if(e.source!==window||e.data!==r)return;if(e.stopPropagation(),0==n.length)return;const t=n.pop(),i=s.pop();t.apply(void 0,i)}),!0)},"./src/utils/errors.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{SpeedyError:()=>n,NotSupportedError:()=>s,NotImplementedError:()=>r,GLError:()=>o,AbstractMethodError:()=>a,IllegalArgumentError:()=>c,IllegalOperationError:()=>p,OutOfMemoryError:()=>l,FileNotFoundError:()=>A,TimeoutError:()=>d,ParseError:()=>u,AssertionError:()=>g,AccessDeniedError:()=>h,WebAssemblyError:()=>I});class n extends Error{constructor(e,t=null){super([e,t?t.toString():"[speedy-vision.js]"].join("\n-> ")),this._cause=t}get name(){return this.constructor.name}set name(e){}get cause(){return this._cause}}class s extends n{constructor(e="",t=null){super(`Unsupported operation. ${e}`,t)}}class r extends n{constructor(e="",t=null){super(`Method not implemented. ${e}`,t)}}class o extends n{constructor(e="",t=null){super(`WebGL error. ${e}`,t)}static from(e){const t=e.getError(),i=["NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL"].find((i=>e[i]==t))||"Unknown";return new o(i)}}class a extends n{constructor(e="",t=null){super(`Can't call abstract method. ${e}`,t)}}class c extends n{constructor(e="",t=null){super(`Illegal argument. ${e}`,t)}}class p extends n{constructor(e="",t=null){super(`Illegal operation. ${e}`,t)}}class l extends n{constructor(e="",t=null){super(`Out of memory. ${e}`,t)}}class A extends n{constructor(e="",t=null){super(`File not found. ${e}`,t)}}class d extends n{constructor(e="",t=null){super(`Timeout error. ${e}`,t)}}class u extends n{constructor(e="",t=null){super(`Parse error. ${e}`,t)}}class g extends n{constructor(e="",t=null){super(`Assertion failed. ${e}`,t)}}class h extends n{constructor(e="",t=null){super(`Access denied. ${e}`,t)}}class I extends n{constructor(e="",t=null){super(`WebAssembly error. ${e}`,t)}}},"./src/utils/fps-counter.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{FPSCounter:()=>r});var n=i("./src/utils/errors.js");let s=null;class r{constructor(){if(this._fps=60,this._frames=0,this._updateInterval=500,this._lastUpdate=performance.now(),this._boundUpdate=this._update.bind(this),null!==s)throw new n.IllegalOperationError("Can't have multiple instances of FPSCounter");this._boundUpdate()}static get instance(){return null===s&&(s=new r),s}get fps(){return this._fps}_update(){const e=performance.now(),t=e-this._lastUpdate;t>=this._updateInterval&&(this._fps=Math.round(this._frames/(.001*t)),this._frames=0,this._lastUpdate=e),this._frames++,requestAnimationFrame(this._boundUpdate)}}},"./src/utils/globals.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{PYRAMID_MAX_LEVELS:()=>n,LOG2_PYRAMID_MAX_SCALE:()=>s,PYRAMID_MAX_SCALE:()=>r,FIX_BITS:()=>o,FIX_RESOLUTION:()=>a,MAX_TEXTURE_LENGTH:()=>c,MIN_KEYPOINT_SIZE:()=>p,MIN_ENCODER_LENGTH:()=>l,MAX_ENCODER_CAPACITY:()=>A,DEFAULT_ENCODER_CAPACITY:()=>d,LOG2_MAX_DESCRIPTOR_SIZE:()=>u,MAX_DESCRIPTOR_SIZE:()=>g,MATCH_INDEX_BITS:()=>h,MATCH_INDEX_MASK:()=>I,MATCH_MAX_INDEX:()=>m,MATCH_MAX_DISTANCE:()=>f,LITTLE_ENDIAN:()=>y});const n=8,s=0,r=1<<s,o=3,a=1<<o,c=(1<<16-o)-1,p=8,l=2,A=8192,d=2048,u=6,g=1<<u,h=32-(u+3),I=(1<<h)-1,m=(1<<h)-1,f=(1<<32-h)-1,y=51966===new Uint16Array(new Uint8Array([254,202]).buffer)[0]},"./src/utils/observable.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{Observable:()=>n});class n{constructor(){this._subscribers=[],this._thisptr=[],this._args=[]}subscribe(e,t,...i){this._subscribers.push(e),this._thisptr.push(t),this._args.push(i)}unsubscribe(e,t){for(let i=this._subscribers.length-1;i>=0;i--)if(this._subscribers[i]===e&&this._thisptr[i]===t){this._subscribers.splice(i,1),this._thisptr.splice(i,1),this._args.splice(i,1);break}}_notify(){for(let e=0;e<this._subscribers.length;e++)this._subscribers[e].call(this._thisptr[e],...this._args[e])}}},"./src/utils/types.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{MediaType:()=>n,ImageFormat:()=>s,PixelComponent:()=>r,ColorComponentId:()=>o});const n=Object.freeze({Image:Symbol("Image"),Video:Symbol("Video"),Canvas:Symbol("Canvas"),Bitmap:Symbol("Bitmap")}),s=Object.freeze({RGBA:Symbol("RGBA"),GREY:Symbol("GREY")}),r=Object.freeze({RED:1,GREEN:2,BLUE:4,ALPHA:8,ALL:15}),o=Object.freeze({[r.RED]:0,[r.GREEN]:1,[r.BLUE]:2,[r.ALPHA]:3})},"./src/utils/utils.js":(e,t,i)=>{"use strict";i.r(t),i.d(t,{Utils:()=>r});var n=i("./src/utils/errors.js"),s=i("./src/core/speedy-promise.js");class r{static warning(e,...t){console.warn("[speedy-vision]",e,...t)}static log(e,...t){console.log("[speedy-vision]",e,...t)}static assert(e,t=""){if(!e)throw new n.AssertionError(t)}static functionArguments(e){const t=e.toString(),i=t.startsWith("function")?"function\\s.*\\(([^)]*)\\)":t.startsWith("(")?"\\(([^)]*)\\).*=>":"([^=]+).*=>",s=new RegExp(i).exec(t);if(null!==s)return s[1].replace(/\/\*.*?\*\//g,"").split(",").map((e=>e.replace(/=.*$/,"").trim())).filter((e=>e));throw new n.ParseError(`Can't detect function arguments of ${t}`)}static getAllPropertyDescriptors(e){if(e){const t=Object.getPrototypeOf(e);return{...r.getAllPropertyDescriptors(t),...Object.getOwnPropertyDescriptors(e)}}return Object.create(null)}static createCanvas(e,t){const i=document.createElement("canvas");return i.width=e,i.height=t,i}static gaussianNoise(e=0,t=1){const i=2*Math.PI;let n,s=Math.random();do{n=Math.random()}while(n<=Number.EPSILON);return Math.sqrt(-2*Math.log(n))*Math.sin(i*s)*t+e}static gaussianKernel(e,t=0,i=!0){if(0==t&&(t=0|Math.ceil(5*e),t+=1-t%2),(t|=0)<1||t%2==0)throw new n.IllegalArgumentError(`Invalid kernel size given to gaussianKernel: ${t} x 1`);if(e<=0)throw new n.IllegalArgumentError(`Invalid sigma given to gaussianKernel: ${e}`);const s=new Array(t),r=t>>1,o=1.4142135623730951*+e,a=.3275911,c=.254829592,p=-.284496736,l=1.421413741,A=-1.453152027,d=1.061405429;let u=0;for(let e=0;e<t;e++){let t=(e-r+.5)/o,i=(e-r-.5)/o,n=1,g=1;t<0&&(n=-1,t=-t),i<0&&(g=-1,i=-i);const h=1/(1+a*t),I=1/(1+a*i),m=((((d*I+A)*I+l)*I+p)*I+c)*I,f=(n*(1-((((d*h+A)*h+l)*h+p)*h+c)*h*Math.exp(-t*t))-g*(1-m*Math.exp(-i*i)))/(2*o);s[e]=f,u+=f}if(i)for(let e=0;e<t;e++)s[e]/=u;return s}static kernel2d(e,t=e){const i=e.length;r.assert(e.length==e.length),r.assert(i>=1&&i%2==1);let n=new Array(i*i),s=0;for(let r=0;r<i;r++)for(let o=0;o<i;o++)n[s++]=e[o]*t[r];return n}static cartesian(e,t){return[].concat(...e.map((e=>t.map((t=>[e,t])))))}static symmetricRange(e){if((e|=0)<0)throw new n.IllegalArgumentError("Expected a non-negative integer as input");return[...Array(2*e+1).keys()].map((t=>t-e))}static range(e){if((e|=0)<=0)throw new n.IllegalArgumentError("Expected a positive integer as input");return[...Array(e).keys()]}static shuffle(e){const t=e.length,i=t-1;for(let n=0;n<i;n++){const i=n+(Math.random()*(t-n)|0);if(n!==i){const t=e[n];e[n]=e[i],e[i]=t}}return e}static flatten(e){const t=[];for(let i=0,n=e.length;i<n;i++){const n=e[i];if(Array.isArray(n))for(let e=0,i=n.length;e<i;e++)t.push(n[e]);else t.push(n)}return t}static decodeFloat16(e){const t=(32767&e)>>10,i=1023&e,n=1-2*((65535&e)>>15);return 0==t?0==i?0*n:n*i*5.960464477539063e-8:31==t?0==i?n*Number.POSITIVE_INFINITY:Number.NaN:n*(t>=15?1<<t-15:1/(1<<15-t))*(1+.0009765625*i)}static requestCameraStream(e={audio:!1,video:!0}){if(r.log("Accessing the webcam..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new n.NotSupportedError("Unsupported browser: no mediaDevices.getUserMedia()");return new s.SpeedyPromise(((t,i)=>{navigator.mediaDevices.getUserMedia(e).then((e=>{const i=document.createElement("video");i.onloadedmetadata=()=>{i.play(),r.log(`The camera is on! Resolution: ${i.videoWidth} x ${i.videoHeight}`),t(i)},i.srcObject=e})).catch((e=>{i(new n.AccessDeniedError("Please give access to the camera and reload the page",e))}))}))}}},"./src/gpu/shaders/filters/convolution1d.glsl":e=>{e.exports="#if !defined(KERNEL_SIZE) || !defined(AXIS) || (AXIS != 0 && AXIS != 1)\n#error Undefined KERNEL_SIZE / AXIS\n#endif\nuniform sampler2D image;\nuniform float kernel[@KERNEL_SIZE@];\nconst ivec2 axis = ivec2(1-AXIS, AXIS);\n#define S(x,k) result += pixelAtShortOffset(image, ivec2((x),(x)) * axis) * kernel[k]\nvoid main()\n{\nvec4 result = vec4(0.0f);\n#if KERNEL_SIZE == 3\nS(-1, 2);\nS( 0, 1);\nS( 1, 0);\n#elif KERNEL_SIZE == 5\nS(-2, 4);\nS(-1, 3);\nS( 0, 2);\nS( 1, 1);\nS( 2, 0);\n#elif KERNEL_SIZE == 7\nS(-3, 6);\nS(-2, 5);\nS(-1, 4);\nS( 0, 3);\nS( 1, 2);\nS( 2, 1);\nS( 3, 0);\n#elif KERNEL_SIZE == 9\nS(-4, 8);\nS(-3, 7);\nS(-2, 6);\nS(-1, 5);\nS( 0, 4);\nS( 1, 3);\nS( 2, 2);\nS( 3, 1);\nS( 4, 0);\n#elif KERNEL_SIZE == 11\nS(-5, 10);\nS(-4, 9);\nS(-3, 8);\nS(-2, 7);\nS(-1, 6);\nS( 0, 5);\nS( 1, 4);\nS( 2, 3);\nS( 3, 2);\nS( 4, 1);\nS( 5, 0);\n#elif KERNEL_SIZE == 13\nS(-6, 12);\nS(-5, 11);\nS(-4, 10);\nS(-3, 9);\nS(-2, 8);\nS(-1, 7);\nS( 0, 6);\nS( 1, 5);\nS( 2, 4);\nS( 3, 3);\nS( 4, 2);\nS( 5, 1);\nS( 6, 0);\n#elif KERNEL_SIZE == 15\nS(-7, 14);\nS(-6, 13);\nS(-5, 12);\nS(-4, 11);\nS(-3, 10);\nS(-2, 9);\nS(-1, 8);\nS( 0, 7);\nS( 1, 6);\nS( 2, 5);\nS( 3, 4);\nS( 4, 3);\nS( 5, 2);\nS( 6, 1);\nS( 7, 0);\n#else\n#error Invalid parameters\n#endif\ncolor = vec4(result.rgb, 1.0f);\n}"},"./src/gpu/shaders/filters/convolution2d.glsl":e=>{e.exports="#ifndef KERNEL_SIZE_SQUARED\n#define Must define KERNEL_SIZE_SQUARED\n#endif\nuniform sampler2D image;\nuniform float kernel[@KERNEL_SIZE_SQUARED@];\n#define S(x,y,k) result += pixelAtShortOffset(image, ivec2((x),(y))) * kernel[k]\nvoid main()\n{\nvec4 result = vec4(0.0f);\n#if KERNEL_SIZE_SQUARED == 9\nS(-1,-1, 8);\nS(-1, 0, 7);\nS(-1, 1, 6);\nS( 0,-1, 5);\nS( 0, 0, 4);\nS( 0, 1, 3);\nS( 1,-1, 2);\nS( 1, 0, 1);\nS( 1, 1, 0);\n#elif KERNEL_SIZE_SQUARED == 25\nS(-2,-2, 24);\nS(-2,-1, 23);\nS(-2, 0, 22);\nS(-2, 1, 21);\nS(-2, 2, 20);\nS(-1,-2, 19);\nS(-1,-1, 18);\nS(-1, 0, 17);\nS(-1, 1, 16);\nS(-1, 2, 15);\nS( 0,-2, 14);\nS( 0,-1, 13);\nS( 0, 0, 12);\nS( 0, 1, 11);\nS( 0, 2, 10);\nS( 1,-2, 9);\nS( 1,-1, 8);\nS( 1, 0, 7);\nS( 1, 1, 6);\nS( 1, 2, 5);\nS( 2,-2, 4);\nS( 2,-1, 3);\nS( 2, 0, 2);\nS( 2, 1, 1);\nS( 2, 2, 0);\n#elif KERNEL_SIZE_SQUARED == 49\nS(-3,-3, 48);\nS(-3,-2, 47);\nS(-3,-1, 46);\nS(-3, 0, 45);\nS(-3, 1, 44);\nS(-3, 2, 43);\nS(-3, 3, 42);\nS(-2,-3, 41);\nS(-2,-2, 40);\nS(-2,-1, 39);\nS(-2, 0, 38);\nS(-2, 1, 37);\nS(-2, 2, 36);\nS(-2, 3, 35);\nS(-1,-3, 34);\nS(-1,-2, 33);\nS(-1,-1, 32);\nS(-1, 0, 31);\nS(-1, 1, 30);\nS(-1, 2, 29);\nS(-1, 3, 28);\nS( 0,-3, 27);\nS( 0,-2, 26);\nS( 0,-1, 25);\nS( 0, 0, 24);\nS( 0, 1, 23);\nS( 0, 2, 22);\nS( 0, 3, 21);\nS( 1,-3, 20);\nS( 1,-2, 19);\nS( 1,-1, 18);\nS( 1, 0, 17);\nS( 1, 1, 16);\nS( 1, 2, 15);\nS( 1, 3, 14);\nS( 2,-3, 13);\nS( 2,-2, 12);\nS( 2,-1, 11);\nS( 2, 0, 10);\nS( 2, 1, 9);\nS( 2, 2, 8);\nS( 2, 3, 7);\nS( 3,-3, 6);\nS( 3,-2, 5);\nS( 3,-1, 4);\nS( 3, 0, 3);\nS( 3, 1, 2);\nS( 3, 2, 1);\nS( 3, 3, 0);\n#else\n#error Invalid KERNEL_SIZE_SQUARED\n#endif\ncolor = vec4(result.rgb, 1.0f);\n}"},"./src/gpu/shaders/filters/fast-median.glsl":e=>{e.exports="uniform sampler2D image;\n#define X(i,j) t = vec2(min(p[i], p[j]), max(p[i], p[j])); p[i] = t.x; p[j] = t.y;\n#define S(i,x,y) p[i] = pixelAtShortOffset(image, ivec2((x),(y))).g\nvoid main()\n{\nfloat median;\nvec2 t;\n#if !defined(KERNEL_SIZE)\n#error Must define KERNEL_SIZE\n#elif KERNEL_SIZE == 3\nfloat p[9];\nS(0,-1,-1);\nS(1, 0,-1);\nS(2, 1,-1);\nS(3,-1, 0);\nS(4, 0, 0);\nS(5, 1, 0);\nS(6,-1, 1);\nS(7, 0, 1);\nS(8, 1, 1);\nX(1,2);X(4,5);X(7,8);X(0,1);X(3,4);X(6,7);X(1,2);X(4,5);X(7,8);X(0,3);X(5,8);X(4,7);X(3,6);X(1,4);X(2,5);X(4,7);X(4,2);X(6,4);X(4,2);\nmedian = p[4];\n#elif KERNEL_SIZE == 5\nfloat p[25];\nS( 0,-2,-2);\nS( 1,-1,-2);\nS( 2, 0,-2);\nS( 3, 1,-2);\nS( 4, 2,-2);\nS( 5,-2,-1);\nS( 6,-1,-1);\nS( 7, 0,-1);\nS( 8, 1,-1);\nS( 9, 2,-1);\nS(10,-2, 0);\nS(11,-1, 0);\nS(12, 0, 0);\nS(13, 1, 0);\nS(14, 2, 0);\nS(15,-2, 1);\nS(16,-1, 1);\nS(17, 0, 1);\nS(18, 1, 1);\nS(19, 2, 1);\nS(20,-2, 2);\nS(21,-1, 2);\nS(22, 0, 2);\nS(23, 1, 2);\nS(24, 2, 2);\nX(0,1);X(3,4);X(2,4);X(2,3);X(6,7);X(5,7);X(5,6);X(9,10);X(8,10);X(8,9);X(12,13);X(11,13);X(11,12);X(15,16);X(14,16);X(14,15);X(18,19);X(17,19);X(17,18);X(21,22);X(20,22);X(20,21);X(23,24);X(2,5);X(3,6);X(0,6);X(0,3);X(4,7);X(1,7);X(1,4);X(11,14);X(8,14);X(8,11);X(12,15);X(9,15);X(9,12);X(13,16);X(10,16);X(10,13);X(20,23);X(17,23);X(17,20);X(21,24);X(18,24);X(18,21);X(19,22);X(8,17);X(9,18);X(0,18);X(0,9);X(10,19);X(1,19);X(1,10);X(11,20);X(2,20);X(2,11);X(12,21);X(3,21);X(3,12);X(13,22);X(4,22);X(4,13);X(14,23);X(5,23);X(5,14);X(15,24);X(6,24);X(6,15);X(7,16);X(7,19);X(13,21);X(15,23);X(7,13);X(7,15);X(1,9);X(3,11);X(5,17);X(11,17);X(9,17);X(4,10);X(6,12);X(7,14);X(4,6);X(4,7);X(12,14);X(10,14);X(6,7);X(10,12);X(6,10);X(6,17);X(12,17);X(7,17);X(7,10);X(12,18);X(7,12);X(10,18);X(12,20);X(10,20);X(10,12);\nmedian = p[12];\n#elif KERNEL_SIZE == 7\nfloat p[49];\nS( 0,-3,-3);\nS( 1,-2,-3);\nS( 2,-1,-3);\nS( 3, 0,-3);\nS( 4, 1,-3);\nS( 5, 2,-3);\nS( 6, 3,-3);\nS( 7,-3,-2);\nS( 8,-2,-2);\nS( 9,-1,-2);\nS(10, 0,-2);\nS(11, 1,-2);\nS(12, 2,-2);\nS(13, 3,-2);\nS(14,-3,-1);\nS(15,-2,-1);\nS(16,-1,-1);\nS(17, 0,-1);\nS(18, 1,-1);\nS(19, 2,-1);\nS(20, 3,-1);\nS(21,-3, 0);\nS(22,-2, 0);\nS(23,-1, 0);\nS(24, 0, 0);\nS(25, 1, 0);\nS(26, 2, 0);\nS(27, 3, 0);\nS(28,-3, 1);\nS(29,-2, 1);\nS(30,-1, 1);\nS(31, 0, 1);\nS(32, 1, 1);\nS(33, 2, 1);\nS(34, 3, 1);\nS(35,-3, 2);\nS(36,-2, 2);\nS(37,-1, 2);\nS(38, 0, 2);\nS(39, 1, 2);\nS(40, 2, 2);\nS(41, 3, 2);\nS(42,-3, 3);\nS(43,-2, 3);\nS(44,-1, 3);\nS(45, 0, 3);\nS(46, 1, 3);\nS(47, 2, 3);\nS(48, 3, 3);\nX(0,1);X(2,3);X(0,2);X(1,3);X(1,2);X(4,5);X(6,7);X(4,6);X(5,7);X(5,6);X(0,4);X(2,6);X(2,4);X(1,5);X(3,7);X(3,5);X(1,2);X(3,4);X(5,6);X(8,9);X(10,11);X(8,10);X(9,11);X(9,10);X(12,13);X(14,15);X(12,14);X(13,15);X(13,14);X(8,12);X(10,14);X(10,12);X(9,13);X(11,15);X(11,13);X(9,10);X(11,12);X(13,14);X(0,8);X(4,12);X(4,8);X(2,10);X(6,14);X(6,10);X(2,4);X(6,8);X(10,12);X(1,9);X(5,13);X(5,9);X(3,11);X(7,15);X(7,11);X(3,5);X(7,9);X(11,13);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(16,17);X(18,19);X(16,18);X(17,19);X(17,18);X(20,21);X(22,23);X(20,22);X(21,23);X(21,22);X(16,20);X(18,22);X(18,20);X(17,21);X(19,23);X(19,21);X(17,18);X(19,20);X(21,22);X(24,25);X(26,27);X(24,26);X(25,27);X(25,26);X(28,29);X(30,31);X(28,30);X(29,31);X(29,30);X(24,28);X(26,30);X(26,28);X(25,29);X(27,31);X(27,29);X(25,26);X(27,28);X(29,30);X(16,24);X(20,28);X(20,24);X(18,26);X(22,30);X(22,26);X(18,20);X(22,24);X(26,28);X(17,25);X(21,29);X(21,25);X(19,27);X(23,31);X(23,27);X(19,21);X(23,25);X(27,29);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(0,16);X(8,24);X(8,16);X(4,20);X(12,28);X(12,20);X(4,8);X(12,16);X(20,24);X(2,18);X(10,26);X(10,18);X(6,22);X(14,30);X(14,22);X(6,10);X(14,18);X(22,26);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(1,17);X(9,25);X(9,17);X(5,21);X(13,29);X(13,21);X(5,9);X(13,17);X(21,25);X(3,19);X(11,27);X(11,19);X(7,23);X(15,31);X(15,23);X(7,11);X(15,19);X(23,27);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(32,33);X(34,35);X(32,34);X(33,35);X(33,34);X(36,37);X(38,39);X(36,38);X(37,39);X(37,38);X(32,36);X(34,38);X(34,36);X(33,37);X(35,39);X(35,37);X(33,34);X(35,36);X(37,38);X(40,41);X(42,43);X(40,42);X(41,43);X(41,42);X(44,45);X(46,47);X(44,46);X(45,47);X(45,46);X(40,44);X(42,46);X(42,44);X(41,45);X(43,47);X(43,45);X(41,42);X(43,44);X(45,46);X(32,40);X(36,44);X(36,40);X(34,42);X(38,46);X(38,42);X(34,36);X(38,40);X(42,44);X(33,41);X(37,45);X(37,41);X(35,43);X(39,47);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(32,48);X(40,48);X(36,40);X(44,48);X(38,42);X(34,36);X(38,40);X(42,44);X(46,48);X(37,41);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(47,48);X(0,32);X(16,48);X(16,32);X(8,40);X(24,40);X(8,16);X(24,32);X(40,48);X(4,36);X(20,36);X(12,44);X(28,44);X(12,20);X(28,36);X(4,8);X(12,16);X(20,24);X(28,32);X(36,40);X(44,48);X(2,34);X(18,34);X(10,42);X(26,42);X(10,18);X(26,34);X(6,38);X(22,38);X(14,46);X(30,46);X(14,22);X(30,38);X(6,10);X(14,18);X(22,26);X(30,34);X(38,42);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(30,32);X(34,36);X(38,40);X(42,44);X(46,48);X(1,33);X(17,33);X(9,41);X(25,41);X(9,17);X(25,33);X(5,37);X(21,37);X(13,45);X(29,45);X(13,21);X(29,37);X(5,9);X(13,17);X(21,25);X(29,33);X(37,41);X(3,35);X(19,35);X(11,43);X(27,43);X(11,19);X(27,35);X(7,39);X(23,39);X(15,47);X(31,47);X(15,23);X(31,39);X(7,11);X(15,19);X(23,27);X(31,35);X(39,43);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(31,33);X(35,37);X(39,41);X(43,45);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);\nmedian = p[24];\n#else\n#error Unsupported kernel size\n#endif\ncolor = vec4(median, median, median, 1.0f);\n}"},"./src/gpu/shaders/filters/nightvision.glsl":e=>{e.exports="uniform sampler2D image;\nuniform sampler2D illuminationMap;\nuniform float gain;\nuniform float offset;\nuniform float decay;\n#ifndef GREYSCALE\n#error Must define GREYSCALE\n#endif\n#if GREYSCALE == 0\nconst mat3 rgb2yuv = mat3(\n0.299f, -0.14713f, 0.615f,\n0.587f, -0.28886f, -0.51499f,\n0.114f, 0.436f, -0.10001f\n);\nconst mat3 yuv2rgb = mat3(\n1.0f, 1.0f, 1.0f,\n0.0f, -0.39465f, 2.03211f,\n1.13983f, -0.58060f, 0.0f\n);\n#endif\nconst float eps = 0.0001f;\nconst float sqrt2 = 1.4142135623730951f;\nconst float magic = 20.0f;\nconst vec2 center = vec2(0.5f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nvec4 imapPixel = threadPixel(illuminationMap);\nfloat lambda = -sqrt2 * log(max(1.0f - decay, eps));\nfloat dist = length(texCoord - center);\nfloat vgain = gain * exp(-lambda * dist);\nfloat normalizedGain = 2.0f * vgain;\nfloat normalizedOffset = 2.0f * offset - 1.0f;\n#if GREYSCALE != 0\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (pixel.g - imapPixel.g)));\nluma = clamp(luma + normalizedOffset, 0.0f, 1.0f);\ncolor = vec4(luma, luma, luma, 1.0f);\n#else\nvec3 yuvPixel = rgb2yuv * pixel.rgb;\nvec3 yuvImapPixel = rgb2yuv * imapPixel.rgb;\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (yuvPixel.r - yuvImapPixel.r)));\nluma += normalizedOffset;\nvec3 rgbCorrectedPixel = yuv2rgb * vec3(luma, yuvPixel.gb);\nrgbCorrectedPixel = clamp(rgbCorrectedPixel, 0.0f, 1.0f);\ncolor = vec4(rgbCorrectedPixel, 1.0f);\n#endif\n}"},"./src/gpu/shaders/filters/normalize-image.glsl":e=>{e.exports="#ifndef GREYSCALE\n#error Must define GREYSCALE\n#endif\n#if GREYSCALE != 0\nuniform sampler2D minmax2d;\n#else\nuniform sampler2D minmax2dRGB[3];\n#endif\nuniform float minValue;\nuniform float maxValue;\nconst float eps = 1.0f / 255.0f;\nvoid main()\n{\nvec2 minmax = clamp(vec2(minValue, maxValue), 0.0f, 255.0f) / 255.0f;\nvec4 newMin = vec4(minmax.x);\nvec4 newRange = vec4(minmax.y - minmax.x);\nvec4 alpha = vec4(1.0f, newMin.x, newRange.x, 1.0f);\n#if GREYSCALE != 0\nvec4 pixel = threadPixel(minmax2d);\nmat4 channel = mat4(pixel, pixel, pixel, alpha);\n#else\nmat4 channel = mat4(\nthreadPixel(minmax2dRGB[0]),\nthreadPixel(minmax2dRGB[1]),\nthreadPixel(minmax2dRGB[2]),\nalpha\n);\n#endif\nvec4 oldMin = vec4(channel[0].g, channel[1].g, channel[2].g, channel[3].g);\nvec4 oldRange = max(vec4(channel[0].b, channel[1].b, channel[2].b, channel[3].b), eps);\nvec4 oldIntensity = vec4(channel[0].a, channel[1].a, channel[2].a, channel[3].a);\nvec4 newIntensity = (oldIntensity - oldMin) * newRange / oldRange + newMin;\ncolor = newIntensity;\n}"},"./src/gpu/shaders/filters/rgb2grey.glsl":e=>{e.exports="const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\nuniform sampler2D image;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat g = dot(pixel, grey);\ncolor = vec4(g, g, g, 1.0f);\n}"},"./src/gpu/shaders/include/colors.glsl":e=>{e.exports="#ifndef _COLORS_GLSL\n#define _COLORS_GLSL\n#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@\n#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@\n#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@\n#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@\n#endif"},"./src/gpu/shaders/include/filters.glsl":e=>{e.exports="#ifndef _FILTERS_GLSL\n#define _FILTERS_GLSL\nfloat laplacian(sampler2D pyramid, vec2 position, float lod)\n{\nfloat pot = exp2(lod);\nivec2 pyrBaseSize = textureSize(pyramid, 0);\nconst vec3 ones = vec3(1.0f);\nconst mat3 kernel = mat3(\n0,-1, 0,\n-1, 4,-1,\n0,-1, 0\n);\n#define LPC(x,y) pyrSubpixelAtExOffset(pyramid, position, lod, pot, ivec2((x),(y)), pyrBaseSize).g\nmat3 neighborhood = mat3(\n0.0f, LPC(0,-1), 0.0f,\nLPC(-1,0), LPC(0,0), LPC(1,0),\n0.0f, LPC(0,1), 0.0f\n);\nmat3 m = matrixCompMult(neighborhood, kernel);\nreturn dot(ones, vec3(\ndot(m[0], ones),\ndot(m[1], ones),\ndot(m[2], ones)\n)) * (1.0f + lod);\n}\n#endif"},"./src/gpu/shaders/include/fixed-point.glsl":e=>{e.exports="#ifndef _FIXEDPOINT_GLSL\n#define _FIXEDPOINT_GLSL\n#define fixed_t int\n#define fixed2_t ivec2\nconst int FIX_BITS = int(@FIX_BITS@);\nconst float FIX_RESOLUTION = float(@FIX_RESOLUTION@);\n#define itofix(x) fixed_t((x) << FIX_BITS)\n#define fixtoi(f) int((x) >> FIX_BITS)\n#define ftofix(x) fixed_t((x) * FIX_RESOLUTION + 0.5f)\n#define fixtof(f) (float(f) / FIX_RESOLUTION)\n#define ivec2tofix(x) fixed2_t((x) << FIX_BITS)\n#define fixtoivec2(f) ivec2((f) >> FIX_BITS)\n#define vec2tofix(v) fixed2_t((v) * FIX_RESOLUTION + vec2(0.5f))\n#define fixtovec2(f) (vec2(f) / FIX_RESOLUTION)\n#endif"},"./src/gpu/shaders/include/float16.glsl":e=>{e.exports="#ifndef _FLOAT16_GLSL\n#define _FLOAT16_GLSL\n#define encodeFloat16(f) (vec2(packf16(f)) / 255.0f)\n#define decodeFloat16(v) unpackf16(uvec2((v) * 255.0f))\n#define encodePairOfFloat16(f) vec4(encodeFloat16((f).x), encodeFloat16((f).y))\n#define decodePairOfFloat16(v) vec2(decodeFloat16((v).rg), decodeFloat16((v).ba))\n#define encodeNullPairOfFloat16() vec4(1.0f)\n#define isNullPairOfFloat16(v) all(equal((v), encodeNullPairOfFloat16()))\n#define encodeDiscardedPairOfFloat16() vec4(0.0f, 1.0f, 0.0f, 1.0f)\n#define isDiscardedPairOfFloat16(v) all(equal((v), encodeDiscardedPairOfFloat16()))\n#define encodeFloat16NaN() vec2(0.5f, 1.0f)\n#define isEncodedFloat16NaN(v) all(equal((v), encodeFloat16NaN()))\nuvec2 packf16( float f)\n{\nuint y = packHalf2x16(vec2(f, 0.0f));\nreturn uvec2(y, y >> 8u) & 0xFFu;\n}\nfloat unpackf16(uvec2 v)\n{\nv &= 0xFFu;\nreturn unpackHalf2x16(v.x | (v.y << 8u)).x;\n}\nbool isEncodedFloat16Zero(vec2 v)\n{\nuvec2 w = uvec2(v * 255.0f);\nreturn 0u == w.x + w.y * (0x80u - w.y);\n}\n#endif"},"./src/gpu/shaders/include/global.glsl":e=>{e.exports="#ifndef _GLOBAL_GLSL\n#define _GLOBAL_GLSL\n#define threadLocation() ivec2(texCoord * texSize)\n#define outputSize() ivec2(texSize)\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\n#define pixelAtShortOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))\n#define pixelAtLongOffset(img, offset) textureLod((img), texCoord + vec2(offset) / texSize, 0.0f)\n#endif"},"./src/gpu/shaders/include/int32.glsl":e=>{e.exports="#ifndef _INT32_GLSL\n#define _INT32_GLSL\nuint decodeUint32(vec4 rgba)\n{\nuvec4 v = uvec4(rgba * 255.0f) & 255u;\nreturn v.x | (v.y << 8u) | (v.z << 16u) | (v.w << 24u);\n}\nvec4 encodeUint32(uint value)\n{\nuvec4 v = uvec4(value, value >> 8u, value >> 16u, value >> 24u) & 255u;\nreturn vec4(v) / 255.0f;\n}\n#endif"},"./src/gpu/shaders/include/keypoint-descriptors.glsl":e=>{e.exports="#ifndef _KEYPOINT_DESCRIPTORS_GLSL\n#define _KEYPOINT_DESCRIPTORS_GLSL\n#if !defined(DESCRIPTOR_SIZE)\n#error Must define DESCRIPTOR_SIZE\n#elif !defined(_KEYPOINTS_GLSL)\n#error Must include keypoints.glsl\n#endif\nuint[DESCRIPTOR_SIZE] readKeypointDescriptor(sampler2D encodedKeypoints, int descriptorSize, int extraSize, int encoderLength, KeypointAddress address)\n{\nint descriptorOffset = sizeofEncodedKeypoint(0, extraSize) / 4;\nKeypointAddress descriptorAddress = KeypointAddress(address.base, descriptorOffset);\nuint[DESCRIPTOR_SIZE] descriptor;\nvec4 pixel; uvec4 bytes;\n@unroll\nfor(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {\npixel = readKeypointData(encodedKeypoints, encoderLength, descriptorAddress);\nbytes = uvec4(pixel * 255.0f);\ndescriptor[i]   = bytes.r;\ndescriptor[i+1] = bytes.g;\ndescriptor[i+2] = bytes.b;\ndescriptor[i+3] = bytes.a;\ndescriptorAddress.offset++;\n}\nreturn descriptor;\n}\nuint[DESCRIPTOR_SIZE] readKeypointDescriptorFromDB(sampler2D descriptorDB, int descriptorDBStride, int index)\n{\nuint[DESCRIPTOR_SIZE] descriptor;\nint rasterIndex = index * (DESCRIPTOR_SIZE / 4) * int(index >= 0);\nvec4 pixel; uvec4 bytes; ivec2 pos;\n@unroll\nfor(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {\npos = ivec2(rasterIndex % descriptorDBStride, rasterIndex / descriptorDBStride);\npixel = (index >= 0) ? texelFetch(descriptorDB, pos, 0) : vec4(0.0f);\nbytes = uvec4(pixel * 255.0f);\ndescriptor[i]   = bytes.r;\ndescriptor[i+1] = bytes.g;\ndescriptor[i+2] = bytes.b;\ndescriptor[i+3] = bytes.a;\nrasterIndex++;\n}\nreturn descriptor;\n}\nint distanceBetweenKeypointDescriptors(uint[DESCRIPTOR_SIZE] a, uint[DESCRIPTOR_SIZE] b)\n{\nconst int[256] POPCNT = int[256](0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8);\nuvec4 xor, u, v;\nint dist = 0;\nivec4 bits;\n@unroll\nfor(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {\nu = uvec4(a[i], a[i+1], a[i+2], a[i+3]);\nv = uvec4(b[i], b[i+1], b[i+2], b[i+3]);\nxor = (u ^ v) & 255u;\nbits = ivec4(POPCNT[xor.x], POPCNT[xor.y], POPCNT[xor.z], POPCNT[xor.w]);\ndist += bits.x + bits.y + bits.z + bits.w;\n}\nreturn dist;\n}\n#endif"},"./src/gpu/shaders/include/keypoint-matches.glsl":e=>{e.exports='#ifndef _KEYPOINT_MATCHES_GLSL\n#define _KEYPOINT_MATCHES_GLSL\n@include "int32.glsl"\nconst int MATCH_INDEX_BITS = int(@MATCH_INDEX_BITS@);\nconst int MATCH_INDEX_MASK = int(@MATCH_INDEX_MASK@);\nconst int MATCH_MAX_INDEX = int(@MATCH_MAX_INDEX@);\nconst int MATCH_MAX_DISTANCE = int(@MATCH_MAX_DISTANCE@);\nstruct KeypointMatch\n{\nint index;\nint dist;\n};\nvec4 encodeKeypointMatch(KeypointMatch candidate)\n{\nuint index = uint(candidate.index & MATCH_INDEX_MASK);\nuint dist = uint(clamp(candidate.dist, 0, MATCH_MAX_DISTANCE));\nuint u32 = index | (dist << MATCH_INDEX_BITS);\nreturn encodeUint32(u32);\n}\nKeypointMatch decodeKeypointMatch(vec4 rgba)\n{\nuint u32 = decodeUint32(rgba);\nint dist = int(u32 >> MATCH_INDEX_BITS);\nint index = int(u32 & uint(MATCH_INDEX_MASK));\nreturn KeypointMatch(index, dist);\n}\nconst KeypointMatch MATCH_NOT_FOUND = KeypointMatch(MATCH_MAX_INDEX, MATCH_MAX_DISTANCE);\n#endif'},"./src/gpu/shaders/include/keypoints.glsl":e=>{e.exports='#ifndef _KEYPOINTS_GLSL\n#define _KEYPOINTS_GLSL\n@include "math.glsl"\n@include "fixed-point.glsl"\n@include "float16.glsl"\n@include "pyramids.glsl"\nstruct Keypoint\n{\nvec2 position;\nfloat lod;\nfloat orientation;\nfloat score;\nuint flags;\n};\nstruct KeypointAddress\n{\nint base;\nint offset;\n};\nconst int MIN_KEYPOINT_SIZE = int(@MIN_KEYPOINT_SIZE@);\nconst int MAX_DESCRIPTOR_SIZE = int(@MAX_DESCRIPTOR_SIZE@);\nconst uint KPF_NONE = 0u;\nconst uint KPF_NULL = 1u;\nconst uint KPF_DISCARDED = 2u;\n#define encodeKeypointScore(score) encodeFloat16(score)\n#define decodeKeypointScore(encodedScore) decodeFloat16(encodedScore)\n#define encodeKeypointOrientation(angle) ((angle) * INV_PI_OVER_2 + 0.5f)\n#define decodeKeypointOrientation(value) ((value) * TWO_PI - PI)\n#define encodeNullKeypoint() (vec4(1.0f))\n#define encodeDiscardedKeypoint() (vec4(0.0f))\n#define isNullKeypoint(keypoint) ((((keypoint).flags) & KPF_NULL) != 0u)\n#define isDiscardedKeypoint(keypoint) ((((keypoint).flags) & KPF_DISCARDED) != 0u)\n#define isBadKeypoint(keypoint) ((keypoint).score < 0.0f)\n#define sizeofEncodedKeypoint(descriptorSize, extraSize) (MIN_KEYPOINT_SIZE + (descriptorSize) + (extraSize))\n#define sizeofEncodedKeypointHeader() sizeofEncodedKeypoint(0,0)\n#define findKeypointIndex(address, descriptorSize, extraSize) ((address).base / ((sizeofEncodedKeypoint((descriptorSize), (extraSize))) / 4))\nvec4 readKeypointData(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\n{\nint rasterIndex = address.base + address.offset;\nvec4 data = pixelAt(encodedKeypoints, ivec2(rasterIndex % encoderLength, rasterIndex / encoderLength));\nreturn rasterIndex < encoderLength * encoderLength ? data : encodeNullKeypoint();\n}\nKeypointAddress findKeypointAddress(ivec2 thread, int encoderLength, int descriptorSize, int extraSize)\n{\nint threadRaster = thread.y * encoderLength + thread.x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nint keypointIndex = int(threadRaster / pixelsPerKeypoint);\nKeypointAddress address = KeypointAddress(\nkeypointIndex * pixelsPerKeypoint,\nthreadRaster % pixelsPerKeypoint\n);\nreturn address;\n}\nKeypoint decodeKeypoint(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\n{\nKeypoint keypoint;\nKeypointAddress positionAddress = KeypointAddress(address.base, 0);\nKeypointAddress propertiesAddress = KeypointAddress(address.base, 1);\nvec4 rawEncodedPosition = readKeypointData(encodedKeypoints, encoderLength, positionAddress);\nivec4 encodedPosition = ivec4(rawEncodedPosition * 255.0f);\nkeypoint.position = fixtovec2(fixed2_t(\nencodedPosition.r | (encodedPosition.g << 8),\nencodedPosition.b | (encodedPosition.a << 8)\n));\nvec4 rawEncodedProperties = readKeypointData(encodedKeypoints, encoderLength, propertiesAddress);\nkeypoint.lod = decodeLod(rawEncodedProperties.r);\nkeypoint.orientation = decodeKeypointOrientation(rawEncodedProperties.g);\nkeypoint.score = decodeKeypointScore(rawEncodedProperties.ba);\nbool isNull = all(equal(rawEncodedPosition, vec4(1)));\nbool isDiscarded = all(equal(rawEncodedPosition + rawEncodedProperties, vec4(0)));\nkeypoint.score = (isNull || isDiscarded) ? -1.0f : keypoint.score;\nkeypoint.flags = KPF_NONE;\nkeypoint.flags |= KPF_NULL * uint(isNull);\nkeypoint.flags |= KPF_DISCARDED * uint(isDiscarded);\nreturn keypoint;\n}\nvec4 encodeKeypointPosition(vec2 position)\n{\nconst vec2 zeros = vec2(0.0f);\nfixed2_t pos = vec2tofix(max(position, zeros));\nfixed2_t lo = pos & 255;\nfixed2_t hi = (pos >> 8) & 255;\nreturn vec4(lo.x, hi.x, lo.y, hi.y) / 255.0f;\n}\n#endif'},"./src/gpu/shaders/include/math.glsl":e=>{e.exports="#ifndef _MATH_GLSL\n#define _MATH_GLSL\n#define TWO_PI          6.28318530718f\n#define PI              3.14159265359f\n#define PI_OVER_2       1.57079632679f\n#define PI_OVER_4       0.78539816339f\n#define INV_PI          0.3183098861837907f\n#define INV_PI_OVER_2   0.15915494309189535f\nconst highp float INFINITY = 1.0f / 0.0f;\nfloat fastAtan(float x)\n{\nfloat w = 1.0f - abs(x);\nreturn (w >= 0.0f) ? ((PI_OVER_4 + 0.273f * w) * x) :\n(sign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273f * (1.0f - abs(1.0f / x))) / x);\n}\nfloat fastAtan2(float y, float x)\n{\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\n}\n#endif"},"./src/gpu/shaders/include/pyramids.glsl":e=>{e.exports="#ifndef _PYRAMIDS_GLSL\n#define _PYRAMIDS_GLSL\n#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))\n#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\n#define pyrPixelAt(pyr, pos, lod) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / texSize, (lod))\n#define pyrPixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\n#define pyrSubpixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), ((pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\n#define pyrSubpixelAtExOffset(pyr, pos, lod, pot, offset, pyrBaseSize) textureLod((pyr), (((pos) + vec2(0.5f)) + ((pot) * vec2(offset))) / vec2(pyrBaseSize), (lod))\nconst int PYRAMID_MAX_LEVELS = int(@PYRAMID_MAX_LEVELS@);\nconst float F_PYRAMID_MAX_LEVELS = float(@PYRAMID_MAX_LEVELS@);\nconst float LOG2_PYRAMID_MAX_SCALE = float(@LOG2_PYRAMID_MAX_SCALE@);\n#define encodeLod(lod) ((LOG2_PYRAMID_MAX_SCALE + (lod)) / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS))\nfloat decodeLod(float encodedLod)\n{\nfloat lod = encodedLod * (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE;\nreturn lod - lod * step(1.0f, encodedLod);\n}\n#define LOD_EPS 0.0625f\nconst float ENCODED_LOD_EPS = (LOD_EPS / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS));\n#define isSameLod(lod1, lod2) (abs((lod1) - (lod2)) < LOD_EPS)\n#define isSameEncodedLod(alpha1, alpha2) (abs((alpha1) - (alpha2)) < ENCODED_LOD_EPS)\n#endif"},"./src/gpu/shaders/include/subpixel.glsl":e=>{e.exports="#ifndef _SUBPIXEL_GLSL\n#define _SUBPIXEL_GLSL\n#define subpixelAt(image, pos) textureLod((image), ((pos) + vec2(0.5f)) / texSize, 0.0f)\nvec4 subpixelAtBI(sampler2D image, vec2 pos)\n{\nvec2 frc = fract(pos);\nvec2 ifrc = vec2(1.0f) - frc;\nvec2 p = (floor(pos) + vec2(0.5f)) / vec2(textureSize(image, 0));\nvec4 pix00 = textureLod(image, p, 0.0f);\nvec4 pix10 = textureLodOffset(image, p, 0.0f, ivec2(1,0));\nvec4 pix01 = textureLodOffset(image, p, 0.0f, ivec2(0,1));\nvec4 pix11 = textureLodOffset(image, p, 0.0f, ivec2(1,1));\nmat4 pix = mat4(pix00, pix10, pix01, pix11);\nvec4 mul = vec4(ifrc.x * ifrc.y, frc.x * ifrc.y, ifrc.x * frc.y, frc.x * frc.y);\nreturn pix * mul;\n}\n#endif"},"./src/gpu/shaders/keypoints/allocate-descriptors.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D inputEncodedKeypoints;\nuniform int inputDescriptorSize;\nuniform int inputExtraSize;\nuniform int inputEncoderLength;\nuniform int outputDescriptorSize;\nuniform int outputExtraSize;\nuniform int outputEncoderLength;\nconst vec4 EMPTY_DESCRIPTOR = vec4(0.0f);\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, outputEncoderLength, outputDescriptorSize, outputExtraSize);\nint myIndex = findKeypointIndex(myAddress, outputDescriptorSize, outputExtraSize);\nint headerSize = sizeofEncodedKeypointHeader();\nbool isDescriptor = (myAddress.offset >= (headerSize + outputExtraSize) / 4);\nint addressOffset = myAddress.offset;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\nKeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, addressOffset);\ncolor = isDescriptor ? EMPTY_DESCRIPTOR : readKeypointData(inputEncodedKeypoints, inputEncoderLength, otherAddress);\n}'},"./src/gpu/shaders/keypoints/allocate-extra.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D inputEncodedKeypoints;\nuniform int inputDescriptorSize;\nuniform int inputExtraSize;\nuniform int inputEncoderLength;\nuniform int outputDescriptorSize;\nuniform int outputExtraSize;\nuniform int outputEncoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, outputEncoderLength, outputDescriptorSize, outputExtraSize);\nint myIndex = findKeypointIndex(myAddress, outputDescriptorSize, outputExtraSize);\nint headerSize = sizeofEncodedKeypointHeader();\nbool isHead = (myAddress.offset < headerSize / 4);\nbool isDescriptor = (myAddress.offset >= (headerSize + outputExtraSize) / 4);\nbool isExtra = (!isHead && !isDescriptor);\nint numberOfExtraPixels = outputExtraSize / 4;\nint addressOffset = myAddress.offset - int(isDescriptor) * numberOfExtraPixels;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\nKeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, addressOffset);\ncolor = isExtra ? vec4(0.0f) : readKeypointData(inputEncodedKeypoints, inputEncoderLength, otherAddress);\n}'},"./src/gpu/shaders/keypoints/apply-homography.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform mat3 homography;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\ncolor = pixel;\nif(address.offset != 0)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nvec3 pos3 = homography * vec3(keypoint.position, 1.0f);\ncolor = encodeKeypointPosition(pos3.xy / pos3.z);\n}'},"./src/gpu/shaders/keypoints/bf-knn.glsl":e=>{e.exports='@include "keypoints.glsl"\n@include "keypoint-descriptors.glsl"\n@include "keypoint-matches.glsl"\nuniform sampler2D encodedMatches;\nuniform sampler2D encodedFilters;\nuniform int matcherLength;\nuniform sampler2D dbEncodedKeypoints;\nuniform int dbDescriptorSize;\nuniform int dbExtraSize;\nuniform int dbEncoderLength;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int passId;\n#ifndef NUMBER_OF_KEYPOINTS_PER_PASS\n#error Undefined NUMBER_OF_KEYPOINTS_PER_PASS\n#endif\nconst int INFINITE_DISTANCE = MATCH_MAX_DISTANCE + 1;\nvoid main()\n{\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * matcherLength;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\ncolor = encodeKeypointMatch(MATCH_NOT_FOUND);\nif(isBadKeypoint(keypoint))\nreturn;\nKeypointMatch bestMatch = decodeKeypointMatch(threadPixel(encodedMatches));\nKeypointMatch filterMatch = decodeKeypointMatch(threadPixel(encodedFilters));\nuint[DESCRIPTOR_SIZE] descriptor = readKeypointDescriptor(encodedKeypoints, descriptorSize, extraSize, encoderLength, address);\nuint[DESCRIPTOR_SIZE] dbDescriptor;\nint dbPixelsPerKeypoint = sizeofEncodedKeypoint(dbDescriptorSize, dbExtraSize) / 4;\nfor(int i = 0; i < NUMBER_OF_KEYPOINTS_PER_PASS; i++) {\nint dbKeypointIndex = passId * NUMBER_OF_KEYPOINTS_PER_PASS + i;\nKeypointAddress dbAddress = KeypointAddress(dbKeypointIndex * dbPixelsPerKeypoint, 0);\nKeypoint dbKeypoint = decodeKeypoint(dbEncodedKeypoints, dbEncoderLength, dbAddress);\ndbDescriptor = readKeypointDescriptor(dbEncodedKeypoints, dbDescriptorSize, dbExtraSize, dbEncoderLength, dbAddress);\nint dist = !isBadKeypoint(dbKeypoint) ? distanceBetweenKeypointDescriptors(descriptor, dbDescriptor) : INFINITE_DISTANCE;\nbestMatch.index = all(bvec2(\ndist < bestMatch.dist || (dist == bestMatch.dist && dbKeypointIndex > bestMatch.index),\ndist > filterMatch.dist || (dist == filterMatch.dist && dbKeypointIndex < filterMatch.index)\n)) ? dbKeypointIndex : bestMatch.index;\nbestMatch.dist = dbKeypointIndex == bestMatch.index ? dist : bestMatch.dist;\n}\ncolor = encodeKeypointMatch(bestMatch);\n}'},"./src/gpu/shaders/keypoints/clip-border.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform int imageWidth;\nuniform int imageHeight;\nuniform int borderTop;\nuniform int borderRight;\nuniform int borderBottom;\nuniform int borderLeft;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, addr);\nvec2 p = keypoint.position;\nbool withinBorder = any(lessThan(\nvec4(p.x, p.y, -p.x, -p.y),\nvec4(borderLeft, borderTop, borderRight - (imageWidth - 1), borderBottom - (imageHeight - 1))\n));\nvec4 pixel = threadPixel(encodedKeypoints);\nvec4 nullPixel = encodeNullKeypoint();\ncolor = withinBorder ? nullPixel : pixel;\n}'},"./src/gpu/shaders/keypoints/clip.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int maxKeypoints;\nvoid main()\n{\nivec2 thread = threadLocation();\nint newEncoderLength = outputSize().x;\nKeypointAddress address = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\nvec4 pixel = readKeypointData(encodedKeypoints, encoderLength, address);\ncolor = index < maxKeypoints ? pixel : encodeNullKeypoint();\n}'},"./src/gpu/shaders/keypoints/distance-filter.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypointsA;\nuniform int encoderLengthA;\nuniform sampler2D encodedKeypointsB;\nuniform int encoderLengthB;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform float threshold;\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nvec4 data = readKeypointData(encodedKeypointsA, encoderLengthA, address);\ncolor = data;\nif(address.offset >= sizeofEncodedKeypointHeader() / 4)\nreturn;\nKeypoint keypointA = decodeKeypoint(encodedKeypointsA, encoderLengthA, address);\nKeypoint keypointB = decodeKeypoint(encodedKeypointsB, encoderLengthB, address);\ncolor = encodeNullKeypoint();\nif(isNullKeypoint(keypointA) && isNullKeypoint(keypointB))\nreturn;\ncolor = encodeDiscardedKeypoint();\nif(isDiscardedKeypoint(keypointA) || isDiscardedKeypoint(keypointB))\nreturn;\ncolor = encodeDiscardedKeypoint();\nif(isNullKeypoint(keypointA) || isNullKeypoint(keypointB))\nreturn;\nvec2 delta = keypointA.position - keypointB.position;\nbool shouldKeep = (dot(delta, delta) <= threshold * threshold);\ncolor = shouldKeep ? data : encodeDiscardedKeypoint();\n}'},"./src/gpu/shaders/keypoints/encode-keypoint-long-offsets.glsl":e=>{e.exports='@include "float16.glsl"\nuniform sampler2D offsetsImage;\nuniform ivec2 imageSize;\n#ifndef MAX_ITERATIONS\n#error Undefined MAX_ITERATIONS\n#endif\n#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).a * 255.0f) << 8))\n#define encodeSkipOffset(offset) (vec2((offset) & 255, (offset) >> 8) / 255.0f)\nvoid main()\n{\nvec4 pixel = threadPixel(offsetsImage);\nivec2 thread = threadLocation();\nint rasterIndex = thread.y * imageSize.x + thread.x;\nint offset = decodeSkipOffset(pixel);\nint totalOffset = offset;\nvec2 encodedScore = pixel.rb;\nivec2 pos = thread; int allow = 1;\n@unroll\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\nallow *= int(pos.y < imageSize.y) * int(isEncodedFloat16Zero(pixel.rb));\nrasterIndex += allow * offset;\npos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\npixel = pixelAt(offsetsImage, pos);\noffset = decodeSkipOffset(pixel);\ntotalOffset += allow * offset;\n}\ntotalOffset = min(totalOffset, 65535);\ncolor.rb = encodedScore;\ncolor.ga = encodeSkipOffset(totalOffset);\n}'},"./src/gpu/shaders/keypoints/encode-keypoint-offsets.glsl":e=>{e.exports='@include "float16.glsl"\nuniform sampler2D corners;\nuniform ivec2 imageSize;\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nivec2 pos = threadLocation();\nvec2 encodedScore = pixel.rb;\nint offset = 0, allow = 1, jumped = 0;\n#define READ(j) ; \\\nallow *= int(pos.y < imageSize.y) * int(isEncodedFloat16Zero(pixel.rb)); \\\noffset += allow; \\\npos.x = (pos.x + 1) % imageSize.x; \\\npos.y += int(pos.x == 0); \\\npixel = (0 != (jumped |= int(pos.x == 0))) ? pixelAtShortOffset(corners, ivec2((j),1)) : pixelAtShortOffset(corners, ivec2((j),0))\nREAD(1); READ(2); READ(3); READ(4); READ(5); READ(6); READ(7);\ncolor.rb = encodedScore;\ncolor.ga = vec2(offset, 0) / 255.0f;\n}'},"./src/gpu/shaders/keypoints/encode-keypoint-positions.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D offsetsImage;\nuniform ivec2 imageSize;\nuniform int passId;\nuniform int numPasses;\nuniform int keypointLimit;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).a * 255.0f) << 8))\nbool findQthKeypoint(int q, int p, inout ivec2 position, out vec4 pixel)\n{\nint notFirstPass = int(passId > 0);\nposition *= notFirstPass;\np |= -(1 - notFirstPass);\np -= notFirstPass;\nint rasterIndex = position.y * imageSize.x + position.x;\nwhile(position.y < imageSize.y && p != q) {\nposition = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\npixel = texelFetch(offsetsImage, position, 0);\np += int(!isEncodedFloat16Zero(pixel.rb));\nrasterIndex += max(1, decodeSkipOffset(pixel));\n}\nreturn (p == q);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint q = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = vec4(0.0f);\nif(address.offset != 0)\nreturn;\ncolor = threadPixel(encodedKeypoints);\nint numPixels = encoderLength * encoderLength;\nint maxKeypoints = numPixels / pixelsPerKeypoint;\nint maxKeypointsPerPass = maxKeypoints / numPasses + int(maxKeypoints % numPasses != 0);\nint targetPassId = q / maxKeypointsPerPass;\nif(passId != targetPassId)\nreturn;\nint lastIndexFromPrevPass = passId * maxKeypointsPerPass - 1;\nKeypointAddress lastAddressFromPrevPass = KeypointAddress(max(0, lastIndexFromPrevPass) * pixelsPerKeypoint, 0);\nKeypoint lastKeypointFromPrevPass = decodeKeypoint(encodedKeypoints, encoderLength, lastAddressFromPrevPass);\nivec2 position = passId > 0 ? ivec2(lastKeypointFromPrevPass.position) : ivec2(0);\nvec4 pixel;\ncolor = encodeNullKeypoint();\nif(q >= min(maxKeypoints, keypointLimit) || !findQthKeypoint(q, lastIndexFromPrevPass, position, pixel))\nreturn;\ncolor = encodeKeypointPosition(vec2(position));\n}'},"./src/gpu/shaders/keypoints/encode-keypoint-properties.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D corners;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(encodedKeypoints);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint q = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = pixel;\nif(address.offset != 1)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nvec4 kpix = pixelAt(corners, ivec2(keypoint.position));\nkeypoint.score = decodeFloat16(kpix.rb);\ncolor.r = kpix.a;\ncolor.g = encodeKeypointOrientation(0.0f);\ncolor.ba = encodeKeypointScore(keypoint.score);\n}'},"./src/gpu/shaders/keypoints/encode-keypoints.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D corners;\nuniform mediump usampler2D lookupTable;\nuniform int stride;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int encoderCapacity;\nconst uvec2 NULL_ELEMENT = uvec2(0xFFFFu);\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\nivec2 pos = ivec2(index % stride, index / stride);\nuvec4 entry = texelFetch(lookupTable, pos, 0);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nint rasterIndex = address.base + address.offset;\nint numberOfPixels = encoderLength * encoderLength;\nint numberOfValidPixels = numberOfPixels - (numberOfPixels % pixelsPerKeypoint);\nint maxEncoderCapacity = numberOfValidPixels / pixelsPerKeypoint;\ncolor = encodeNullKeypoint();\nif(all(equal(entry.xy, NULL_ELEMENT)) || index >= min(encoderCapacity, maxEncoderCapacity))\nreturn;\ncolor = encodeKeypointPosition(vec2(entry.xy));\nif(address.offset == 0)\nreturn;\ncolor = vec4(0.0f);\nif(address.offset >= sizeofEncodedKeypointHeader() / 4)\nreturn;\nvec4 pixel = texelFetch(corners, ivec2(entry.xy), 0);\nvec2 encodedScore = encodeKeypointScore(decodeFloat16(pixel.rb));\nfloat encodedOrientation = encodeKeypointOrientation(0.0f);\nfloat encodedLod = pixel.a;\ncolor = vec4(encodedLod, encodedOrientation, encodedScore);\n}'},"./src/gpu/shaders/keypoints/encode-null-keypoints.glsl":e=>{e.exports='@include "keypoints.glsl"\nvoid main()\n{\ncolor = encodeNullKeypoint();\n}'},"./src/gpu/shaders/keypoints/fast.glsl":e=>{e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform float lod;\nuniform int threshold;\n#define USE_VARYINGS 1\n#if !defined(FAST_TYPE)\n#error Undefined FAST_TYPE\n#elif FAST_TYPE == 916\nin vec2 v_pix0, v_pix1, v_pix2, v_pix3, v_pix4, v_pix5, v_pix6, v_pix7,\nv_pix8, v_pix9, v_pix10,v_pix11,v_pix12,v_pix13,v_pix14,v_pix15;\n#else\n#error Invalid FAST_TYPE\n#endif\n#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\n#define XIP(v) textureLod(pyramid, (v), lod).g\nvoid main()\n{\nfloat pixel = threadPixel(pyramid).g;\nvec4 prev = threadPixel(corners);\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nfloat pot = exp2(lod);\nfloat t = float(clamp(threshold, 0, 255)) / 255.0f;\nfloat ct = pixel + t, c_t = pixel - t;\ncolor = vec4(prev.r, pixel, prev.ba);\n#if FAST_TYPE == 916\nconst ivec4 margin = ivec4(3, 3, 4, 4);\nif(any(lessThan(ivec4(thread, size - thread), margin)))\nreturn;\n#if USE_VARYINGS\nfloat p0 = XIP(v_pix0), p4 = XIP(v_pix4), p8 = XIP(v_pix8), p12 = XIP(v_pix12);\n#else\nfloat p0 = PIX(0,3), p4 = PIX(3,0), p8 = PIX(0,-3), p12 = PIX(-3,0);\n#endif\nbvec4 brighter = bvec4(p0 > ct, p4 > ct, p8 > ct, p12 > ct);\nbvec4 darker = bvec4(p0 < c_t, p4 < c_t, p8 < c_t, p12 < c_t);\nbvec4 bpairs = bvec4(all(brighter.xy), all(brighter.yz), all(brighter.zw), all(brighter.wx));\nbvec4 dpairs = bvec4(all(darker.xy), all(darker.yz), all(darker.zw), all(darker.wx));\nif(!(any(bpairs) || any(dpairs)))\nreturn;\n#if USE_VARYINGS\nfloat p1 = XIP(v_pix1), p2 = XIP(v_pix2), p3 = XIP(v_pix3),\np5 = XIP(v_pix5), p6 = XIP(v_pix6), p7 = XIP(v_pix7),\np9 = XIP(v_pix9), p10 = XIP(v_pix10), p11 = XIP(v_pix11),\np13 = XIP(v_pix13), p14 = XIP(v_pix14), p15 = XIP(v_pix15);\n#else\nfloat p1 = PIX(1,3), p2 = PIX(2,2), p3 = PIX(3,1),\np5 = PIX(3,-1), p6 = PIX(2,-2), p7 = PIX(1,-3),\np9 = PIX(-1,-3), p10 = PIX(-2,-2), p11 = PIX(-3,-1),\np13 = PIX(-3,1), p14 = PIX(-2,2), p15 = PIX(-1,3);\n#endif\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\nif(!isCorner)\nreturn;\nmat4 mp = mat4(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);\nmat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);\nmat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;\nconst vec4 zeros = vec4(0.0f), ones = vec4(1.0f);\nvec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);\nbs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);\nbs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);\nbs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);\nfloat thisScore = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\nfloat prevScore = decodeFloat16(prev.rb);\nvec3 thisResult = vec3(encodeFloat16(thisScore), encodeLod(lod));\ncolor.rba = thisScore > prevScore ? thisResult : color.rba;\n#endif\n}'},"./src/gpu/shaders/keypoints/fast.vs.glsl":e=>{e.exports="uniform mediump float lod;\n#if !defined(FAST_TYPE)\n#error Undefined FAST_TYPE\n#elif FAST_TYPE == 916\nout vec2 v_pix0, v_pix1, v_pix2, v_pix3, v_pix4, v_pix5, v_pix6, v_pix7,\nv_pix8, v_pix9, v_pix10,v_pix11,v_pix12,v_pix13,v_pix14,v_pix15;\n#else\n#error Invalid FAST_TYPE\n#endif\n#define PIX(x,y) (texCoord + ((pot) * vec2((x),(y))) / texSize)\nvoid vsmain()\n{\nfloat pot = exp2(lod);\n#if FAST_TYPE == 916\nv_pix0 = PIX(0,3); v_pix1 = PIX(1,3), v_pix2 = PIX(2,2), v_pix3 = PIX(3,1);\nv_pix4 = PIX(3,0); v_pix5 = PIX(3,-1), v_pix6 = PIX(2,-2), v_pix7 = PIX(1,-3);\nv_pix8 = PIX(0,-3); v_pix9 = PIX(-1,-3), v_pix10 = PIX(-2,-2), v_pix11 = PIX(-3,-1);\nv_pix12 = PIX(-3,0); v_pix13 = PIX(-3,1), v_pix14 = PIX(-2,2), v_pix15 = PIX(-1,3);\n#endif\n}"},"./src/gpu/shaders/keypoints/hamming-distance-filter.glsl":e=>{e.exports='@include "keypoints.glsl"\n@include "keypoint-descriptors.glsl"\nuniform sampler2D encodedKeypointsA;\nuniform int encoderLengthA;\nuniform sampler2D encodedKeypointsB;\nuniform int encoderLengthB;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int threshold;\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nvec4 data = readKeypointData(encodedKeypointsA, encoderLengthA, address);\ncolor = data;\nif(address.offset >= sizeofEncodedKeypointHeader() / 4)\nreturn;\nKeypoint keypointA = decodeKeypoint(encodedKeypointsA, encoderLengthA, address);\nKeypoint keypointB = decodeKeypoint(encodedKeypointsB, encoderLengthB, address);\ncolor = encodeNullKeypoint();\nif(isNullKeypoint(keypointA) && isNullKeypoint(keypointB))\nreturn;\ncolor = encodeDiscardedKeypoint();\nif(isDiscardedKeypoint(keypointA) || isDiscardedKeypoint(keypointB))\nreturn;\ncolor = encodeDiscardedKeypoint();\nif(isNullKeypoint(keypointA) || isNullKeypoint(keypointB))\nreturn;\nuint[DESCRIPTOR_SIZE] descriptorA, descriptorB;\ndescriptorA = readKeypointDescriptor(encodedKeypointsA, descriptorSize, extraSize, encoderLengthA, address);\ndescriptorB = readKeypointDescriptor(encodedKeypointsB, descriptorSize, extraSize, encoderLengthB, address);\nint dist = distanceBetweenKeypointDescriptors(descriptorA, descriptorB);\nbool shouldKeep = (dist <= threshold);\ncolor = shouldKeep ? data : encodeDiscardedKeypoint();\n}'},"./src/gpu/shaders/keypoints/harris-cutoff.glsl":e=>{e.exports='@include "float16.glsl"\nuniform sampler2D corners;\nuniform sampler2D maxScore;\nuniform float quality;\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nfloat score = decodeFloat16(pixel.rb);\nfloat maxval = decodeFloat16(threadPixel(maxScore).rb);\nfloat threshold = maxval * clamp(quality, 0.0f, 1.0f);\ncolor = pixel;\ncolor.rb = score >= threshold ? color.rb : encodeFloat16(0.0f);\n}'},"./src/gpu/shaders/keypoints/harris.glsl":e=>{e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\n@include "filters.glsl"\n#if !defined(WINDOW_SIZE)\n#error Undefined WINDOW_SIZE\n#endif\n#define WINDOW_RADIUS ((WINDOW_SIZE - 1) / 2)\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform sampler2D derivatives;\nuniform float lod;\nuniform float lodStep;\nuniform float gaussian[@WINDOW_SIZE@];\n#define G(x) gaussian[(x) + WINDOW_RADIUS]\n#define W(x,y) (G(x) * G(y))\n#define H(ox,oy) dpix = pixelAtShortOffset(derivatives, ivec2((ox),(oy))); \\\ndf = (1.0f + lod) * decodePairOfFloat16(dpix); \\\nh += vec3(df.x * df.x, df.x * df.y, df.y * df.y) * W((ox),(oy))\nvoid main()\n{\nfloat intensity = 0.0f;\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(corners);\nvec4 dpix = vec4(0.0f);\nvec2 df = vec2(0.0f);\nvec3 h = vec3(0.0f);\ncolor = pixel;\n#if WINDOW_SIZE == 1\nH(0,0);\n#elif WINDOW_SIZE == 3\nH(-1,-1); H(0,-1); H(1,-1);\nH(-1,0); H(0,0); H(1,0);\nH(-1,1); H(0,1); H(1,1);\n#elif WINDOW_SIZE == 5\nH(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2);\nH(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1);\nH(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0);\nH(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1);\nH(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2);\n#elif WINDOW_SIZE == 7\nH(-3,-3); H(-2,-3); H(-1,-3); H(0,-3); H(1,-3); H(2,-3); H(3,-3);\nH(-3,-2); H(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2); H(3,-2);\nH(-3,-1); H(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1); H(3,-1);\nH(-3,0); H(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0); H(3,0);\nH(-3,1); H(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1); H(3,1);\nH(-3,2); H(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2); H(3,2);\nH(-3,3); H(-2,3); H(-1,3); H(0,3); H(1,3); H(2,3); H(3,3);\n#else\n#error Invalid WINDOW_SIZE\n#endif\nfloat response = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));\nresponse /= float(WINDOW_SIZE * WINDOW_SIZE);\nfloat lodPlus = min(float(PYRAMID_MAX_LEVELS - 1), lod + lodStep);\nfloat currentScaleStrength = abs(laplacian(pyramid, vec2(thread), lod));\nfloat previousScaleStrength = abs(laplacian(pyramid, vec2(thread), lodPlus));\nfloat previousResponse = decodeFloat16(pixel.rb);\nvec4 result = vec4(encodeFloat16(response), encodeLod(lod), intensity);\ncolor.rbag = (currentScaleStrength >= previousScaleStrength || previousResponse == 0.0f) ? result : pixel.rbag;\n}'},"./src/gpu/shaders/keypoints/knn-init.glsl":e=>{e.exports='@include "keypoint-matches.glsl"\nvoid main()\n{\n#if ENCODE_FILTERS != 0\nKeypointMatch initial = KeypointMatch(MATCH_MAX_INDEX, 0);\n#else\nKeypointMatch initial = KeypointMatch(MATCH_MAX_INDEX, MATCH_MAX_DISTANCE);\n#endif\ncolor = encodeKeypointMatch(initial);\n}'},"./src/gpu/shaders/keypoints/knn-transfer.glsl":e=>{e.exports='@include "keypoint-matches.glsl"\nuniform sampler2D encodedMatches;\nuniform sampler2D encodedKthMatches;\nuniform int numberOfMatchesPerKeypoint;\nuniform int kthMatch;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 matcherSize = textureSize(encodedMatches, 0);\nivec2 kthMatcherSize = textureSize(encodedKthMatches, 0);\nint rasterIndex = thread.y * matcherSize.x + thread.x;\nint matchIndex = rasterIndex / numberOfMatchesPerKeypoint;\nint matchCell = rasterIndex % numberOfMatchesPerKeypoint;\ncolor = threadPixel(encodedMatches);\nif(matchCell != kthMatch)\nreturn;\ncolor = encodeKeypointMatch(MATCH_NOT_FOUND);\nif(matchIndex >= kthMatcherSize.x * kthMatcherSize.y)\nreturn;\nivec2 pos = ivec2(matchIndex % kthMatcherSize.x, matchIndex / kthMatcherSize.x);\ncolor = texelFetch(encodedKthMatches, pos, 0);\n}'},"./src/gpu/shaders/keypoints/laplacian.glsl":e=>{e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\n@include "filters.glsl"\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform float lodStep;\nuniform float lodOffset;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(corners);\nfloat lod = decodeLod(pixel.a);\nfloat lodMinus = max(0.0f, lod - lodStep + lodOffset);\nfloat lodPlus = min(float(PYRAMID_MAX_LEVELS - 1), lod + lodStep + lodOffset);\nfloat lapMinus = laplacian(pyramid, vec2(thread), lodMinus);\nfloat lapPlus = abs(lodPlus - lodMinus) < 1e-5 ? lapMinus : laplacian(pyramid, vec2(thread), lodPlus);\ncolor = encodePairOfFloat16(vec2(lapMinus, lapPlus));\n}'},"./src/gpu/shaders/keypoints/lk.glsl":e=>{e.exports='@include "keypoints.glsl"\n@include "float16.glsl"\nuniform sampler2D nextPyramid;\nuniform sampler2D prevPyramid;\nuniform sampler2D encodedFlow;\nuniform sampler2D prevKeypoints;\nuniform int level;\nuniform int depth;\nuniform int numberOfIterations;\nuniform float discardThreshold;\nuniform float epsilon;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#ifndef WINDOW_SIZE\n#error Undefined WINDOW_SIZE\n#endif\n#define NEXT_IMAGE 1\n#define PREV_IMAGE 0\nconst int WINDOW_RADIUS = (WINDOW_SIZE - 1) / 2;\nconst int WINDOW_SIZE_SQUARED = (WINDOW_SIZE) * (WINDOW_SIZE);\nconst int WINDOW_SIZE_PLUS = (WINDOW_SIZE) + 2;\nconst int WINDOW_SIZE_PLUS_SQUARED = WINDOW_SIZE_PLUS * WINDOW_SIZE_PLUS;\nconst int DBL_WINDOW_SIZE_PLUS_SQUARED = 2 * WINDOW_SIZE_PLUS_SQUARED;\nconst int WINDOW_RADIUS_PLUS = (WINDOW_SIZE_PLUS - 1) / 2;\nconst highp float FLT_SCALE = 9.5367431640625e-7;\nconst highp float FLT_EPSILON = 0.00000011920929f;\nint pixelBuffer[DBL_WINDOW_SIZE_PLUS_SQUARED];\n#define prevPixel(index) pixelBuffer[(index)]\n#define nextPixel(index) pixelBuffer[WINDOW_SIZE_PLUS_SQUARED + (index)]\n#define pixelIndex(i, j) (((j) + WINDOW_RADIUS_PLUS) * WINDOW_SIZE_PLUS + ((i) + WINDOW_RADIUS_PLUS))\nivec2 derivBuffer[WINDOW_SIZE_SQUARED];\n#define derivativesAt(x, y) derivBuffer[((y) + WINDOW_RADIUS) * WINDOW_SIZE + ((x) + WINDOW_RADIUS)]\nvoid readWindow(vec2 center, float lod)\n{\nconst int r = WINDOW_RADIUS;\nivec2 pyrBaseSize = textureSize(prevPyramid, 0);\nfloat pot = exp2(lod);\nivec2 offset; int idx;\n#define readPixelsAt(ox, oy) offset = ivec2((ox), (oy)); \\\nidx = pixelIndex(offset.x, offset.y); \\\nnextPixel(idx) = int(255.0f * pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g); \\\nprevPixel(idx) = int(255.0f * pyrSubpixelAtExOffset(prevPyramid, center, lod, pot, offset, pyrBaseSize).g)\nfor(int j = 0; j < WINDOW_SIZE; j++) {\nfor(int i = 0; i < WINDOW_SIZE; i++) {\nreadPixelsAt(i-r, j-r);\n}\n}\nint r1 = r+1;\nfor(int k = 0; k < WINDOW_SIZE; k++) {\nreadPixelsAt(-r1, k-r);\nreadPixelsAt( r1, k-r);\nreadPixelsAt(k-r,-r1);\nreadPixelsAt(k-r, r1);\n}\nreadPixelsAt(-r1,-r1);\nreadPixelsAt( r1,-r1);\nreadPixelsAt(-r1, r1);\nreadPixelsAt( r1, r1);\n}\nivec2 computeDerivatives(int imageCode, ivec2 offset)\n{\nconst mat3 dx = mat3(\n3, 0, -3,\n10, 0, -10,\n3, 0, -3\n);\nconst mat3 dy = mat3(\n3, 10, 3,\n0, 0, 0,\n-3, -10, -3\n);\nint indexOffset = imageCode * WINDOW_SIZE_PLUS_SQUARED;\nmat3 window = mat3(\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+0)],\n0.0f,\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+0)],\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y+1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+1)]\n);\nmat3 fx = matrixCompMult(dx, window);\nmat3 fy = matrixCompMult(dy, window);\nconst vec3 ones = vec3(1.0f);\nreturn ivec2(\ndot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),\ndot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)\n);\n}\nint readBufferedPixel(int imageCode, ivec2 offset)\n{\nconst int r = WINDOW_RADIUS;\noffset = clamp(offset, -r, r);\nint indexOffset = imageCode * WINDOW_SIZE_PLUS_SQUARED;\nreturn pixelBuffer[indexOffset + pixelIndex(offset.x, offset.y)];\n}\nint readBufferedSubpixel(int imageCode, vec2 offset)\n{\nivec2 p = ivec2(floor(offset));\nvec2 frc = fract(offset);\nvec2 ifrc = vec2(1.0f) - frc;\nvec4 pix = vec4(\nreadBufferedPixel(imageCode, p),\nreadBufferedPixel(imageCode, p + ivec2(1,0)),\nreadBufferedPixel(imageCode, p + ivec2(0,1)),\nreadBufferedPixel(imageCode, p + ivec2(1,1))\n);\nvec4 sub = vec4(\nifrc.x * ifrc.y,\nfrc.x * ifrc.y,\nifrc.x * frc.y,\nfrc.x * frc.y\n);\nreturn int(0.5f + dot(sub*pix, vec4(1.0f)));\n}\nvec2 computeMismatch(vec2 pyrGuess, vec2 localGuess)\n{\nconst int r = WINDOW_RADIUS;\nint timeDerivative;\nivec2 mismatch = ivec2(0);\nint x, y, _x, _y;\nvec2 d = pyrGuess + localGuess;\n#define innerLoop() \\\nfor(_x = 0; _x < WINDOW_SIZE; _x++) { \\\nx = _x - r; y = _y - r; \\\ntimeDerivative = ( \\\nreadBufferedSubpixel(NEXT_IMAGE, vec2(x, y) + d) - \\\nreadBufferedPixel(PREV_IMAGE, ivec2(x, y)) \\\n); \\\nmismatch += derivativesAt(x, y) * timeDerivative; \\\n}\n@unroll\nfor(_y = 0; _y < WINDOW_SIZE; _y++) {\ninnerLoop();\n}\nreturn vec2(mismatch) * FLT_SCALE;\n}\nbool isInsideImage(vec2 position)\n{\nvec2 imageSize = vec2(textureSize(nextPyramid, 0));\nvec2 border = vec2(WINDOW_SIZE);\nreturn all(bvec4(\ngreaterThanEqual(position, border),\nlessThan(position, imageSize - border)\n));\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedFlow);\nivec2 thread = threadLocation();\nfloat windowArea = float(WINDOW_SIZE * WINDOW_SIZE);\nconst int r = WINDOW_RADIUS;\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(prevKeypoints, encoderLength, address);\ncolor = encodeNullPairOfFloat16();\nif(isNullKeypoint(keypoint))\nreturn;\ncolor = encodeDiscardedPairOfFloat16();\nif(isBadKeypoint(keypoint))\nreturn;\nvec2 pyrGuess = (level < depth - 1) ? decodePairOfFloat16(pixel) : vec2(0.0f);\npyrGuess *= 2.0f;\nreadWindow(keypoint.position, float(level));\nivec2 derivatives;\nivec3 harris3i = ivec3(0);\nfor(int j = 0; j < WINDOW_SIZE; j++) {\nfor(int i = 0; i < WINDOW_SIZE; i++) {\nderivatives = computeDerivatives(PREV_IMAGE, ivec2(i-r, j-r));\nharris3i += ivec3(\nderivatives.x * derivatives.x,\nderivatives.x * derivatives.y,\nderivatives.y * derivatives.y\n);\nderivativesAt(i-r, j-r) = derivatives;\n}\n}\nhighp vec3 harris = vec3(harris3i) * FLT_SCALE;\nhighp mat2 invHarris = mat2(harris.z, -harris.y, -harris.y, harris.x);\nhighp float det = harris.x * harris.z - harris.y * harris.y;\nhighp float invDet = abs(det) >= FLT_EPSILON ? 1.0f / det : 0.0f;\nhighp float minEigenvalue = 0.5f * ((harris.x + harris.z) - sqrt(\n(harris.x - harris.z) * (harris.x - harris.z) + 4.0f * (harris.y * harris.y)\n));\nint niceNumbers = int(abs(det) >= FLT_EPSILON && minEigenvalue >= discardThreshold * windowArea);\nbool goodKeypoint = (level > 0) || (niceNumbers != 0);\nhighp float eps2 = epsilon * epsilon;\nhighp vec2 mismatch, delta, localGuess = vec2(0.0f);\nfor(int k = 0; k < numberOfIterations; k++) {\nmismatch = niceNumbers != 0 ? computeMismatch(pyrGuess, localGuess) : vec2(0.0f);\ndelta = mismatch * invHarris * invDet;\nniceNumbers *= int(eps2 <= dot(delta, delta));\nlocalGuess += float(niceNumbers) * delta;\n}\nvec2 opticalFlow = pyrGuess + localGuess;\nbool mustDiscard = (level == 0) && any(bvec2(\n!goodKeypoint,\n!isInsideImage(keypoint.position + opticalFlow)\n));\ncolor = !mustDiscard ? encodePairOfFloat16(opticalFlow) : encodeDiscardedPairOfFloat16();\n}'},"./src/gpu/shaders/keypoints/lookup-of-locations.glsl":e=>{e.exports='#if @FS_USE_CUSTOM_PRECISION@\nprecision mediump int;\nprecision mediump float;\n#endif\n#if !defined(STAGE)\n#error Undefined STAGE\n#elif STAGE == 1\n@include "float16.glsl"\nuniform sampler2D corners;\n#elif STAGE < 1\nuniform mediump usampler2D lookupTable;\n#else\n#define SKIP_TEXTURE_READS 1\n#define DENSITY_FACTOR 0.10\nuniform mediump usampler2D lookupTable;\nuniform int blockSize;\nuniform int width;\nuniform int height;\nin vec2 v_topLeft, v_top, v_topRight,\nv_left, v_center, v_right,\nv_bottomLeft, v_bottom, v_bottomRight;\n#endif\nconst uvec2 NULL_ELEMENT = uvec2(0xFFFFu);\nvoid main()\n{\n#if STAGE == 1\nuvec2 outSize = uvec2(outputSize());\nuvec2 thread = uvec2(threadLocation());\nuvec2 size = uvec2(textureSize(corners, 0));\nuint location = thread.y * outSize.x + thread.x;\nivec2 pos = ivec2(location % size.x, location / size.x);\nvec4 pixel = location < size.x * size.y ? texelFetch(corners, pos, 0) : vec4(0.0f);\nbool isCorner = !isEncodedFloat16Zero(pixel.rb);\ncolor = isCorner ? uvec4(uvec2(pos), 1u, 0u) : uvec4(NULL_ELEMENT, 0u, 0u);\n#elif STAGE > 1\nint dblBlockSize = 2 * blockSize;\nivec2 thread = threadLocation();\nivec2 offset = thread % dblBlockSize;\nivec2 delta = thread - offset;\n#if SKIP_TEXTURE_READS\nif(blockSize >= 8) {\nuint sb = texture(lookupTable, texCoord).z;\nfloat p = max((float(sb) / float(blockSize)) / float(blockSize), DENSITY_FACTOR);\nfloat rowthr = float(dblBlockSize) * p + 3.0f * sqrt(p * (1.0f - p));\ncolor = uvec4(NULL_ELEMENT, 4u * sb, 0u);\nif(offset.y >= max(1, int(ceil(rowthr))))\nreturn;\n}\n#endif\n#define deltaCenter ivec2(0,0)\n#define deltaTop ivec2(0,-blockSize)\n#define deltaTopRight ivec2(blockSize,-blockSize)\n#define deltaRight ivec2(blockSize,0)\n#define deltaBottomRight ivec2(blockSize,blockSize)\n#define deltaBottom ivec2(0,blockSize)\n#define deltaBottomLeft ivec2(-blockSize,blockSize)\n#define deltaLeft ivec2(-blockSize,0)\n#define deltaTopLeft ivec2(-blockSize,-blockSize)\nivec2 boundary = ivec2(width - 1, height - 1) / blockSize;\nivec2 bottomRightPos = thread + deltaBottomRight;\nuvec2 valid = uvec2(\nbottomRightPos.x < width  || bottomRightPos.x / blockSize == boundary.x,\nbottomRightPos.y < height || bottomRightPos.y / blockSize == boundary.y\n);\nuvec4 mask[4] = uvec4[4](\nuvec4(1u, valid.x, valid.y, valid.x * valid.y),\nuvec4(1u, 1u, valid.y, valid.y),\nuvec4(1u, valid.x, 1u, valid.x),\nuvec4(1u)\n);\n#if SKIP_TEXTURE_READS\n#define calcSb(delta) texelFetch(lookupTable, blockSize * ((thread + (delta)) / blockSize), 0).z\nuint center = calcSb(deltaCenter);\nuint top = calcSb(deltaTop);\nuint topRight = calcSb(deltaTopRight);\nuint right = calcSb(deltaRight);\nuint bottomRight = calcSb(deltaBottomRight);\nuint bottom = calcSb(deltaBottom);\nuint bottomLeft = calcSb(deltaBottomLeft);\nuint left = calcSb(deltaLeft);\nuint topLeft = calcSb(deltaTopLeft);\n#else\n#define calcSb(pos) texture(lookupTable, (pos)).z\nuint center = calcSb(v_center);\nuint top = calcSb(v_top);\nuint topRight = calcSb(v_topRight);\nuint right = calcSb(v_right);\nuint bottomRight = calcSb(v_bottomRight);\nuint bottom = calcSb(v_bottom);\nuint bottomLeft = calcSb(v_bottomLeft);\nuint left = calcSb(v_left);\nuint topLeft = calcSb(v_topLeft);\n#endif\nuvec4 sums[4] = uvec4[4](\nuvec4(center, right, bottom, bottomRight),\nuvec4(left, center, bottomLeft, bottom),\nuvec4(top, topRight, center, right),\nuvec4(topLeft, top, left, center)\n);\nivec2 cmp = ivec2(greaterThanEqual(offset, ivec2(blockSize)));\nint option = 2 * cmp.y + cmp.x;\nuvec4 cdef = sums[option] * mask[option];\nuint c2b = cdef.x, d2b = cdef.y, e2b = cdef.z, f2b = cdef.w;\nuint sb = center;\nuint s2b = c2b + d2b + e2b + f2b;\ns2b = s2b < sb ? 0xFFFFu : min(0xFFFFu, s2b);\nuint w2b = uint(min(dblBlockSize, width - delta.x));\nuvec2 uoffset = uvec2(offset);\nuint ceiling = s2b >= uoffset.x ? (s2b - uoffset.x) / w2b + uint((s2b - uoffset.x) % w2b > 0u) : 0u;\ncolor = uvec4(NULL_ELEMENT, s2b, 0u);\nif(uoffset.y >= ceiling)\nreturn;\nuint i2b = uoffset.y * w2b + uoffset.x;\nuint j2b = i2b >= c2b ? i2b - c2b : 0u;\nuint k2b = j2b >= d2b ? j2b - d2b : 0u;\nuint l2b = k2b >= e2b ? k2b - e2b : 0u;\nuint wl = uint(min(blockSize, width - delta.x));\nuint wr = uint(min(blockSize, width - delta.x - blockSize));\nivec2 magicOffset = (\n(i2b < c2b) ? ivec2(i2b % wl, i2b / wl) : (\n(j2b < d2b) ? ivec2(j2b % wr, j2b / wr) + ivec2(blockSize, 0) : (\n(k2b < e2b) ? ivec2(k2b % wl, k2b / wl) + ivec2(0, blockSize) : (\n(l2b < f2b) ? ivec2(l2b % wr, l2b / wr) + ivec2(blockSize) : ivec2(0)\n))));\nuvec2 a2b = texelFetch(lookupTable, delta + magicOffset, 0).xy;\ncolor = uvec4(a2b, s2b, 0u);\n#else\nuvec4 pix = texture(lookupTable, texCoord);\ncolor = all(equal(pix.xy, NULL_ELEMENT)) ? vec4(0,1,1,1) : vec4(1,0,0,1);\n#endif\n}'},"./src/gpu/shaders/keypoints/lookup-of-locations.vs.glsl":e=>{e.exports="#if !defined(STAGE) || STAGE < 1\n#error Invalid STAGE\n#else\nuniform mediump int blockSize;\nout vec2 v_topLeft, v_top, v_topRight,\nv_left, v_center, v_right,\nv_bottomLeft, v_bottom, v_bottomRight;\nvoid vsmain()\n{\nfloat b = float(blockSize);\n#define V(x,y) (texCoord + (vec2((x),(y)) * b) / texSize)\nv_topLeft = V(-1,-1); v_top = V(0,-1); v_topRight = V(1,-1);\nv_left = V(-1,0); v_center = V(0,0); v_right = V(1,0);\nv_bottomLeft = V(-1,1); v_bottom = V(0,1); v_bottomRight = V(1,1);\n}\n#endif"},"./src/gpu/shaders/keypoints/lsh-knn.glsl":e=>{e.exports='@include "keypoints.glsl"\n@include "keypoint-matches.glsl"\n@include "keypoint-descriptors.glsl"\nuniform sampler2D candidates;\nuniform sampler2D filters;\nuniform int matcherLength;\nuniform sampler2D tables;\nuniform sampler2D descriptorDB;\nuniform int tableIndex;\nuniform int bucketCapacity;\nuniform int bucketsPerTable;\nuniform int tablesStride;\nuniform int descriptorDBStride;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#if HASH_SIZE > SEQUENCE_MAXLEN\n#error LSH: invalid HASH_SIZE\n#elif SEQUENCE_COUNT * SEQUENCE_MAXLEN * 4 > 16384\n#error LSH: sequences are too large!\n#elif (SEQUENCE_COUNT * SEQUENCE_MAXLEN) % 4 > 0\n#error LSH: sequences of invalid size!\n#endif\nlayout(std140) uniform LSHSequences\n{\nuvec4 sequences[(SEQUENCE_COUNT * SEQUENCE_MAXLEN) / 4];\n};\n#if HASH_SIZE == 10\nconst int SWAP_COUNT[3] = int[3](1, 11, 56);\nconst int[56] SWAP = int[56](0,1,2,4,8,16,32,64,128,256,512,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768);\n#elif HASH_SIZE == 11\nconst int SWAP_COUNT[3] = int[3](1, 12, 67);\nconst int[67] SWAP = int[67](0,1,2,4,8,16,32,64,128,256,512,1024,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536);\n#elif HASH_SIZE == 12\nconst int SWAP_COUNT[3] = int[3](1, 13, 79);\nconst int[79] SWAP = int[79](0,1,2,4,8,16,32,64,128,256,512,1024,2048,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072);\n#elif HASH_SIZE == 13\nconst int SWAP_COUNT[3] = int[3](1, 14, 92);\nconst int[92] SWAP = int[92](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144);\n#elif HASH_SIZE == 14\nconst int SWAP_COUNT[3] = int[3](1, 15, 106);\nconst int[106] SWAP = int[106](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288);\n#elif HASH_SIZE == 15\nconst int SWAP_COUNT[3] = int[3](1, 16, 121);\nconst int[121] SWAP = int[121](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576);\n#elif HASH_SIZE == 16\nconst int SWAP_COUNT[3] = int[3](1, 17, 137);\nconst int[137] SWAP = int[137](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152);\n#elif HASH_SIZE == 17\nconst int SWAP_COUNT[3] = int[3](1, 18, 154);\nconst int[154] SWAP = int[154](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304);\n#elif HASH_SIZE == 18\nconst int SWAP_COUNT[3] = int[3](1, 19, 172);\nconst int[172] SWAP = int[172](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608);\n#elif HASH_SIZE == 19\nconst int SWAP_COUNT[3] = int[3](1, 20, 191);\nconst int[191] SWAP = int[191](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608,262145,262146,262148,262152,262160,262176,262208,262272,262400,262656,263168,264192,266240,270336,278528,294912,327680,393216);\n#elif HASH_SIZE == 20\nconst int SWAP_COUNT[3] = int[3](1, 21, 211);\nconst int[211] SWAP = int[211](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608,262145,262146,262148,262152,262160,262176,262208,262272,262400,262656,263168,264192,266240,270336,278528,294912,327680,393216,524289,524290,524292,524296,524304,524320,524352,524416,524544,524800,525312,526336,528384,532480,540672,557056,589824,655360,786432);\n#else\n#error Invalid HASH_SIZE\n#endif\n#if LEVEL < 0 || LEVEL > 2\n#error Invalid LEVEL\n#endif\nconst uint END_OF_LIST = 0xFFFFFFFFu;\nconst int NUMBER_OF_HASHES = SWAP_COUNT[LEVEL];\nuint sequenceElement(int sequenceIndex, int elementIndex)\n{\nint offset = (SEQUENCE_MAXLEN) * sequenceIndex + elementIndex;\nuvec4 tuple = sequences[offset / 4];\nreturn tuple[offset & 3];\n}\nint descriptorHash(uint[DESCRIPTOR_SIZE] descriptor, int sequenceIndex)\n{\nuint bit, b, m;\nint hash = 0;\n@unroll\nfor(int i = 0; i < HASH_SIZE; i++) {\nbit = sequenceElement(sequenceIndex, i);\nb = bit >> 3u;\nm = 1u << (bit & 7u);\nhash = (hash << 1) | int((descriptor[b] & m) != 0u);\n}\nreturn hash;\n}\n#define readTableData(tables, tablesStride, rasterIndex) decodeUint32(texelFetch((tables), ivec2((rasterIndex) % (tablesStride), (rasterIndex) / (tablesStride)), 0))\nvoid main()\n{\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * matcherLength;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\ncolor = encodeKeypointMatch(MATCH_NOT_FOUND);\nif(isBadKeypoint(keypoint))\nreturn;\nKeypointMatch candidate = decodeKeypointMatch(threadPixel(candidates));\nKeypointMatch mfilter = decodeKeypointMatch(threadPixel(filters));\nuint[DESCRIPTOR_SIZE] candidateDescriptor;\nuint[DESCRIPTOR_SIZE] descriptor = readKeypointDescriptor(encodedKeypoints, descriptorSize, extraSize, encoderLength, address);\nint hash0 = descriptorHash(descriptor, tableIndex);\nfor(int h = 0; h < NUMBER_OF_HASHES; h++) {\nint hash = hash0 ^ SWAP[h];\nint tableAddress = tableIndex * bucketsPerTable * bucketCapacity;\nint bucketAddress = tableAddress + hash * bucketCapacity;\nbool validEntry = true;\nfor(int b = 0; b < bucketCapacity; b++) {\nint entryAddress = bucketAddress + b;\nuint entry = validEntry ? readTableData(tables, tablesStride, entryAddress) : END_OF_LIST;\nvalidEntry = (validEntry && entry != END_OF_LIST);\nint candidateIndex = int(entry);\ncandidateDescriptor = readKeypointDescriptorFromDB(descriptorDB, descriptorDBStride, validEntry ? candidateIndex : -1);\nint descriptorDistance = distanceBetweenKeypointDescriptors(descriptor, candidateDescriptor);\nKeypointMatch match = KeypointMatch(candidateIndex, descriptorDistance);\nbool betterThanCandidate = (match.dist < candidate.dist) || (match.dist == candidate.dist && match.index > candidate.index);\nbool worseThanFilter = (match.dist > mfilter.dist) || (match.dist == mfilter.dist && match.index < mfilter.index);\nbool nicerMatch = (validEntry && betterThanCandidate && worseThanFilter);\nivec2 v = nicerMatch ? ivec2(match.index, match.dist) : ivec2(candidate.index, candidate.dist);\ncandidate = KeypointMatch(v.x, v.y);\n}\n}\ncolor = encodeKeypointMatch(candidate);\n}'},"./src/gpu/shaders/keypoints/mix-keypoints.glsl":e=>{e.exports='@include "keypoints.glsl"\n@include "int32.glsl"\n#if !defined(STAGE)\n#error Undefined STAGE\n#elif STAGE == 1\nuniform sampler2D encodedKeypointsA;\nuniform sampler2D encodedKeypointsB;\nuniform int encoderLengthA;\nuniform int encoderLengthB;\nuniform int encoderCapacityA;\nuniform int encoderCapacityB;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#elif STAGE == 2\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int maxKeypoints;\n#elif STAGE == 3\nuniform sampler2D array;\nuniform int blockSize;\n#elif STAGE == 4\nuniform sampler2D array;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#elif STAGE == 5\nuniform sampler2D array;\n#else\n#error Invalid STAGE\n#endif\n#define NULL_KEYPOINT_INDEX 0xFFFF\nconst highp uint UNIT = 0x10000u;\nvoid main()\n{\n#if STAGE == 1\nivec2 thread = threadLocation();\nKeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint keypointIndex = findKeypointIndex(addr, descriptorSize, extraSize);\nint newKeypointIndex = keypointIndex < encoderCapacityA ? keypointIndex : keypointIndex - encoderCapacityA;\ncolor = encodeNullKeypoint();\nif(newKeypointIndex >= max(encoderCapacityA, encoderCapacityB))\nreturn;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\naddr = KeypointAddress(newKeypointIndex * pixelsPerKeypoint, addr.offset);\nvec4 dataA = readKeypointData(encodedKeypointsA, encoderLengthA, addr);\nvec4 dataB = readKeypointData(encodedKeypointsB, encoderLengthB, addr);\ncolor = keypointIndex < encoderCapacityA ? dataA : dataB;\n#elif STAGE == 2\nivec2 thread = threadLocation();\nint keypointIndex = thread.y * outputSize().x + thread.x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress addr = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, addr);\nbool isValid = !isNullKeypoint(keypoint) && keypointIndex < maxKeypoints;\nkeypointIndex = isValid ? keypointIndex : NULL_KEYPOINT_INDEX;\ncolor = encodeUint32(uint(keypointIndex & 0xFFFF) | (isValid ? UNIT : 0u));\n#elif STAGE == 3\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nint arrayLength = size.x * size.y;\nint arrayIndex = thread.y * size.x + thread.x;\nint arrayIndexLeft = arrayIndex - blockSize;\nint arrayIndexRight = arrayIndex + blockSize;\nint mask = int(arrayIndexRight < arrayLength || arrayIndexRight / blockSize == (arrayLength - 1) / blockSize);\narrayIndexLeft = max(0, arrayIndexLeft);\narrayIndexRight = min(arrayLength - 1, arrayIndexRight);\n#define raster2pos(k) ivec2((k) % size.x, (k) / size.x)\nuvec3 entries32 = uvec3(\ndecodeUint32(threadPixel(array)),\ndecodeUint32(texelFetch(array, raster2pos(arrayIndexLeft), 0)),\ndecodeUint32(texelFetch(array, raster2pos(arrayIndexRight), 0))\n);\nivec3 sb = ivec3((entries32 >> 16u) & 0xFFFFu);\nsb.z *= mask;\nint dblBlockSize = 2 * blockSize;\nint offset = arrayIndex % dblBlockSize;\nint s2b = sb.x + (offset < blockSize ? sb.z : sb.y);\nint l2b = offset < blockSize ? sb.x : sb.y;\nuint keypointIndex = entries32.x & 0xFFFFu;\nuint shiftedS2b = uint(s2b) << 16u;\ncolor = encodeUint32(uint(NULL_KEYPOINT_INDEX) | shiftedS2b);\nif(offset >= s2b)\nreturn;\ncolor = encodeUint32(keypointIndex | shiftedS2b);\nif(offset < l2b)\nreturn;\nvec4 entry = texelFetch(array, raster2pos(arrayIndex + blockSize - l2b), 0);\nkeypointIndex = decodeUint32(entry) & 0xFFFFu;\ncolor = encodeUint32(keypointIndex | shiftedS2b);\n#elif STAGE == 4\nivec2 thread = threadLocation();\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint keypointIndex = findKeypointIndex(addr, descriptorSize, extraSize);\n#define raster2pos(k) ivec2((k) % size.x, (k) / size.x)\nivec2 size = textureSize(array, 0);\nuint sortedPair = decodeUint32(texelFetch(array, raster2pos(keypointIndex), 0));\nint newKeypointIndex = int(sortedPair & 0xFFFFu);\ncolor = encodeNullKeypoint();\nif(newKeypointIndex == NULL_KEYPOINT_INDEX || keypointIndex >= size.x * size.y)\nreturn;\nKeypointAddress newAddr = KeypointAddress(newKeypointIndex * pixelsPerKeypoint, addr.offset);\ncolor = readKeypointData(encodedKeypoints, encoderLength, newAddr);\n#elif STAGE == 5\nuint val = decodeUint32(threadPixel(array));\ncolor = (val & 0xFFFFu) == uint(NULL_KEYPOINT_INDEX) ? vec4(0,1,1,1) : vec4(1,0,0,1);\n#endif\n}'},"./src/gpu/shaders/keypoints/nonmax-scale.glsl":e=>{e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\n@include "filters.glsl"\n#if !defined(USE_LAPLACIAN)\n#error Undefined USE_LAPLACIAN\n#endif\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform float lodStep;\n#if USE_LAPLACIAN\nuniform sampler2D pyrLaplacian;\n#endif\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(corners);\nfloat score = decodeFloat16(pixel.rb);\nfloat myEncodedLod = pixel.a;\nfloat lod = decodeLod(myEncodedLod);\nfloat lodPlus = lod + lodStep;\nfloat lodMinus = lod - lodStep;\nfloat pot = exp2(lod);\nfloat potPlus = exp2(lodPlus);\nfloat potMinus = exp2(lodMinus);\ncolor = pixel;\nif(score == 0.0f)\nreturn;\n#define P(p,u,v) textureLod(corners, texCoord + (p) * vec2((u),(v)) / texSize, 0.0f)\nvec4 pix[18] = vec4[18](\n#define D(u,v) P(potMinus,(u),(v))\nD(-1,-1), D(0,-1), D(1,-1),\nD(-1,0), D(0,0), D(1,0),\nD(-1,1), D(0,1), D(1,1)\n,\n#define U(u,v) P(potPlus,(u),(v))\nU(-1,-1), U(0,-1), U(1,-1),\nU(-1,0), U(0,0), U(1,0),\nU(-1,1), U(0,1), U(1,1)\n);\nfloat scores[18] = float[18](\n#define C(j) decodeFloat16(pix[j].rb)\nC(0), C(1), C(2),\nC(3), C(4), C(5),\nC(6), C(7), C(8)\n,\nC(9), C(10), C(11),\nC(12), C(13), C(14),\nC(15), C(16), C(17)\n);\nfloat lods[18] = float[18](\n#define E(j) decodeLod(pix[j].a)\nE(0), E(1), E(2),\nE(3), E(4), E(5),\nE(6), E(7), E(8)\n,\nE(9), E(10), E(11),\nE(12), E(13), E(14),\nE(15), E(16), E(17)\n);\n#if USE_LAPLACIAN\n#define L(p,u,v) textureLod(pyrLaplacian, texCoord + (p) * vec2((u),(v)) / texSize, 0.0f)\nmat3 strengths[2] = mat3[2](mat3(\n#define Lm(u,v) abs(decodeFloat16(L(potMinus,(u),(v)).xy))\nLm(-1,-1), Lm(0,-1), Lm(1,-1),\nLm(-1,0), Lm(0,0), Lm(1,0),\nLm(-1,1), Lm(0,1), Lm(1,1)\n), mat3(\n#define Lp(u,v) abs(decodeFloat16(L(potPlus,(u),(v)).zw))\nLp(-1,-1), Lp(0,-1), Lp(1,-1),\nLp(-1,0), Lp(0,0), Lp(1,0),\nLp(-1,1), Lp(0,1), Lp(1,1)\n));\nfloat myStrength = abs(laplacian(pyramid, vec2(thread), lod));\n#else\n#define L(u,v) (((v)+1)*3 + ((u)+1))\nmat3 strengths[2] = mat3[2](mat3(\n#define Lm(u,v) scores[L((u),(v))]\nLm(-1,-1), Lm(0,-1), Lm(1,-1),\nLm(-1,0), Lm(0,0), Lm(1,0),\nLm(-1,1), Lm(0,1), Lm(1,1)\n), mat3(\n#define Lp(u,v) scores[9 + L((u),(v))]\nLp(-1,-1), Lp(0,-1), Lp(1,-1),\nLp(-1,0), Lp(0,0), Lp(1,0),\nLp(-1,1), Lp(0,1), Lp(1,1)\n));\nfloat myStrength = score;\n#endif\n#define B(j,lod) float(isSameLod(lods[j], (lod))) * float(scores[j] > 0.0f)\nmat3 nearLod[2] = mat3[2](mat3(\n#define Bm(j) B((j), lodMinus)\nBm(0), Bm(1), Bm(2),\nBm(3), Bm(4), Bm(5),\nBm(6), Bm(7), Bm(8)\n), mat3(\n#define Bp(j) B((j), lodPlus)\nBp(9), Bp(10), Bp(11),\nBp(12), Bp(13), Bp(14),\nBp(15), Bp(16), Bp(17)\n));\nmat3 upStrengths = matrixCompMult(strengths[1], nearLod[1]);\nmat3 downStrengths = matrixCompMult(strengths[0], nearLod[0]);\nvec3 maxUpStrength3 = max(upStrengths[0], max(upStrengths[1], upStrengths[2]));\nvec3 maxDownStrength3 = max(downStrengths[0], max(downStrengths[1], downStrengths[2]));\nvec3 maxStrength3 = max(maxUpStrength3, maxDownStrength3);\nfloat maxStrength = max(maxStrength3.x, max(maxStrength3.y, maxStrength3.z));\ncolor.rb = encodeFloat16(score * step(maxStrength, myStrength));\n}'},"./src/gpu/shaders/keypoints/nonmax-space.glsl":e=>{e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D corners;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(corners);\nfloat encodedLod = pixel.a;\nfloat score = decodeFloat16(pixel.rb);\nfloat lod = decodeLod(encodedLod);\nfloat pot = exp2(lod);\ncolor = pixel;\nif(score == 0.0f)\nreturn;\n#if 1\nvec2 gridSize = vec2(pot);\nvec2 gridLocation = floor(mod(texCoord * texSize, gridSize));\nvec2 gridDelta = gridLocation / gridSize - vec2(0.5f);\nfloat gridStep = 1.0f / pot;\nconst float adjustment = 1.25f;\ncolor.rb = encodeFloat16(0.0f);\nif(max(abs(gridDelta.x), abs(gridDelta.y)) > adjustment * gridStep)\nreturn;\n#endif\n#define P(x,y) textureLod(corners, texCoord + pot * vec2((x), (y)) / texSize, 0.0f)\nvec4 pix[9] = vec4[9](\nP(-1,-1), P(0,-1), P(1,-1),\nP(-1,0), pixel, P(1,0),\nP(-1,1), P(0,1), P(1,1)\n);\n#define S(j) decodeFloat16(pix[j].rb)\nmat3 scores = mat3(\nS(0), S(1), S(2),\nS(3), S(4), S(5),\nS(6), S(7), S(8)\n);\n#define B(j) float(isSameLod(decodeLod(pix[j].a), lod))\nmat3 sameLod = mat3(\nB(0), B(1), B(2),\nB(3), B(4), B(5),\nB(6), B(7), B(8)\n);\nmat3 sameLodScores = matrixCompMult(scores, sameLod);\nvec3 maxScore3 = max(sameLodScores[0], max(sameLodScores[1], sameLodScores[2]));\nfloat maxScore = max(maxScore3.x, max(maxScore3.y, maxScore3.z));\ncolor.rb = encodeFloat16(score * step(maxScore, score));\n}'},"./src/gpu/shaders/keypoints/nonmax-suppression.glsl":e=>{e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D image;\nuniform float lodStep;\n#if !defined(MULTISCALE)\n#error Must define MULTISCALE\n#elif MULTISCALE != 0\n#define LOD_STEP (lodStep)\n#define USE_MIDDLE_RING\n#else\n#define LOD_STEP (0.0f)\n#endif\n#define PIX(x,y) pixelAtShortOffset(image, ivec2((x),(y)))\n#define L2(v,i) bvec2(isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))\n#define L3(v,i) bvec3(isSameEncodedLod(v[i].a, alpha), isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))\n#define S3(v,i) decodeFloat16(v[i].rb) * float(any(L3(v,i)))\n#define S2(v,i) decodeFloat16(v[i].rb) * float(any(L2(v,i)))\n#define P(i) S3(p,i)\n#define Q(i) S2(q,i)\n#define R(i) S2(r,i)\nconst vec4 O = vec4(0.0f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat lod = decodeLod(pixel.a);\nfloat score = decodeFloat16(pixel.rb);\ncolor = pixel;\nif(score == 0.0f)\nreturn;\nvec4 p[8] = vec4[8](\nPIX(0,1), PIX(1,1), PIX(1,0), PIX(1,-1),\nPIX(0,-1), PIX(-1,-1), PIX(-1,0), PIX(-1,1)\n);\n#ifdef USE_MIDDLE_RING\nvec4 q[16] = vec4[16](\nPIX(0,2), PIX(1,2), PIX(2,2), PIX(2,1),\nPIX(2,0), PIX(2,-1), PIX(2,-2), PIX(1,-2),\nPIX(0,-2), PIX(-1,-2), PIX(-2,-2), PIX(-2,-1),\nPIX(-2,0), PIX(-2,1), PIX(-2,2), PIX(-1,2)\n);\n#else\nvec4 q[16] = vec4[16](O,O,O,O,O,O,O,O,O,O,O,O,O,O,O,O);\n#endif\n#ifdef USE_OUTER_RING\nvec4 r[16] = vec4[16](\nPIX(0,3), PIX(1,3), PIX(3,1), PIX(3,0),\nPIX(3,-1), PIX(1,-3), PIX(0,-3), PIX(-1,-3),\nPIX(-3,-1), PIX(-3,0), PIX(-3,1), PIX(-1,3),\nPIX(0,4), PIX(4,0), PIX(0,-4), PIX(-4,0)\n);\n#else\nvec4 r[16] = vec4[16](O,O,O,O,O,O,O,O,O,O,O,O,O,O,O,O);\n#endif\nfloat alphaPlus = encodeLod(lod + LOD_STEP);\nfloat alphaMinus = encodeLod(lod - LOD_STEP);\nfloat alpha = encodeLod(lod);\nmat3 innerScore = mat3(\nP(0), P(1), P(2), P(3),\nP(4), P(5), P(6), P(7),\n0.0f);\nmat4 middleScore = mat4(\nQ(0), Q(1), Q(2), Q(3),\nQ(4), Q(5), Q(6), Q(7),\nQ(8), Q(9), Q(10), Q(11),\nQ(12), Q(13), Q(14), Q(15)\n);\nmat4 outerScore = mat4(\nR(0), R(1), R(2), R(3),\nR(4), R(5), R(6), R(7),\nR(8), R(9), R(10), R(11),\nR(12), R(13), R(14), R(15)\n);\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\nfloat finalScore = step(maxScore, score) * score;\ncolor.rb = encodeFloat16(finalScore);\n}'},"./src/gpu/shaders/keypoints/orb-descriptor.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedCorners;\nuniform int encoderLength;\nuniform sampler2D image;\nuniform int extraSize;\nconst int descriptorSize = 32;\n#define P(a,b,c,d) ivec4((a),(b),(c),(d))\nconst ivec4 pat31[256] = ivec4[256](\nP(8,-3,9,5),\nP(4,2,7,-12),\nP(-11,9,-8,2),\nP(7,-12,12,-13),\nP(2,-13,2,12),\nP(1,-7,1,6),\nP(-2,-10,-2,-4),\nP(-13,-13,-11,-8),\nP(-13,-3,-12,-9),\nP(10,4,11,9),\nP(-13,-8,-8,-9),\nP(-11,7,-9,12),\nP(7,7,12,6),\nP(-4,-5,-3,0),\nP(-13,2,-12,-3),\nP(-9,0,-7,5),\nP(12,-6,12,-1),\nP(-3,6,-2,12),\nP(-6,-13,-4,-8),\nP(11,-13,12,-8),\nP(4,7,5,1),\nP(5,-3,10,-3),\nP(3,-7,6,12),\nP(-8,-7,-6,-2),\nP(-2,11,-1,-10),\nP(-13,12,-8,10),\nP(-7,3,-5,-3),\nP(-4,2,-3,7),\nP(-10,-12,-6,11),\nP(5,-12,6,-7),\nP(5,-6,7,-1),\nP(1,0,4,-5),\nP(9,11,11,-13),\nP(4,7,4,12),\nP(2,-1,4,4),\nP(-4,-12,-2,7),\nP(-8,-5,-7,-10),\nP(4,11,9,12),\nP(0,-8,1,-13),\nP(-13,-2,-8,2),\nP(-3,-2,-2,3),\nP(-6,9,-4,-9),\nP(8,12,10,7),\nP(0,9,1,3),\nP(7,-5,11,-10),\nP(-13,-6,-11,0),\nP(10,7,12,1),\nP(-6,-3,-6,12),\nP(10,-9,12,-4),\nP(-13,8,-8,-12),\nP(-13,0,-8,-4),\nP(3,3,7,8),\nP(5,7,10,-7),\nP(-1,7,1,-12),\nP(3,-10,5,6),\nP(2,-4,3,-10),\nP(-13,0,-13,5),\nP(-13,-7,-12,12),\nP(-13,3,-11,8),\nP(-7,12,-4,7),\nP(6,-10,12,8),\nP(-9,-1,-7,-6),\nP(-2,-5,0,12),\nP(-12,5,-7,5),\nP(3,-10,8,-13),\nP(-7,-7,-4,5),\nP(-3,-2,-1,-7),\nP(2,9,5,-11),\nP(-11,-13,-5,-13),\nP(-1,6,0,-1),\nP(5,-3,5,2),\nP(-4,-13,-4,12),\nP(-9,-6,-9,6),\nP(-12,-10,-8,-4),\nP(10,2,12,-3),\nP(7,12,12,12),\nP(-7,-13,-6,5),\nP(-4,9,-3,4),\nP(7,-1,12,2),\nP(-7,6,-5,1),\nP(-13,11,-12,5),\nP(-3,7,-2,-6),\nP(7,-8,12,-7),\nP(-13,-7,-11,-12),\nP(1,-3,12,12),\nP(2,-6,3,0),\nP(-4,3,-2,-13),\nP(-1,-13,1,9),\nP(7,1,8,-6),\nP(1,-1,3,12),\nP(9,1,12,6),\nP(-1,-9,-1,3),\nP(-13,-13,-10,5),\nP(7,7,10,12),\nP(12,-5,12,9),\nP(6,3,7,11),\nP(5,-13,6,10),\nP(2,-12,2,3),\nP(3,8,4,-6),\nP(2,6,12,-13),\nP(9,-12,10,3),\nP(-8,4,-7,9),\nP(-11,12,-4,-6),\nP(1,12,2,-8),\nP(6,-9,7,-4),\nP(2,3,3,-2),\nP(6,3,11,0),\nP(3,-3,8,-8),\nP(7,8,9,3),\nP(-11,-5,-6,-4),\nP(-10,11,-5,10),\nP(-5,-8,-3,12),\nP(-10,5,-9,0),\nP(8,-1,12,-6),\nP(4,-6,6,-11),\nP(-10,12,-8,7),\nP(4,-2,6,7),\nP(-2,0,-2,12),\nP(-5,-8,-5,2),\nP(7,-6,10,12),\nP(-9,-13,-8,-8),\nP(-5,-13,-5,-2),\nP(8,-8,9,-13),\nP(-9,-11,-9,0),\nP(1,-8,1,-2),\nP(7,-4,9,1),\nP(-2,1,-1,-4),\nP(11,-6,12,-11),\nP(-12,-9,-6,4),\nP(3,7,7,12),\nP(5,5,10,8),\nP(0,-4,2,8),\nP(-9,12,-5,-13),\nP(0,7,2,12),\nP(-1,2,1,7),\nP(5,11,7,-9),\nP(3,5,6,-8),\nP(-13,-4,-8,9),\nP(-5,9,-3,-3),\nP(-4,-7,-3,-12),\nP(6,5,8,0),\nP(-7,6,-6,12),\nP(-13,6,-5,-2),\nP(1,-10,3,10),\nP(4,1,8,-4),\nP(-2,-2,2,-13),\nP(2,-12,12,12),\nP(-2,-13,0,-6),\nP(4,1,9,3),\nP(-6,-10,-3,-5),\nP(-3,-13,-1,1),\nP(7,5,12,-11),\nP(4,-2,5,-7),\nP(-13,9,-9,-5),\nP(7,1,8,6),\nP(7,-8,7,6),\nP(-7,-4,-7,1),\nP(-8,11,-7,-8),\nP(-13,6,-12,-8),\nP(2,4,3,9),\nP(10,-5,12,3),\nP(-6,-5,-6,7),\nP(8,-3,9,-8),\nP(2,-12,2,8),\nP(-11,-2,-10,3),\nP(-12,-13,-7,-9),\nP(-11,0,-10,-5),\nP(5,-3,11,8),\nP(-2,-13,-1,12),\nP(-1,-8,0,9),\nP(-13,-11,-12,-5),\nP(-10,-2,-10,11),\nP(-3,9,-2,-13),\nP(2,-3,3,2),\nP(-9,-13,-4,0),\nP(-4,6,-3,-10),\nP(-4,12,-2,-7),\nP(-6,-11,-4,9),\nP(6,-3,6,11),\nP(-13,11,-5,5),\nP(11,11,12,6),\nP(7,-5,12,-2),\nP(-1,12,0,7),\nP(-4,-8,-3,-2),\nP(-7,1,-6,7),\nP(-13,-12,-8,-13),\nP(-7,-2,-6,-8),\nP(-8,5,-6,-9),\nP(-5,-1,-4,5),\nP(-13,7,-8,10),\nP(1,5,5,-13),\nP(1,0,10,-13),\nP(9,12,10,-1),\nP(5,-8,10,-9),\nP(-1,11,1,-13),\nP(-9,-3,-6,2),\nP(-1,-10,1,12),\nP(-13,1,-8,-10),\nP(8,-11,10,-6),\nP(2,-13,3,-6),\nP(7,-13,12,-9),\nP(-10,-10,-5,-7),\nP(-10,-8,-8,-13),\nP(4,-6,8,5),\nP(3,12,8,-13),\nP(-4,2,-3,-3),\nP(5,-13,10,-12),\nP(4,-13,5,-1),\nP(-9,9,-4,3),\nP(0,3,3,-9),\nP(-12,1,-6,1),\nP(3,2,4,-8),\nP(-10,-10,-10,9),\nP(8,-13,12,12),\nP(-8,-12,-6,-5),\nP(2,2,3,7),\nP(10,6,11,-8),\nP(6,8,8,-12),\nP(-7,10,-6,5),\nP(-3,-9,-3,9),\nP(-1,-13,-1,5),\nP(-3,-7,-3,4),\nP(-8,-2,-8,3),\nP(4,2,12,12),\nP(2,-5,3,11),\nP(6,-9,11,-13),\nP(3,-1,7,12),\nP(11,-1,12,4),\nP(-3,0,-3,6),\nP(4,-11,4,12),\nP(2,-4,2,1),\nP(-10,-6,-8,1),\nP(-13,7,-11,1),\nP(-13,12,-11,-13),\nP(6,0,11,-13),\nP(0,-1,1,4),\nP(-13,3,-9,-2),\nP(-9,8,-6,-3),\nP(-13,-6,-8,-2),\nP(5,-9,8,10),\nP(2,7,3,-9),\nP(-1,-6,-1,-1),\nP(9,5,11,-2),\nP(11,-3,12,-8),\nP(3,0,3,5),\nP(-1,4,0,10),\nP(3,-6,4,5),\nP(-13,0,-10,5),\nP(5,8,12,11),\nP(8,9,9,-6),\nP(7,-4,8,-12),\nP(-10,4,-10,9),\nP(7,3,12,4),\nP(9,-7,10,-2),\nP(7,0,12,-2),\nP(-1,-6,0,-11)\n);\nvoid getPair(int index, mat2 rot, out vec2 p, out vec2 q)\n{\nivec4 data = pat31[index];\nvec2 op = vec2(data.xy);\nvec2 oq = vec2(data.zw);\np = rot * op;\nq = rot * oq;\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedCorners);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint descriptorCell = address.offset - sizeofEncodedKeypoint(0, extraSize) / 4;\ncolor = pixel;\nif(descriptorCell < 0)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedCorners, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nfloat degreesOrientation = round(360.0f + degrees(keypoint.orientation));\nfloat orientation = radians(degreesOrientation - mod(degreesOrientation, 12.0f));\nfloat kcos = cos(orientation);\nfloat ksin = sin(orientation);\nmat2 rot = mat2(kcos, ksin, -ksin, kcos);\nfloat pot = exp2(keypoint.lod);\nint patternStart = 32 * descriptorCell;\nuint test[4] = uint[4](0u, 0u, 0u, 0u);\nfor(int t = 0; t < 4; t++) {\nuint bits = 0u;\nvec2 p, q;\nvec4 a, b;\nint i = t * 8;\n@unroll\nfor(int j = 0; j < 8; j++) {\ngetPair(patternStart + i + j, rot, p, q);\na = texelFetch(image, ivec2(round(keypoint.position + pot * p)), 0);\nb = texelFetch(image, ivec2(round(keypoint.position + pot * q)), 0);\nbits |= uint(a.g < b.g) << j;\n}\ntest[t] = bits;\n}\ncolor = vec4(test[0], test[1], test[2], test[3]) / 255.0f;\n}'},"./src/gpu/shaders/keypoints/orb-orientation.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D image;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#define P(x,y) ivec2((x),(y))\nconst int diskPointCount[16] = int[16](0, 4, 12, 28, 48, 80, 112, 148, 196, 252, 316, 376, 440, 528, 612, 708);\nconst ivec2 diskPoint[708] = ivec2[708](\nP(0,-1),P(-1,0),P(1,0),P(0,1),\nP(-1,-1),P(1,-1),P(-1,1),P(1,1),P(0,-2),P(-2,0),P(2,0),P(0,2),\nP(-1,-2),P(1,-2),P(-2,-1),P(2,-1),P(-2,1),P(2,1),P(-1,2),P(1,2),P(-2,-2),P(2,-2),P(-2,2),P(2,2),P(0,-3),P(-3,0),P(3,0),P(0,3),\nP(-1,-3),P(1,-3),P(-3,-1),P(3,-1),P(-3,1),P(3,1),P(-1,3),P(1,3),P(-2,-3),P(2,-3),P(-3,-2),P(3,-2),P(-3,2),P(3,2),P(-2,3),P(2,3),P(0,-4),P(-4,0),P(4,0),P(0,4),\nP(-1,-4),P(1,-4),P(-4,-1),P(4,-1),P(-4,1),P(4,1),P(-1,4),P(1,4),P(-3,-3),P(3,-3),P(-3,3),P(3,3),P(-2,-4),P(2,-4),P(-4,-2),P(4,-2),P(-4,2),P(4,2),P(-2,4),P(2,4),P(0,-5),P(-3,-4),P(3,-4),P(-4,-3),P(4,-3),P(-5,0),P(5,0),P(-4,3),P(4,3),P(-3,4),P(3,4),P(0,5),\nP(-1,-5),P(1,-5),P(-5,-1),P(5,-1),P(-5,1),P(5,1),P(-1,5),P(1,5),P(-2,-5),P(2,-5),P(-5,-2),P(5,-2),P(-5,2),P(5,2),P(-2,5),P(2,5),P(-4,-4),P(4,-4),P(-4,4),P(4,4),P(-3,-5),P(3,-5),P(-5,-3),P(5,-3),P(-5,3),P(5,3),P(-3,5),P(3,5),P(0,-6),P(-6,0),P(6,0),P(0,6),\nP(-1,-6),P(1,-6),P(-6,-1),P(6,-1),P(-6,1),P(6,1),P(-1,6),P(1,6),P(-2,-6),P(2,-6),P(-6,-2),P(6,-2),P(-6,2),P(6,2),P(-2,6),P(2,6),P(-4,-5),P(4,-5),P(-5,-4),P(5,-4),P(-5,4),P(5,4),P(-4,5),P(4,5),P(-3,-6),P(3,-6),P(-6,-3),P(6,-3),P(-6,3),P(6,3),P(-3,6),P(3,6),P(0,-7),P(-7,0),P(7,0),P(0,7),\nP(-1,-7),P(1,-7),P(-5,-5),P(5,-5),P(-7,-1),P(7,-1),P(-7,1),P(7,1),P(-5,5),P(5,5),P(-1,7),P(1,7),P(-4,-6),P(4,-6),P(-6,-4),P(6,-4),P(-6,4),P(6,4),P(-4,6),P(4,6),P(-2,-7),P(2,-7),P(-7,-2),P(7,-2),P(-7,2),P(7,2),P(-2,7),P(2,7),P(-3,-7),P(3,-7),P(-7,-3),P(7,-3),P(-7,3),P(7,3),P(-3,7),P(3,7),P(-5,-6),P(5,-6),P(-6,-5),P(6,-5),P(-6,5),P(6,5),P(-5,6),P(5,6),P(0,-8),P(-8,0),P(8,0),P(0,8),\nP(-1,-8),P(1,-8),P(-4,-7),P(4,-7),P(-7,-4),P(7,-4),P(-8,-1),P(8,-1),P(-8,1),P(8,1),P(-7,4),P(7,4),P(-4,7),P(4,7),P(-1,8),P(1,8),P(-2,-8),P(2,-8),P(-8,-2),P(8,-2),P(-8,2),P(8,2),P(-2,8),P(2,8),P(-6,-6),P(6,-6),P(-6,6),P(6,6),P(-3,-8),P(3,-8),P(-8,-3),P(8,-3),P(-8,3),P(8,3),P(-3,8),P(3,8),P(-5,-7),P(5,-7),P(-7,-5),P(7,-5),P(-7,5),P(7,5),P(-5,7),P(5,7),P(-4,-8),P(4,-8),P(-8,-4),P(8,-4),P(-8,4),P(8,4),P(-4,8),P(4,8),P(0,-9),P(-9,0),P(9,0),P(0,9),\nP(-1,-9),P(1,-9),P(-9,-1),P(9,-1),P(-9,1),P(9,1),P(-1,9),P(1,9),P(-2,-9),P(2,-9),P(-6,-7),P(6,-7),P(-7,-6),P(7,-6),P(-9,-2),P(9,-2),P(-9,2),P(9,2),P(-7,6),P(7,6),P(-6,7),P(6,7),P(-2,9),P(2,9),P(-5,-8),P(5,-8),P(-8,-5),P(8,-5),P(-8,5),P(8,5),P(-5,8),P(5,8),P(-3,-9),P(3,-9),P(-9,-3),P(9,-3),P(-9,3),P(9,3),P(-3,9),P(3,9),P(-4,-9),P(4,-9),P(-9,-4),P(9,-4),P(-9,4),P(9,4),P(-4,9),P(4,9),P(-7,-7),P(7,-7),P(-7,7),P(7,7),P(0,-10),P(-6,-8),P(6,-8),P(-8,-6),P(8,-6),P(-10,0),P(10,0),P(-8,6),P(8,6),P(-6,8),P(6,8),P(0,10),\nP(-1,-10),P(1,-10),P(-10,-1),P(10,-1),P(-10,1),P(10,1),P(-1,10),P(1,10),P(-2,-10),P(2,-10),P(-10,-2),P(10,-2),P(-10,2),P(10,2),P(-2,10),P(2,10),P(-5,-9),P(5,-9),P(-9,-5),P(9,-5),P(-9,5),P(9,5),P(-5,9),P(5,9),P(-3,-10),P(3,-10),P(-10,-3),P(10,-3),P(-10,3),P(10,3),P(-3,10),P(3,10),P(-7,-8),P(7,-8),P(-8,-7),P(8,-7),P(-8,7),P(8,7),P(-7,8),P(7,8),P(-4,-10),P(4,-10),P(-10,-4),P(10,-4),P(-10,4),P(10,4),P(-4,10),P(4,10),P(-6,-9),P(6,-9),P(-9,-6),P(9,-6),P(-9,6),P(9,6),P(-6,9),P(6,9),P(0,-11),P(-11,0),P(11,0),P(0,11),\nP(-1,-11),P(1,-11),P(-11,-1),P(11,-1),P(-11,1),P(11,1),P(-1,11),P(1,11),P(-2,-11),P(2,-11),P(-5,-10),P(5,-10),P(-10,-5),P(10,-5),P(-11,-2),P(11,-2),P(-11,2),P(11,2),P(-10,5),P(10,5),P(-5,10),P(5,10),P(-2,11),P(2,11),P(-8,-8),P(8,-8),P(-8,8),P(8,8),P(-3,-11),P(3,-11),P(-7,-9),P(7,-9),P(-9,-7),P(9,-7),P(-11,-3),P(11,-3),P(-11,3),P(11,3),P(-9,7),P(9,7),P(-7,9),P(7,9),P(-3,11),P(3,11),P(-6,-10),P(6,-10),P(-10,-6),P(10,-6),P(-10,6),P(10,6),P(-6,10),P(6,10),P(-4,-11),P(4,-11),P(-11,-4),P(11,-4),P(-11,4),P(11,4),P(-4,11),P(4,11),P(0,-12),P(-12,0),P(12,0),P(0,12),\nP(-1,-12),P(1,-12),P(-8,-9),P(8,-9),P(-9,-8),P(9,-8),P(-12,-1),P(12,-1),P(-12,1),P(12,1),P(-9,8),P(9,8),P(-8,9),P(8,9),P(-1,12),P(1,12),P(-5,-11),P(5,-11),P(-11,-5),P(11,-5),P(-11,5),P(11,5),P(-5,11),P(5,11),P(-2,-12),P(2,-12),P(-12,-2),P(12,-2),P(-12,2),P(12,2),P(-2,12),P(2,12),P(-7,-10),P(7,-10),P(-10,-7),P(10,-7),P(-10,7),P(10,7),P(-7,10),P(7,10),P(-3,-12),P(3,-12),P(-12,-3),P(12,-3),P(-12,3),P(12,3),P(-3,12),P(3,12),P(-6,-11),P(6,-11),P(-11,-6),P(11,-6),P(-11,6),P(11,6),P(-6,11),P(6,11),P(-4,-12),P(4,-12),P(-12,-4),P(12,-4),P(-12,4),P(12,4),P(-4,12),P(4,12),P(-9,-9),P(9,-9),P(-9,9),P(9,9),P(-8,-10),P(8,-10),P(-10,-8),P(10,-8),P(-10,8),P(10,8),P(-8,10),P(8,10),P(0,-13),P(-5,-12),P(5,-12),P(-12,-5),P(12,-5),P(-13,0),P(13,0),P(-12,5),P(12,5),P(-5,12),P(5,12),P(0,13),\nP(-1,-13),P(1,-13),P(-7,-11),P(7,-11),P(-11,-7),P(11,-7),P(-13,-1),P(13,-1),P(-13,1),P(13,1),P(-11,7),P(11,7),P(-7,11),P(7,11),P(-1,13),P(1,13),P(-2,-13),P(2,-13),P(-13,-2),P(13,-2),P(-13,2),P(13,2),P(-2,13),P(2,13),P(-3,-13),P(3,-13),P(-13,-3),P(13,-3),P(-13,3),P(13,3),P(-3,13),P(3,13),P(-6,-12),P(6,-12),P(-12,-6),P(12,-6),P(-12,6),P(12,6),P(-6,12),P(6,12),P(-9,-10),P(9,-10),P(-10,-9),P(10,-9),P(-10,9),P(10,9),P(-9,10),P(9,10),P(-4,-13),P(4,-13),P(-8,-11),P(8,-11),P(-11,-8),P(11,-8),P(-13,-4),P(13,-4),P(-13,4),P(13,4),P(-11,8),P(11,8),P(-8,11),P(8,11),P(-4,13),P(4,13),P(-7,-12),P(7,-12),P(-12,-7),P(12,-7),P(-12,7),P(12,7),P(-7,12),P(7,12),P(-5,-13),P(5,-13),P(-13,-5),P(13,-5),P(-13,5),P(13,5),P(-5,13),P(5,13),P(0,-14),P(-14,0),P(14,0),P(0,14),\nP(-1,-14),P(1,-14),P(-14,-1),P(14,-1),P(-14,1),P(14,1),P(-1,14),P(1,14),P(-2,-14),P(2,-14),P(-10,-10),P(10,-10),P(-14,-2),P(14,-2),P(-14,2),P(14,2),P(-10,10),P(10,10),P(-2,14),P(2,14),P(-9,-11),P(9,-11),P(-11,-9),P(11,-9),P(-11,9),P(11,9),P(-9,11),P(9,11),P(-3,-14),P(3,-14),P(-6,-13),P(6,-13),P(-13,-6),P(13,-6),P(-14,-3),P(14,-3),P(-14,3),P(14,3),P(-13,6),P(13,6),P(-6,13),P(6,13),P(-3,14),P(3,14),P(-8,-12),P(8,-12),P(-12,-8),P(12,-8),P(-12,8),P(12,8),P(-8,12),P(8,12),P(-4,-14),P(4,-14),P(-14,-4),P(14,-4),P(-14,4),P(14,4),P(-4,14),P(4,14),P(-7,-13),P(7,-13),P(-13,-7),P(13,-7),P(-13,7),P(13,7),P(-7,13),P(7,13),P(-5,-14),P(5,-14),P(-10,-11),P(10,-11),P(-11,-10),P(11,-10),P(-14,-5),P(14,-5),P(-14,5),P(14,5),P(-11,10),P(11,10),P(-10,11),P(10,11),P(-5,14),P(5,14),P(0,-15),P(-9,-12),P(9,-12),P(-12,-9),P(12,-9),P(-15,0),P(15,0),P(-12,9),P(12,9),P(-9,12),P(9,12),P(0,15)\n);\nconst int DEFAULT_PATCH_RADIUS = 15;\nconst int MIN_PATCH_RADIUS = 2;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nvec2 m = vec2(0.0f);\nfloat pot = exp2(keypoint.lod);\nvec2 imageSize = vec2(textureSize(image, 0));\nint scaledRadius = int(ceil(float(DEFAULT_PATCH_RADIUS) / pot));\nint radius = max(scaledRadius, MIN_PATCH_RADIUS);\nint count = diskPointCount[radius];\nfor(int j = 0; j < count; j++) {\nvec2 offset = vec2(diskPoint[j]);\nvec2 position = keypoint.position + round(pot * offset);\nvec4 patchPixel = texture(image, (position + vec2(0.5f)) / imageSize);\nm += offset * patchPixel.g;\n}\nfloat angle = fastAtan2(m.y, m.x);\nfloat encodedOrientation = encodeKeypointOrientation(angle);\ncolor = vec4(0.0f, encodedOrientation, 0.0f, 0.0f);\n}'},"./src/gpu/shaders/keypoints/refine-scale.glsl":e=>{e.exports='@include "keypoints.glsl"\n@include "filters.glsl"\n#if !defined(METHOD)\n#error Undefined METHOD\n#endif\nuniform sampler2D pyramid;\nuniform float lodStep;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#if METHOD == 1\nuniform int threshold;\n#endif\nconst float eps = 1e-6;\nfloat cornerStrength(vec2 position, float lod)\n{\n#if METHOD == 0\nreturn laplacian(pyramid, position, lod);\n#elif METHOD == 1\nfloat pot = exp2(lod);\nfloat t = float(clamp(threshold, 0, 255)) / 255.0f;\n#define P(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\nmat4 mp = mat4(\nP(0,3),P(3,0),P(0,-3),P(-3,0),\nP(1,3),P(2,2),P(3,1),P(3,-1),\nP(2,-2),P(1,-3),P(-1,-3),P(-2,-2),\nP(-3,-1),P(-3,1),P(-2,2),P(-1,3)\n);\nfloat c = P(0,0);\nfloat ct = c + t, c_t = c - t;\nmat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);\nmat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;\nconst vec4 zeros = vec4(0.0f), ones = vec4(1.0f);\nvec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);\nbs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);\nbs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);\nbs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);\nreturn max(dot(bs, ones), dot(ds, ones)) / 16.0f;\n#else\n#error Invalid method\n#endif\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\ncolor = pixel;\nif(address.offset != 1)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nvec3 strength = vec3(\ncornerStrength(keypoint.position, max(0.0f, keypoint.lod - lodStep)),\ncornerStrength(keypoint.position, keypoint.lod),\ncornerStrength(keypoint.position, keypoint.lod + lodStep)\n);\nvec3 p = mat3(\n2, -3, 1,\n-4, 4, 0,\n2, -1, 0\n) * strength;\nfloat maxStrength = max(strength.x, max(strength.y, strength.z));\nvec3 diffStrength = abs(strength - vec3(maxStrength));\nvec3 strengthIndicators = vec3(lessThan(diffStrength, vec3(eps)));\nfloat maxPoint = min(1.0f, dot(vec3(0.0f, 0.5f, 1.0f), strengthIndicators));\nbool hasMax = p.x < -eps;\nfloat pmax = hasMax ? -0.5f * p.y / p.x : maxPoint;\nfloat alpha = abs(pmax - 0.5f) <= 0.5f ? pmax : maxPoint;\nfloat lodOffset = mix(-lodStep, lodStep, alpha);\nfloat lod = keypoint.lod + lodOffset;\ncolor.r = encodeLod(lod);\n}'},"./src/gpu/shaders/keypoints/score-findmax.glsl":e=>{e.exports='@include "float16.glsl"\nuniform sampler2D corners;\nuniform int iterationNumber;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 bounds = outputSize();\nint jump = (1 << iterationNumber);\nint clusterLength = jump << 1;\nint clusterMask = clusterLength - 1;\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\nvec4 p0 = threadPixel(corners);\nvec4 p1 = texelFetch(corners, next1 % bounds, 0);\nvec4 p2 = texelFetch(corners, next2 % bounds, 0);\nvec4 p3 = texelFetch(corners, next3 % bounds, 0);\nfloat s0 = decodeFloat16(p0.rb);\nfloat s1 = decodeFloat16(p1.rb);\nfloat s2 = decodeFloat16(p2.rb);\nfloat s3 = decodeFloat16(p3.rb);\nbool b0 = s0 >= s1 && s0 >= s2 && s0 >= s3;\nbool b1 = s1 >= s0 && s1 >= s2 && s1 >= s3;\nbool b2 = s2 >= s0 && s2 >= s1 && s2 >= s3;\ncolor = vec4(0.0f);\ncolor.rb = b0 ? p0.rb : (\nb1 ? p1.rb : (\nb2 ? p2.rb : p3.rb\n)\n);\n}'},"./src/gpu/shaders/keypoints/shuffle.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#if PERMUTATION_MAXLEN % 4 > 0 || PERMUTATION_MAXLEN * 4 > 16384\n#error Invalid PERMUTATION_MAXLEN\n#endif\nlayout(std140) uniform Permutation\n{\nivec4 permutation[PERMUTATION_MAXLEN / 4];\n};\nint permutationElement(int index)\n{\nint base = index - (index % PERMUTATION_MAXLEN);\nint offset = index - base;\nivec4 tuple = permutation[offset / 4];\nint newOffset = tuple[offset & 3];\nreturn base + newOffset;\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nint otherIndex = permutationElement(myIndex);\nKeypointAddress otherAddress = KeypointAddress(otherIndex * pixelsPerKeypoint, myAddress.offset);\nKeypoint myKeypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nKeypoint otherKeypoint = decodeKeypoint(encodedKeypoints, encoderLength, otherAddress);\ncolor = readKeypointData(encodedKeypoints, encoderLength, otherAddress);\n}'},"./src/gpu/shaders/keypoints/sort-keypoints.glsl":e=>{e.exports='@include "keypoints.glsl"\n#if !defined(STAGE)\n#error Undefined STAGE\n#elif STAGE == 1\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#elif STAGE == 2\nuniform sampler2D permutation;\nuniform int blockSize;\nuniform int dblLog2BlockSize;\n#elif STAGE == 3\nuniform sampler2D permutation;\nuniform int maxKeypoints;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\n#else\n#error Invalid STAGE\n#endif\nstruct PermutationElement\n{\nint keypointIndex;\nfloat score;\nbool valid;\n};\nvec4 encodePermutationElement(PermutationElement element)\n{\nconst vec2 ONES = vec2(1.0f);\nvec2 encodedScore = element.valid ? encodeFloat16(element.score) : ONES;\nvec2 encodedIndex = vec2(element.keypointIndex & 255, (element.keypointIndex >> 8) & 255) / 255.0f;\nreturn vec4(encodedIndex, encodedScore);\n}\nPermutationElement decodePermutationElement(vec4 pixel)\n{\nconst vec2 ONES = vec2(1.0f);\nPermutationElement element;\nelement.keypointIndex = int(pixel.r * 255.0f) | (int(pixel.g * 255.0f) << 8);\nelement.valid = !all(equal(pixel.ba, ONES));\nelement.score = element.valid ? decodeFloat16(pixel.ba) : -1.0f;\nreturn element;\n}\nPermutationElement readPermutationElement(sampler2D permutation, int elementIndex, int stride, int height)\n{\nconst vec4 INVALID_PIXEL = vec4(1.0f);\nivec2 pos = ivec2(elementIndex % stride, elementIndex / stride);\nvec4 pixel = pos.y < height ? pixelAt(permutation, pos) : INVALID_PIXEL;\nreturn decodePermutationElement(pixel);\n}\n#if STAGE == 2\nPermutationElement selectKth(sampler2D permutation, int k, int la, int ra, int lb, int rb)\n{\nfloat scoreA, scoreB;\nint ha, hb, ma, mb;\nbool discard1stHalf, altb;\nbool locked = false;\nint tmp, result = 0;\nint stride = outputSize().x;\nint height = outputSize().y;\nfor(int i = 0; i < dblLog2BlockSize; i++) {\ntmp = (lb > rb && !locked) ? (la+k) : result;\nresult = (la > ra && !locked) ? (lb+k) : tmp;\nlocked = locked || (la > ra) || (lb > rb);\nha = (ra - la + 1) / 2;\nhb = (rb - lb + 1) / 2;\nma = la + ha;\nmb = lb + hb;\nscoreA = readPermutationElement(permutation, ma, stride, height).score;\nscoreB = readPermutationElement(permutation, mb, stride, height).score;\ndiscard1stHalf = (k > ha + hb);\naltb = (-scoreA < -scoreB);\nk -= int(discard1stHalf && altb) * (ha + 1);\nk -= int(discard1stHalf && !altb) * (hb + 1);\nla += int(discard1stHalf && altb) * (ma + 1 - la);\nlb += int(discard1stHalf && !altb) * (mb + 1 - lb);\nra += int(!discard1stHalf && !altb) * (ma - 1 - ra);\nrb += int(!discard1stHalf && altb) * (mb - 1 - rb);\n}\nreturn readPermutationElement(permutation, result, stride, height);\n}\n#endif\nvoid main()\n{\n#if STAGE == 1\nivec2 thread = threadLocation();\nint stride = outputSize().x;\nint keypointIndex = thread.y * stride + thread.x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nPermutationElement element;\nelement.keypointIndex = keypointIndex;\nelement.score = keypoint.score;\nelement.valid = !isBadKeypoint(keypoint);\ncolor = encodePermutationElement(element);\n#elif STAGE == 2\nivec2 thread = threadLocation();\nint stride = outputSize().x;\nint elementIndex = thread.y * stride + thread.x;\nint blockIndex = elementIndex / blockSize;\nint blockOffset = elementIndex % blockSize;\nint la = blockIndex * blockSize;\nint lb = la + blockSize / 2;\nint ra = lb - 1;\nint rb = (blockIndex + 1) * blockSize - 1;\nint k = blockOffset;\nPermutationElement element = selectKth(permutation, k, la, ra, lb, rb);\ncolor = encodePermutationElement(element);\n#elif STAGE == 3\nivec2 thread = threadLocation();\nint newEncoderLength = outputSize().x;\nKeypointAddress myAddress = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);\nint myKeypointIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nivec2 psize = textureSize(permutation, 0);\nPermutationElement element = readPermutationElement(permutation, myKeypointIndex, psize.x, psize.y);\nint oldEncoderLength = textureSize(encodedKeypoints, 0).x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(element.keypointIndex * pixelsPerKeypoint, myAddress.offset);\nvec4 keypointData = readKeypointData(encodedKeypoints, oldEncoderLength, address);\ncolor = myKeypointIndex < maxKeypoints && element.valid ? keypointData : encodeNullKeypoint();\n#endif\n}'},"./src/gpu/shaders/keypoints/subpixel-refinement.glsl":e=>{e.exports='@include "keypoints.glsl"\n@include "float16.glsl"\n#if !defined(METHOD)\n#error Must define METHOD\n#endif\nuniform sampler2D pyramid;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int maxIterations;\nuniform float epsilon;\nconst int PATCH_RADIUS = 1;\nconst int PATCH_SIZE = 2 * PATCH_RADIUS + 1;\nconst int PATCH_SIZE_SQUARED = PATCH_SIZE * PATCH_SIZE;\nconst int LARGE_PATCH_RADIUS = PATCH_RADIUS + 1;\nconst int LARGE_PATCH_SIZE = 2 * LARGE_PATCH_RADIUS + 1;\nconst int LARGE_PATCH_SIZE_SQUARED = LARGE_PATCH_SIZE * LARGE_PATCH_SIZE;\nconst int LARGER_PATCH_RADIUS = LARGE_PATCH_RADIUS + 1;\nconst int LARGER_PATCH_SIZE = 2 * LARGER_PATCH_RADIUS + 1;\nconst int LARGER_PATCH_SIZE_SQUARED = LARGER_PATCH_SIZE * LARGER_PATCH_SIZE;\nconst float EPS = 1e-5;\nfloat smoothPixelBuffer[LARGER_PATCH_SIZE_SQUARED];\nvec2 derivativesBuffer[LARGE_PATCH_SIZE_SQUARED];\nfloat responseBuffer[PATCH_SIZE_SQUARED];\n#define patchPixelAt(u,v) smoothPixelBuffer[((v) + LARGER_PATCH_RADIUS) * LARGER_PATCH_SIZE + ((u) + LARGER_PATCH_RADIUS)]\n#define derivativesAt(u,v) derivativesBuffer[((v) + LARGE_PATCH_RADIUS) * LARGE_PATCH_SIZE + ((u) + LARGE_PATCH_RADIUS)]\n#define responseAt(u,v) responseBuffer[((v) + PATCH_RADIUS) * PATCH_SIZE + ((u) + PATCH_RADIUS)]\nvoid readPixels(vec2 center, float lod)\n{\nivec2 pyrBaseSize = textureSize(pyramid, 0);\nfloat pot = exp2(lod);\nint u, v;\nfor(int j = 0; j < LARGER_PATCH_SIZE; j++) {\nfor(int i = 0; i < LARGER_PATCH_SIZE; i++) {\nu = i - LARGER_PATCH_RADIUS;\nv = j - LARGER_PATCH_RADIUS;\npatchPixelAt(u,v) = pyrSubpixelAtExOffset(pyramid, center, lod, pot, ivec2(u,v), pyrBaseSize).g;\n}\n}\n}\nvoid computeDerivatives()\n{\nconst mat3 dx = mat3(\n-1, 0, 1,\n-2, 0, 2,\n-1, 0, 1\n);\nconst mat3 dy = mat3(\n1, 2, 1,\n0, 0, 0,\n-1,-2,-1\n);\nint u, v;\nmat3 pix, convX, convY;\nconst vec3 ones = vec3(1.0f);\nfor(int j = 0; j < LARGE_PATCH_SIZE; j++) {\nfor(int i = 0; i < LARGE_PATCH_SIZE; i++) {\nu = i - LARGE_PATCH_RADIUS;\nv = j - LARGE_PATCH_RADIUS;\npix = mat3(\npatchPixelAt(u+1,v+1), patchPixelAt(u+0,v+1), patchPixelAt(u-1,v+1),\npatchPixelAt(u+1,v+0), patchPixelAt(u+0,v+0), patchPixelAt(u-1,v+0),\npatchPixelAt(u+1,v-1), patchPixelAt(u+0,v-1), patchPixelAt(u-1,v-1)\n);\nconvX = matrixCompMult(dx, pix);\nconvY = matrixCompMult(dy, pix);\nderivativesAt(u,v) = vec2(\ndot(ones, vec3(\ndot(convX[0], ones),\ndot(convX[1], ones),\ndot(convX[2], ones)\n)),\ndot(ones, vec3(\ndot(convY[0], ones),\ndot(convY[1], ones),\ndot(convY[2], ones)\n))\n);\n}\n}\n}\nvec2 computeResponseMap()\n{\nfloat patchArea = float(PATCH_SIZE * PATCH_SIZE);\nvec3 h; vec2 d, c = vec2(0.0f);\nconst vec3 ones = vec3(1.0f);\nfloat response, sum = 0.0f;\nint u, v;\n#define H(r,s) d = derivativesAt((r),(s)); h += vec3(d.x * d.x, d.x * d.y, d.y * d.y)\nfor(int j = 0; j < PATCH_SIZE; j++) {\nfor(int i = 0; i < PATCH_SIZE; i++) {\nu = i - PATCH_RADIUS;\nv = j - PATCH_RADIUS;\nh = vec3(0.0f);\nH(u-1,v-1); H(u+0,v-1); H(u+1,v-1);\nH(u-1,v+0); H(u+0,v+0); H(u+1,v+0);\nH(u-1,v+1); H(u+0,v+1); H(u+1,v+1);\nresponse = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));\nresponse /= patchArea;\nresponseAt(u,v) = response;\nc += vec2(u,v) * response;\nsum += response;\n}\n}\nreturn abs(sum) > EPS ? c / sum : vec2(0.0f);\n}\n#if METHOD == 0\nvec2 quadratic1d()\n{\nfloat a = 0.5f * (responseAt(-1,0) - 2.0f * responseAt(0,0) + responseAt(1,0));\nfloat b = 0.5f * (responseAt(1,0) - responseAt(-1,0));\nfloat c = responseAt(0,0);\nfloat d = 0.5f * (responseAt(0,-1) - 2.0f * responseAt(0,0) + responseAt(0,1));\nfloat e = 0.5f * (responseAt(0,1) - responseAt(0,-1));\nfloat f = responseAt(0,0);\nbool hasMax = a < -EPS && d < -EPS;\nreturn hasMax ? -0.5f * vec2(b / a, e / d) : vec2(0.0f);\n}\n#endif\n#if METHOD == 1\nvec2 taylor2d()\n{\nfloat dx = (-responseAt(-1,0) + responseAt(1,0)) * 0.5f;\nfloat dy = (-responseAt(0,-1) + responseAt(0,1)) * 0.5f;\nfloat dxx = responseAt(-1,0) - 2.0f * responseAt(0,0) + responseAt(1,0);\nfloat dyy = responseAt(0,-1) - 2.0f * responseAt(0,0) + responseAt(0,1);\nfloat dxy = (responseAt(-1,-1) + responseAt(1,1) - responseAt(1,-1) - responseAt(-1,1)) * 0.25f;\nfloat det = dxx * dyy - dxy * dxy;\nmat2 inv = mat2(dyy, -dxy, -dxy, dxx);\nbool hasMax = det > EPS && dxx < 0.0f;\nreturn hasMax ? inv * vec2(dx, dy) / (-det) : vec2(0.0f);\n}\n#endif\n#if METHOD == 2\nvoid bilinearUpsample(ivec2 patchOffset, vec4 pixelsOfPatch)\n{\nint u, v, i, j;\nvec2 frc, ifrc; vec4 sub;\nconst vec4 ones = vec4(1.0f);\nfloat s = 1.0f / float(PATCH_SIZE - 1);\nint xoff = 2 * patchOffset.x;\nint yoff = 2 * patchOffset.y;\nfor(j = 0; j < PATCH_SIZE; j++) {\nfor(i = 0; i < PATCH_SIZE; i++) {\nu = i - PATCH_RADIUS;\nv = j - PATCH_RADIUS;\nfrc = vec2(i, j) * s;\nifrc = vec2(1.0f) - frc;\nsub = vec4(\nifrc.x * ifrc.y,\nfrc.x * ifrc.y,\nifrc.x * frc.y,\nfrc.x * frc.y\n);\npatchPixelAt(u+xoff,v+yoff) = dot(sub*pixelsOfPatch, ones);\n}\n}\n}\n#endif\n#if METHOD == 3\nvoid bicubicUpsample(ivec2 patchOffset, vec4 pixelsOfPatch, vec4 dx, vec4 dy, vec4 dxy)\n{\nfloat x, y, s = 1.0f / float(PATCH_SIZE - 1);\nint u, v, i, j;\nfloat f00 = pixelsOfPatch.x;\nfloat f10 = pixelsOfPatch.y;\nfloat f01 = pixelsOfPatch.z;\nfloat f11 = pixelsOfPatch.w;\nfloat fx00 = dx.x;\nfloat fx10 = dx.y;\nfloat fx01 = dx.z;\nfloat fx11 = dx.w;\nfloat fy00 = dy.x;\nfloat fy10 = dy.y;\nfloat fy01 = dy.z;\nfloat fy11 = dy.w;\nfloat fxy00 = dxy.x;\nfloat fxy10 = dxy.y;\nfloat fxy01 = dxy.z;\nfloat fxy11 = dxy.w;\nmat4 bicubic = mat4(\n1, 0, -3, 2,\n0, 0, 3, -2,\n0, 1, -2, 1,\n0, 0, -1, 1\n) * mat4(\nf00, f10, fx00, fx10,\nf01, f11, fx01, fx11,\nfy00, fy10, fxy00, fxy10,\nfy01, fy11, fxy01, fxy11\n) * mat4(\n1, 0, 0, 0,\n0, 0, 1, 0,\n-3, 3, -2, -1,\n2, -2, 1, 1\n);\nint xoff = 2 * patchOffset.x;\nint yoff = 2 * patchOffset.y;\nfor(j = 0; j < PATCH_SIZE; j++) {\nfor(i = 0; i < PATCH_SIZE; i++) {\nu = i - PATCH_RADIUS;\nv = j - PATCH_RADIUS;\nx = float(i) * s;\ny = float(j) * s;\npatchPixelAt(u+xoff,v+yoff) = dot(\nvec4(1, x, x*x, x*x*x),\nbicubic * vec4(1, y, y*y, y*y*y)\n);\n}\n}\n}\n#endif\n#if METHOD == 2 || METHOD == 3\nvoid upsamplePatch(int left, int top, int right, int bottom)\n{\nint x, y, k;\nvec4 ptch[9];\nvec2 d00, d10, d01, d11;\nfor(k = 0; k < 9; k++) {\nx = -1 + (k % 3);\ny = -1 + (k / 3);\nptch[k] = vec4(\npatchPixelAt(left+x, top+y),\npatchPixelAt(right+x, top+y),\npatchPixelAt(left+x, bottom+y),\npatchPixelAt(right+x, bottom+y)\n);\n}\nfor(k = 0; k < 9; k++) {\nx = -1 + (k % 3);\ny = -1 + (k / 3);\n#if METHOD == 2\nbilinearUpsample(ivec2(x, y), ptch[k]);\n#elif METHOD == 3\nd00 = derivativesAt(left+x, top+y);\nd10 = derivativesAt(right+x, top+y);\nd01 = derivativesAt(left+x, bottom+y);\nd11 = derivativesAt(right+x, bottom+y);\nbicubicUpsample(ivec2(x, y), ptch[k],\nvec4(d00.x, d10.x, d01.x, d11.x),\nvec4(d00.y, d10.y, d01.y, d11.y),\n0.25f * vec4(\n(patchPixelAt(left+x + 1,top+y + 1) + patchPixelAt(left+x - 1, top+y - 1)) - (patchPixelAt(left+x + 1, top+y - 1) + patchPixelAt(left+x - 1, top+y + 1)),\n(patchPixelAt(right+x + 1,top+y + 1) + patchPixelAt(right+x - 1, top+y - 1)) - (patchPixelAt(right+x + 1, top+y - 1) + patchPixelAt(right+x - 1, top+y + 1)),\n(patchPixelAt(left+x + 1,bottom+y + 1) + patchPixelAt(left+x - 1, bottom+y - 1)) - (patchPixelAt(left+x + 1, bottom+y - 1) + patchPixelAt(left+x - 1, bottom+y + 1)),\n(patchPixelAt(right+x + 1,bottom+y + 1) + patchPixelAt(right+x - 1, bottom+y - 1)) - (patchPixelAt(right+x + 1, bottom+y - 1) + patchPixelAt(right+x - 1, bottom+y + 1))\n)\n);\n#endif\n}\n}\nvec2 upsampleResponseMap(int left, int top, int right, int bottom)\n{\nupsamplePatch(left, top, right, bottom);\ncomputeDerivatives();\nreturn computeResponseMap();\n}\nvec2 iterativeUpsample(vec2 initialGuess)\n{\nint refine = 1;\nfloat scale = 0.5f;\nfloat eps2 = epsilon * epsilon;\nvec2 guess = initialGuess, localGuess = initialGuess;\nfor(int k = 0; k < maxIterations; k++) {\nivec4 quad = ivec4(floor(localGuess.x), floor(localGuess.y), ceil(localGuess.x), ceil(localGuess.y));\nvec2 response = (refine != 0) ? upsampleResponseMap(quad.x, quad.y, quad.z, quad.w) : vec2(0.0f);\nlocalGuess = response * scale;\nguess += localGuess;\nscale *= 0.5f;\nrefine *= int(dot(localGuess, localGuess) >= eps2);\n}\nreturn guess;\n}\n#endif\nvoid main()\n{\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\ncolor = encodeNullPairOfFloat16();\nif(isNullKeypoint(keypoint))\nreturn;\ncolor = encodeDiscardedPairOfFloat16();\nif(isBadKeypoint(keypoint))\nreturn;\nreadPixels(keypoint.position, keypoint.lod);\ncomputeDerivatives();\nvec2 offset = computeResponseMap();\n#if METHOD == 0\noffset = quadratic1d();\n#elif METHOD == 1\noffset = taylor2d();\n#elif METHOD == 2 || METHOD == 3\noffset = iterativeUpsample(offset);\n#else\n#error Unknown METHOD\n#endif\nfloat pot = exp2(keypoint.lod);\ncolor = encodePairOfFloat16(offset * pot);\n}'},"./src/gpu/shaders/keypoints/transfer-flow.glsl":e=>{e.exports='@include "keypoints.glsl"\n@include "float16.glsl"\nuniform sampler2D encodedFlow;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nint len = textureSize(encodedFlow, 0).x;\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\ncolor = pixel;\nif(isBadKeypoint(keypoint))\nreturn;\nivec2 location = ivec2(myIndex % len, myIndex / len);\nvec4 encodedFlow = myIndex < len * len ? pixelAt(encodedFlow, location) : encodeDiscardedKeypoint();\nbool discardFlow = isDiscardedPairOfFloat16(encodedFlow);\nvec2 flow = !discardFlow ? decodePairOfFloat16(encodedFlow) : vec2(0.0f);\nvec4 newPosition = encodeKeypointPosition(keypoint.position + flow);\nvec4 newPixel = myAddress.offset == 0 ? newPosition : pixel;\ncolor = !discardFlow ? newPixel : encodeDiscardedKeypoint();\n}'},"./src/gpu/shaders/keypoints/transfer-orientation.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedOrientations;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nint orientationEncoderLength = textureSize(encodedOrientations, 0).x;\nivec2 location = ivec2(myIndex % orientationEncoderLength, myIndex / orientationEncoderLength);\nvec4 targetPixel = pixelAt(encodedOrientations, location);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nbool isValid = !isBadKeypoint(keypoint);\nfloat encodedOrientation = targetPixel.g;\ncolor = isValid && myAddress.offset == 1 ? vec4(pixel.r, encodedOrientation, pixel.ba) : pixel;\n}'},"./src/gpu/shaders/keypoints/transfer-to-extra.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedData;\nuniform int strideOfEncodedData;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvec4 readEncodedData(sampler2D encodedData, int strideOfEncodedData, int elementId, int pixelsPerElement, int pixelOffset)\n{\nint rasterIndex = elementId * pixelsPerElement + pixelOffset;\nivec2 pos = ivec2(rasterIndex % strideOfEncodedData, rasterIndex / strideOfEncodedData);\nreturn texelFetch(encodedData, pos, 0);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nint headerSize = sizeofEncodedKeypointHeader();\nint extraCell = myAddress.offset - headerSize / 4;\nint numberOfExtraCells = extraSize / 4;\ncolor = threadPixel(encodedKeypoints);\nif(extraCell < 0 || extraCell >= numberOfExtraCells)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nif(isBadKeypoint(keypoint))\nreturn;\ncolor = readEncodedData(encodedData, strideOfEncodedData, myIndex, numberOfExtraCells, extraCell);\n}'},"./src/gpu/shaders/keypoints/upload-keypoints.glsl":e=>{e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints;\nuniform int startIndex;\nuniform int endIndex;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#ifndef BUFFER_SIZE\n#error Undefined BUFFER_SIZE\n#endif\nlayout(std140) uniform KeypointBuffer\n{\nvec4 keypointBuffer[BUFFER_SIZE];\n};\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = pixel;\nif(index < startIndex)\nreturn;\ncolor = encodeNullKeypoint();\nif(index >= endIndex)\nreturn;\nvec4 data = keypointBuffer[index - startIndex];\nswitch(address.offset) {\ncase 0: {\ncolor = encodeKeypointPosition(data.xy);\nbreak;\n}\ncase 1: {\nvec2 score = encodeKeypointScore(max(data.w, 0.0f));\nfloat scale = encodeLod(data.z);\nfloat rotation = encodeKeypointOrientation(0.0f);\ncolor = vec4(scale, rotation, score);\nbreak;\n}\ndefault: {\ncolor = vec4(0.0f);\nbreak;\n}\n}\n}'},"./src/gpu/shaders/pyramids/downsample2.glsl":e=>{e.exports="uniform sampler2D image;\nvoid main()\n{\n#if 1\ncolor = texture(image, texCoord);\n#else\nivec2 thread = threadLocation();\nivec2 pos = min(thread * 2, textureSize(image, 0) - ivec2(1));\ncolor = pixelAt(image, pos);\n#endif\n}"},"./src/gpu/shaders/pyramids/upsample2.glsl":e=>{e.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = pixelAt(image, thread / 2);\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\n}"},"./src/gpu/shaders/transforms/additive-mix.glsl":e=>{e.exports='@include "subpixel.glsl"\nuniform sampler2D image0;\nuniform sampler2D image1;\nuniform float alpha;\nuniform float beta;\nuniform float gamma;\nconst vec4 BACKGROUND = vec4(0.0f);\nvoid main()\n{\nivec2 location = threadLocation();\nivec2 size0 = textureSize(image0, 0);\nivec2 size1 = textureSize(image1, 0);\nvec4 pix0 = all(lessThan(location, size0)) ? pixelAt(image0, location) : BACKGROUND;\nvec4 pix1 = all(lessThan(location, size1)) ? pixelAt(image1, location) : BACKGROUND;\nvec4 pix = clamp(alpha * pix0 + beta * pix1 + vec4(gamma), 0.0f, 1.0f);\ncolor = vec4(pix.rgb, 1.0f);\n}'},"./src/gpu/shaders/transforms/resize.glsl":e=>{e.exports='@include "subpixel.glsl"\nuniform sampler2D image;\nvoid main()\n{\nvec2 imageSize = vec2(textureSize(image, 0));\n#if !defined(INTERPOLATION_METHOD)\n#error Must define INTERPOLATION_METHOD\n#elif INTERPOLATION_METHOD == 0\nvec2 pos = texCoord * imageSize;\ncolor = textureLod(image, (round(pos) + vec2(0.5f)) / imageSize, 0.0f);\n#elif INTERPOLATION_METHOD == 1\ncolor = subpixelAtBI(image, texCoord * imageSize);\n#else\n#error Invalid INTERPOLATION_METHOD\n#endif\n}'},"./src/gpu/shaders/transforms/warp-perspective.glsl":e=>{e.exports='@include "subpixel.glsl"\nuniform sampler2D image;\nuniform mat3 inverseHomography;\nconst vec4 emptyColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\nvec2 perspectiveWarp(mat3 homography, vec2 p)\n{\nvec3 q = homography * vec3(p, 1.0f);\nreturn q.xy / q.z;\n}\nvoid main()\n{\nivec2 location = threadLocation();\nivec2 size = outputSize();\nconst vec2 zero = vec2(0.0f);\nvec2 target = perspectiveWarp(inverseHomography, vec2(location));\nbool withinBounds = all(bvec4(greaterThanEqual(target, zero), lessThan(target, vec2(size))));\ncolor = withinBounds ? subpixelAtBI(image, target) : emptyColor;\n}'},"./src/gpu/shaders/utils/copy-components.glsl":e=>{e.exports='@include "colors.glsl"\nuniform sampler2D dest, src;\nuniform int destComponents;\nuniform int srcComponentId;\nvoid main()\n{\nvec4 destPixel = threadPixel(dest);\nvec4 srcPixel = threadPixel(src);\nbvec4 flags = bvec4(\n(destComponents & PIXELCOMPONENT_RED) != 0,\n(destComponents & PIXELCOMPONENT_GREEN) != 0,\n(destComponents & PIXELCOMPONENT_BLUE) != 0,\n(destComponents & PIXELCOMPONENT_ALPHA) != 0\n);\ncolor = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);\n}'},"./src/gpu/shaders/utils/copy-raster.glsl":e=>{e.exports='#if !defined(TYPE)\n#error Undefined TYPE\n#elif TYPE == 1\n@include "keypoints.glsl"\n#define nullPixel() encodeNullKeypoint()\n#elif TYPE == 2\n@include "float16.glsl"\n#define nullPixel() encodeNullPairOfFloat16()\n#else\n#error Invalid TYPE\n#endif\nuniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 imageSize = textureSize(image, 0);\nint rasterIndex = thread.y * outputSize().x + thread.x;\nbool isValidPixel = rasterIndex < imageSize.x * imageSize.y;\nivec2 pos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\nvec4 nullpix = nullPixel();\ncolor = isValidPixel ? texelFetch(image, pos, 0) : nullpix;\n}'},"./src/gpu/shaders/utils/copy.glsl":e=>{e.exports="uniform sampler2D image;\nvoid main()\n{\ncolor = threadPixel(image);\n}"},"./src/gpu/shaders/utils/fill-components.glsl":e=>{e.exports='@include "colors.glsl"\nuniform sampler2D image;\nuniform int pixelComponents;\nuniform float value;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nbvec4 flags = bvec4(\n(pixelComponents & PIXELCOMPONENT_RED) != 0,\n(pixelComponents & PIXELCOMPONENT_GREEN) != 0,\n(pixelComponents & PIXELCOMPONENT_BLUE) != 0,\n(pixelComponents & PIXELCOMPONENT_ALPHA) != 0\n);\ncolor = mix(pixel, vec4(value), flags);\n}'},"./src/gpu/shaders/utils/fill.glsl":e=>{e.exports="uniform float value;\nvoid main()\n{\ncolor = vec4(value);\n}"},"./src/gpu/shaders/utils/flip-y.vs.glsl":e=>{e.exports="void vsmain()\n{\ngl_Position *= vec4(1,-1,1,1);\n}"},"./src/gpu/shaders/utils/scan-minmax2d.glsl":e=>{e.exports="uniform sampler2D image;\nuniform int iterationNumber;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 last = outputSize() - ivec2(1);\nint jump = (1 << iterationNumber);\nint clusterLength = jump << 1;\nint clusterMask = clusterLength - 1;\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\nvec4 p0 = texelFetch(image, thread, 0);\nvec4 p1 = texelFetch(image, min(next1, last), 0);\nvec4 p2 = texelFetch(image, min(next2, last), 0);\nvec4 p3 = texelFetch(image, min(next3, last), 0);\nvec4 pmax = max(max(p0, p1), max(p2, p3));\nvec4 pmin = min(min(p0, p1), min(p2, p3));\ncolor = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);\n}"},"./src/gpu/shaders/utils/sobel-derivatives.glsl":e=>{e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D pyramid;\nuniform float lod;\n#define USE_VARYINGS 1\nin vec2 v_pix0, v_pix1, v_pix2,\nv_pix3, v_pix4, v_pix5,\nv_pix6, v_pix7, v_pix8;\nconst mat3 hkern = mat3(\n1.0f, 0.0f,-1.0f,\n2.0f, 0.0f,-2.0f,\n1.0f, 0.0f,-1.0f\n), vkern = mat3(\n1.0f, 2.0f, 1.0f,\n0.0f, 0.0f, 0.0f,\n-1.0f,-2.0f,-1.0f\n);\n#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\n#define XIP(v) textureLod(pyramid, (v), lod).g\nvoid main()\n{\nconst vec3 ones = vec3(1.0f);\nfloat pot = exp2(lod);\nmat3 win = mat3(\n#if USE_VARYINGS\nXIP(v_pix0), XIP(v_pix1), XIP(v_pix2),\nXIP(v_pix3), XIP(v_pix4), XIP(v_pix5),\nXIP(v_pix6), XIP(v_pix7), XIP(v_pix8)\n#else\nPIX(-1,-1), PIX(0,-1), PIX(1,-1),\nPIX(-1,0), PIX(0,0), PIX(1,0),\nPIX(-1,1), PIX(0,1), PIX(1,1)\n#endif\n);\nmat3 dx = matrixCompMult(hkern, win);\nmat3 dy = matrixCompMult(vkern, win);\nvec2 df = vec2(\ndot(dx[0] + dx[1] + dx[2], ones),\ndot(dy[0] + dy[1] + dy[2], ones)\n);\ncolor = encodePairOfFloat16(df);\n}'},"./src/gpu/shaders/utils/sobel-derivatives.vs.glsl":e=>{e.exports="uniform mediump float lod;\nout vec2 v_pix0, v_pix1, v_pix2,\nv_pix3, v_pix4, v_pix5,\nv_pix6, v_pix7, v_pix8;\n#define PIX(x,y) (texCoord + ((pot) * vec2((x),(y))) / texSize)\nvoid vsmain()\n{\nfloat pot = exp2(lod);\nv_pix0 = PIX(-1,-1); v_pix1 = PIX(0,-1); v_pix2 = PIX(1,-1);\nv_pix3 = PIX(-1,0); v_pix4 = PIX(0,0); v_pix5 = PIX(1,0);\nv_pix6 = PIX(-1,1); v_pix7 = PIX(0,1); v_pix8 = PIX(1,1);\n}"},"./src/core/wasm/speedy-matrix.wasm.txt":e=>{e.exports="AGFzbQEAAAABiwETYAABfmADf39/AX9gAX8AYAN/f38AYAF9AX9gAX8Bf2ACf38Bf2AFf39/f38B\nf2AFf39/f38AYAZ/f39/f38Bf2AAAX9gAn99AX9gA39/fQF/YAJ/fwF9YAF/AX1gBH9/f38AYAR/\nf39/AX9gEX98fHx8fHx8fHx8fHx8fHx8AGAHf39/f39/fQF/AjsEA2VudgZtZW1vcnkCAAIDZW52\nBWZhdGFsAAIDZW52CGJ5dGVmaWxsAAMDZW52CmNvcHlXaXRoaW4AAwNAPwQFBgIGAQECBwgGAwAJ\nAgYCBgYKBQUFCQsFBgEBDAEBBgYGAQEMAQ0OAwgPAxAIAwYBEQEBAQEBARIBEgEBDwQFAXABBQUG\nCAF/AUHwmgQLB/QDHAZtYWxsb2MABARmcmVlAAYFc3JhbmQACgxNYXQzMl9jcmVhdGUAEA1NYXQz\nMl9kZXN0cm95ABcKTWF0MzJfZGF0YQAYDk1hdDMyX2RhdGFTaXplABkPTWF0MzJfdHJhbnNwb3Nl\nAB0JTWF0MzJfYWRkAB4OTWF0MzJfc3VidHJhY3QAHwtNYXQzMl9zY2FsZQAgDk1hdDMyX2NvbXBt\ndWx0ACEOTWF0MzJfbXVsdGlwbHkAIg5NYXQzMl9pbnZlcnNlMQAjDk1hdDMyX2ludmVyc2UyACQO\nTWF0MzJfaW52ZXJzZTMAJQ1NYXQzMl9xcl9mdWxsACwQTWF0MzJfcXJfcmVkdWNlZAAvDE1hdDMy\nX3FyX29scwAwEE1hdDMyX3FyX2ludmVyc2UAMxZNYXQzMl9ob21vZ3JhcGh5X25kbHQ0ADcVTWF0\nMzJfaG9tb2dyYXBoeV9uZGx0ADgUTWF0MzJfYWZmaW5lX2RpcmVjdDMAOhNNYXQzMl9hZmZpbmVf\nZGlyZWN0ADsYTWF0MzJfcHJhbnNhY19ob21vZ3JhcGh5ADwUTWF0MzJfcHJhbnNhY19hZmZpbmUA\nPhtNYXQzMl90cmFuc2Zvcm1fcGVyc3BlY3RpdmUAPxZNYXQzMl90cmFuc2Zvcm1fYWZmaW5lAEAJ\nCgEAQQELBA8REz0Kh7oBPyMBAX8gALwiAUGAgID8B3FBgICA/AdGIAFB////A3FBAEdxC2kBAX9B\nAEEAKALAmoCAAEEBajYCwJqAgABBAEEAKAK0moCAACIBQQdxIAFqIgEgAGo2ArSagIAAAkBB8JqE\n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\noZlEje21oPfGsD5jDQAgHCAFoiIYIB8gA6KhIiIgFCAIoiAcIAaiIh6gIiOiIB4gHyAEoqEiHiAU\nIAeiIBigIhiioSIkmUSN7bWg98awPmMNACAcmiIlIBShIiYgIqIgHyAcoSIiIBiioUQAAAAAAADw\nPyAkoyIkoiEYICIgI6IgJiAeoqEgJKIhHgJAAkAgHSAgZEEBcw0AIBMgGCAEoiAeIAOiRAAAAAAA\nAPA/oKAiBKIgJaMhHSAcIR8MAQsgEyAYIAaiIB4gBaJEAAAAAAAA8D+goCIEoiAfmqMhHQsgFyAE\noiAfoyETAkACQCAhICWZZEEBcw0AIBogGCAGoiAeIAWiRAAAAAAAAPA/oKAiBKIgFJqjIQcMAQsg\nGiAYIAiiIB4gB6JEAAAAAAAA8D+goCIEoiAcoyEHICUhFAsgGCAdmiABoiATIAKioSIXIAeioiAd\nIBsgBKIgFKMiFKIgHiATIAeaIAGiIBQgAqKhIhyioqCgIBMgB6KhIBggHSAcoqKhIB4gFyAUoqKh\nmUSN7bWg98awPmMNACALIA2hIhsgECAOoSIaoiAWIA8gDaEiH6KhIiCZRI3ttaD3xrA+Yw0AIBEh\nBCARIQIgESEGIBEhDiARIQEgESEDIBEhBSARIQggGyAVIBmgIhWiIBYgCSALoSANIA+hoCIZoqFE\nAAAAAAAA8D8gIKMiFqIiDSAMIAqhIBogGaIgHyAVoqEgFqIiFiAMoqAiDCAJoqIgCyAJoSAWIAui\noCILIBIgDSAQoqAiEKIgFiAPIAmhIA0gD6KgIg8gCqKioKAgDyAMoqEgDSALIAqioqEgFiAQIAmi\noqGZRI3ttaD3xrA+Yw0BIBYgF6IgDSAcoqBEAAAAAAAA8D+gIQUgGCAWIBOiIA0gFKKgoCEDIB4g\nFiAdoiANIAeioKAhASAMIBeiIBAgHKKgIAqgIQ4gGCAKoiAMIBOiIBAgFKKgoCEGIB4gCqIgDCAd\noiAQIAeioKAhAiALIBeiIA8gHKKgIAmgIQQgGCAJoiALIBOiIA8gFKKgoCERIB4gCaIgCyAdoiAP\nIAeioKAhCAwBCyARIQQgESECIBEhBiARIQ4gESEBIBEhAyARIQUgESEICyAAKAIAIicgCLY4AgAg\nJyAAQRRqKAIAIihBAnRqIBG2OAIAICcgKEEDdGogBLY4AgAgJyAAKAIQIgBBAnRqIAK2OAIAICcg\nACAoaiIpQQJ0aiAGtjgCACAnIAAgKEEBdGpBAnRqIA62OAIAICcgAEEDdGogAbY4AgAgJyAoIABB\nAXRqQQJ0aiADtjgCACAnIClBA3RqIAW2OAIAC7oHAhZ/Cn0CQAJAIAAoAghBA0cNACAAKAIMQQNH\nDQAgASgCCEECRw0AIAEoAgwiA0EESA0AIAIoAghBAkcNACACKAIMIANGDQELQbKTgIAAEICAgIAA\nIAEoAgwhAwsgA0EBdCIEQQgQkoCAgAAhBSAEQQEQkoCAgAAhBkEIQQEQkoCAgAAhBwJAIANBAUgN\nACAFQRRqKAIAIgRBDGwgBSgCECIIQQJ0IglqIQogBEEEdCAJaiELIARBFGwgCWohDCAEQRhsIg0g\nCWohDiAEQRxsIg8gCWohECACKAIQQQJ0IREgASgCEEECdCESIAhBA3QhCCAGKAIQIglBA3QhEyAJ\nQQJ0IRQgAkEUaigCAEECdCEVIAFBFGooAgBBAnQhFiAEQQN0IRcgBEECdCEYIAYoAgAhCSAFKAIA\nIQQgAigCACECIAEoAgAhAQNAIAIgEWoqAgAhGSABIBJqKgIAIRogAioCACEbIAQgASoCACIcOAIA\nIAQgGGogGjgCACAEIBdqQYCAgPwDNgIAIAQgCmogHDgCACAEIAtqIBo4AgAgBCAMakGAgID8AzYC\nACAEIA1qIBsgHIwiHJQ4AgAgBCAOaiAZIByUOAIAIAQgD2ogGyAajCIalDgCACAEIBBqIBkgGpQ4\nAgAgCSAbOAIAIAkgFGogGTgCACACIBVqIQIgASAWaiEBIAQgCGohBCAJIBNqIQkgA0F/aiIDDQAL\nCyAHIAUgBkEDELCAgIAAGgJAAkAgBygCACIEKgIAIhkgBCAHKAIQIglBBHRqKgIAIhqUIAQgCUEC\ndGoqAgAiGyAEIAlBFGxqKgIAIhyUIAQgCUEYbGoqAgAiHZSSIAQgCUEDdGoqAgAiHiAEIAlBDGxq\nKgIAIh+UIAQgCUEcbGoqAgAiIJSSIBsgH5STIBkgHJQgIJSTIB4gGpQgHZSTIiEQg4CAgAANAEMA\nAIA/ISIgIYu7RI3ttaD3xrA+Y0EBcw0BC0EAKgKAiICAACIZIRsgGSEeIBkhHyAZIRogGSEcIBkh\nHSAZISAgGSEiCyAAKAIAIgQgGTgCACAEIABBFGooAgAiCUECdGogGzgCACAEIAlBA3RqIB44AgAg\nBCAAKAIQIgJBAnRqIB84AgAgBCACIAlqIgFBAnRqIBo4AgAgBCACIAlBAXRqQQJ0aiAcOAIAIAQg\nAkEDdGogHTgCACAEIAkgAkEBdGpBAnRqICA4AgAgBCABQQN0aiAiOAIAIAcQl4CAgAAaIAYQl4CA\ngAAaIAUQl4CAgAAaIAALnwgKAX8BfQF/An0Bfwp9AX8BfQN/AX0CQAJAIAAoAghBA0cNACAAKAIM\nQQNHDQAgASgCCEECRw0AIAEoAgxBBEcNACACKAIIQQJHDQAgAigCDEEERg0BC0HZk4CAABCAgICA\nAAsgACABKAIAIgMqAgAiBCAEIAMgAUEUaigCACIFQQJ0aioCACIGkiADIAVBA3RqKgIAIgeSIAMg\nBUEDbCIIQQJ0aioCACIJkkMAAIA+lCIKkyIEQwAAAEEgAyAIIAEoAhAiAWpBAnRqKgIAIgsgCyAD\nIAFBAnRqKgIAIgwgAyAFIAFqQQJ0aioCACINkiADIAVBAXQgAWpBAnRqKgIAIg6SkkMAAIA+lCIP\nkyILIAuUIAkgCpMiCSAJlCAOIA+TIg4gDpQgByAKkyIHIAeUIA0gD5MiDSANlCAGIAqTIgYgBpQg\nBCAElCAMIA+TIgwgDJSSkpKSkpKSlZEiBJS7IAwgBJS7IAYgBJS7IA0gBJS7IAcgBJS7IA4gBJS7\nIAkgBJS7IAsgBJS7IAIoAgAiAyoCACILIAsgAyACQRRqKAIAIgVBAnRqKgIAIhCSIAMgBUEDdGoq\nAgAiDJIgAyAFQQNsIghBAnRqKgIAIg2SQwAAgD6UIgmTIgtDAAAAQSADIAggAigCECIBakECdGoq\nAgAiDiAOIAMgAUECdGoqAgAiESADIAUgAWpBAnRqKgIAIhKSIAMgBUEBdCABakECdGoqAgAiBpKS\nQwAAgD6UIg6TIgcgB5QgDSAJkyINIA2UIAYgDpMiBiAGlCAMIAmTIgwgDJQgEiAOkyISIBKUIBAg\nCZMiECAQlCALIAuUIBEgDpMiESARlJKSkpKSkpKVkSILlLsgESALlLsgECALlLsgEiALlLsgDCAL\nlLsgBiALlLsgDSALlLsgByALlLsQtYCAgAAgACgCACIDIABBFGooAgAiBUEBdCICIAAoAhAiAUEB\ndCIIakECdGoqAgAhECADIAggBWpBAnRqIggqAgAhByADIAIgAWpBAnRqIgIqAgAhESADIAVBA3Rq\nIhMqAgAhFCADIAUgAWoiFUECdGoiFioCACEGIAMgBUECdGoiBSoCACEMIAMgAUECdGoiFyoCACES\nIAMgBCAJIAMgAUEDdGoiASoCACINlCADKgIAIhhDAACAPyALlSILlJKUOAIAIBcgBCAOIA2UIBIg\nC5SSlDgCACABIAQgDZQ4AgAgBSAEIAkgB5QgDCALlJKUOAIAIBYgBCAOIAeUIAYgC5SSlDgCACAI\nIAQgB5Q4AgAgEyAUIAQgCiAYlCAPIAyUkpSTIAuUIAkgECAEIAogDZQgDyAHlJKUkyIHlJI4AgAg\nAiARIAQgCiASlCAPIAaUkpSTIAuUIA4gB5SSOAIAIAMgFUEDdGogBzgCACAAC5sCAQZ/AkACQCAA\nKAIIQQNHDQAgACgCDEEDRw0AIAEoAghBAkcNACABKAIMIgNBBEgNACACKAIIQQJHDQAgAigCDCAD\nRg0BC0GAlICAABCAgICAACABKAIMIQMLQQIgAxCSgICAACEEQQIgAxCSgICAACEFQQNBAxCSgICA\nACEGQQNBAxCSgICAACEHQQNBAxCSgICAACEIIAQgASAGQQNBAxCSgICAACIDEMGAgIAAIAUgAiAD\nIAcQwYCAgAAgAyAIIAQgBRC2gICAACIBIAYQp4CAgAAaIAAgByADEKeAgIAAGiADEJeAgIAAGiAB\nEJeAgIAAGiAHEJeAgIAAGiAGEJeAgIAAGiAFEJeAgIAAGiAEEJeAgIAAGiAAC/kFAhZ/Bn0CQAJA\nIAAoAghBAkcNACAAKAIMQQNHDQAgASgCCEECRw0AIAEoAgwiA0EDSA0AIAIoAghBAkcNACACKAIM\nIANGDQELQaeUgIAAEICAgIAAIAEoAgwhAwsgA0EBdCIEQQYQkoCAgAAhBSAEQQEQkoCAgAAhBkEG\nQQEQkoCAgAAhBwJAIANBAUgNACAFQRRqKAIAIgRBDGwgBSgCECIIQQJ0IglqIQogBEEEdCAJaiEL\nIARBFGwgCWohDCACKAIQQQJ0IQ0gASgCEEECdCEOIAhBA3QhDyAGKAIQIglBA3QhECAJQQJ0IREg\nAkEUaigCAEECdCESIAFBFGooAgBBAnQhEyAEQQN0IRQgBEECdCEVIAYoAgAhCSAFKAIAIQQgAigC\nACECIAEoAgAhAQNAIAIgDWooAgAhFiABIA5qKAIAIQggAigCACEXIAQgASgCACIYNgIAIAQgFWog\nCDYCACAEIBRqQYCAgPwDNgIAIAQgCmogGDYCACAEIAtqIAg2AgAgBCAMakGAgID8AzYCACAJIBc2\nAgAgCSARaiAWNgIAIAIgEmohAiABIBNqIQEgBCAPaiEEIAkgEGohCSADQX9qIgMNAAsLIAcgBSAG\nQQMQsICAgAAaAkACQCAHKAIAIgQqAgAiGSAEIAcoAhAiCUECdGoqAgAiGpIgBCAJQQN0aioCACIb\nkiAEIAlBDGxqKgIAIhySIAQgCUEEdGoqAgAiHZIgBCAJQRRsaioCACIekhCDgICAAA0AIBkgHZQg\nGiAclJOLu0SN7bWg98awPmNBAXMNAQtBACoCgIiAgAAiGSEaIBkhGyAZIRwgGSEdIBkhHgsgACgC\nACIEIBk4AgAgBCAAQRRqKAIAIglBAnRqIBo4AgAgBCAJQQN0aiAbOAIAIAQgACgCECICQQJ0aiAc\nOAIAIAQgAiAJakECdGogHTgCACAEIAIgCUEBdGpBAnRqIB44AgAgBxCXgICAABogBhCXgICAABog\nBRCXgICAABogAAvNBQMBfAJ/FXwCQAJAIAAoAghBAkcNACAAKAIMQQNHDQAgASgCCEECRw0AIAEo\nAgxBA0cNACACKAIIQQJHDQAgAigCDEEDRg0BC0HKlICAABCAgICAAAtBACoCgIiAgAC7IQMCQAJA\nIAEoAgAiBCABKAIQIgVBAnRqKgIAuyIGIAQgAUEUaigCACIBIAVqQQJ0aioCALsiB6EiCCAEIAFB\nA3RqKgIAuyIJoiAHIAQgAUEBdCAFakECdGoqAgC7IgqhIgsgBCoCALsiDKIgCiAGoSINIAQgAUEC\ndGoqAgC7Ig6ioKAiD5lEje21oPfGsD5jDQAgAigCACIEIAIoAhAiBUECdGoqAgC7IhAgBCACQRRq\nKAIAIgEgBWpBAnRqKgIAuyIRoSAEIAFBA3RqKgIAuyISoiARIAQgAUEBdCAFakECdGoqAgC7IhOh\nIAQqAgC7IhSiIBMgEKEgBCABQQJ0aioCALsiFaKgoJlEje21oPfGsD5jDQBEAAAAAAAA8D8gD6Mi\nFiALIBSiIA0gFaKgIAggEqKgoiIPIBYgCSAOoSIXIBCiIAwgCaEiGCARoqAgDiAMoSIZIBOioKIi\nGqIgFiAXIBSiIBggFaKgIBkgEqKgoiIXIBYgCyAQoiANIBGioCAIIBOioKIiCKKhmUSN7bWg98aw\nPmNBAXNFDQAgFiAOIAqiIAcgCaKhIgMgEKIgBiAJoiAMIAqioSIKIBGioCAMIAeiIAYgDqKhIgcg\nE6KgoiEGIBYgAyAUoiAKIBWioCAHIBKioKIhAwwBCyADIQ8gAyEXIAMhCCADIRogAyEGCyAAKAIA\nIgQgD7Y4AgAgBCAAQRRqKAIAIgFBAnRqIBe2OAIAIAQgAUEDdGogA7Y4AgAgBCAAKAIQIgVBAnRq\nIAi2OAIAIAQgBSABakECdGogGrY4AgAgBCAFIAFBAXRqQQJ0aiAGtjgCACAAC4EDAQl/AkACQCAA\nKAIIQQJHDQAgACgCDEEDRw0AIAEoAghBAkcNACABKAIMIgNBA0gNACACKAIIQQJHDQAgAigCDCAD\nRg0BC0HtlICAABCAgICAACABKAIMIQMLQQIgAxCSgICAACEEQQIgAxCSgICAACEFQQNBAxCSgICA\nACEGQQNBAxCSgICAACEHQQNBAxCUgICAACEIEJaAgIAAIAhBAEEBQQBBAhCagICAACEJQQNBAxCS\ngICAACEDQQNBAxCSgICAACEKEJaAgIAAIApBAEEBQQBBAhCagICAACELIAQgASAGIAMQwYCAgAAg\nBSACIAMgBxDBgICAACAJIAQgBRC5gICAACEBIAMgCCAGEKeAgIAAGiAKIAcgAxCngICAABogACAL\nEJWAgIAAGiALEJeAgIAAGiAKEJeAgIAAGiADEJeAgIAAGiABEJeAgIAAGiAIEJeAgIAAGiAHEJeA\ngIAAGiAGEJeAgIAAGiAFEJeAgIAAGiAEEJeAgIAAGiAAC5kUAhx/DX0jgICAgABBEGsiBySAgICA\nAAJAAkAgACgCCEEDRw0AIAAoAgxBA0cNACACKAIIQQJHDQAgAigCDCIIQQRIDQAgAygCCEECRw0A\nIAMoAgwgCEcNAAJAIAFFDQAgASgCCEEBRw0BIAEoAgwgCEcNAQsgBEEBSA0AIAVBAUgNACAGQwAA\nAABgDQELQZCVgIAAEICAgIAAIAIoAgwhCAsCQCABRQ0AIAFDAAAAABCbgICAABoLIAhBAnQiCUGy\nlYCAABCFgICAACEKIAlB0ZWAgAAQhYCAgAAgCBCNgICAACILIAhBBBCOgICAACAIIARBAnQiDCAI\nb2sgDGoiDUECdEHwlYCAABCFgICAACEOAkAgDUEBSA0AQQAhDyAIQQFIIRAgDiERA0ACQCAQDQBB\n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\nNgIACwv2EgMAQYAIC7ISAAD4f091dCBvZiBtZW1vcnkhAERvdWJsZSBmcmVlAEFzc2VydGlvbiBm\nYWlsZWQgYXQgbWF0MzIuYzo2MQBPdXQgb2YgbWVtb3J5IGF0IG1hdDMyLmM6NjMAQXNzZXJ0aW9u\nIGZhaWxlZCBhdCBtYXQzMi5jOjg0AE91dCBvZiBtZW1vcnkgYXQgbWF0MzIuYzo4NgBPdXQgb2Yg\nbWVtb3J5IGF0IG1hdDMyLmM6ODkAT3V0IG9mIG1lbW9yeSBhdCBtYXQzMi5jOjEzNgAAAGANAAAB\nAAAAAAAAAAAAAAABAAAAAQAAAAIAAABEb3VibGUgZnJlZSBhdCBtYXQzMi5jOjE0OQBBc3NlcnRp\nb24gZmFpbGVkIGF0IG1hdDMyLmM6MTg0AEFzc2VydGlvbiBmYWlsZWQgYXQgbWF0MzIuYzoxODgA\nQXNzZXJ0aW9uIGZhaWxlZCBhdCBtYXQzMi5jOjI3NQBEb3VibGUgZnJlZSBhdCBtYXQzMi5jOjI5\nAEFzc2VydGlvbiBmYWlsZWQgYXQgYXJpdGhtZXRpYzMyLmM6MzYAQXNzZXJ0aW9uIGZhaWxlZCBh\ndCBhcml0aG1ldGljMzIuYzo1OABBc3NlcnRpb24gZmFpbGVkIGF0IGFyaXRobWV0aWMzMi5jOjgw\nAEFzc2VydGlvbiBmYWlsZWQgYXQgYXJpdGhtZXRpYzMyLmM6OTkAQXNzZXJ0aW9uIGZhaWxlZCBh\ndCBhcml0aG1ldGljMzIuYzoxMjEAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzox\nNDMAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzoxNjgAQXNzZXJ0aW9uIGZhaWxl\nZCBhdCBhcml0aG1ldGljMzIuYzoxODkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIu\nYzoyMTgAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzoyNzEAQXNzZXJ0aW9uIGZh\naWxlZCBhdCBhcml0aG1ldGljMzIuYzozMjIAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGlj\nMzIuYzozNTYAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzozNzgAQXNzZXJ0aW9u\nIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzo0MjAAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1l\ndGljMzIuYzo0MzYAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6MjYxAEFzc2VydGlvbiBmYWls\nZWQgYXQgcXIzMi5jOjI2NQBBc3NlcnRpb24gZmFpbGVkIGF0IHFyMzIuYzoyODYAQXNzZXJ0aW9u\nIGZhaWxlZCBhdCBxcjMyLmM6MjkwAEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjMyMQBBc3Nl\ncnRpb24gZmFpbGVkIGF0IHFyMzIuYzozMjUAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6Mzc5\nAE91dCBvZiBtZW1vcnkgYXQgcXIzMi5jOjM2AEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjY5\nAEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjczAEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5j\nOjE4NABEb3VibGUgZnJlZSBhdCBxcjMyLmM6NTUAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6\nMTQ4AEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjIyNABBc3NlcnRpb24gZmFpbGVkIGF0IHFy\nMzIuYzoyMjgAQXNzZXJ0aW9uIGZhaWxlZCBhdCBob21vZ3JhcGh5MzIuYzoyNDQAQXNzZXJ0aW9u\nIGZhaWxlZCBhdCBob21vZ3JhcGh5MzIuYzoyODAAQXNzZXJ0aW9uIGZhaWxlZCBhdCBob21vZ3Jh\ncGh5MzIuYzozNTkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBob21vZ3JhcGh5MzIuYzo0NDQAQXNzZXJ0\naW9uIGZhaWxlZCBhdCBhZmZpbmUzMi5jOjExOQBBc3NlcnRpb24gZmFpbGVkIGF0IGFmZmluZTMy\nLmM6MTk2AEFzc2VydGlvbiBmYWlsZWQgYXQgYWZmaW5lMzIuYzoyMjkAQXNzZXJ0aW9uIGZhaWxl\nZCBhdCByYW5zYWMzMi5jOjcxAE91dCBvZiBtZW1vcnkgYXQgcmFuc2FjMzIuYzo4NABPdXQgb2Yg\nbWVtb3J5IGF0IHJhbnNhYzMyLmM6ODgAT3V0IG9mIG1lbW9yeSBhdCByYW5zYWMzMi5jOjkzAE91\ndCBvZiBtZW1vcnkgYXQgcmFuc2FjMzIuYzoxMDcARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIuYzoy\nMzYARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIuYzoyNDMARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIu\nYzoyNDYARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIuYzoyNDkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBy\nYW5zYWMzMi5jOjI3NQBPdXQgb2YgbWVtb3J5IGF0IHJhbnNhYzMyLmM6Mjg4AE91dCBvZiBtZW1v\ncnkgYXQgcmFuc2FjMzIuYzoyOTIAT3V0IG9mIG1lbW9yeSBhdCByYW5zYWMzMi5jOjI5NwBPdXQg\nb2YgbWVtb3J5IGF0IHJhbnNhYzMyLmM6MzExAERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6NDM2\nAERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6NDQzAERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6\nNDQ2AERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6NDQ5AEFzc2VydGlvbiBmYWlsZWQgYXQgdHJh\nbnNmb3JtMzIuYzozOQBBc3NlcnRpb24gZmFpbGVkIGF0IHRyYW5zZm9ybTMyLmM6NzcAQXNzZXJ0\naW9uIGZhaWxlZCBhdCB0cmFuc2Zvcm0zMi5jOjExNAAAQbQaCwwIAAAAUA0AAAEAAAAAQcAaCyQA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\n"}},t={};function i(n){var s=t[n];if(void 0!==s)return s.exports;var r=t[n]={exports:{}};return e[n](r,r.exports,i),r.exports}i.d=(e,t)=>{for(var n in t)i.o(t,n)&&!i.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{"use strict";i.r(n),i.d(n,{default:()=>S});var e=i("./src/gpu/speedy-gl.js"),t=i("./src/core/speedy-media.js"),s=i("./src/core/settings.js"),r=i("./src/utils/fps-counter.js"),o=(i("./src/core/speedy-vector.js"),i("./src/core/speedy-point.js")),a=i("./src/core/speedy-size.js"),c=i("./src/core/speedy-matrix-factory.js"),p=i("./src/core/speedy-promise.js"),l=i("./src/core/pipeline/pipeline.js"),A=i("./src/core/pipeline/factories/image-factory.js"),d=i("./src/core/pipeline/factories/filter-factory.js"),u=i("./src/core/pipeline/factories/transform-factory.js"),g=i("./src/core/pipeline/factories/keypoint-factory.js"),h=i("./src/core/pipeline/factories/vector2-factory.js"),I=i("./src/utils/utils.js"),m=i("./src/utils/globals.js");const f=new c.SpeedyMatrixFactory,y=new h.SpeedyPipelineVector2Factory;class S{static load(e,i={}){return t.SpeedyMedia.load(e,i)}static camera(e=640,i=360){const n="object"==typeof e?e:{audio:!1,video:{width:0|e,height:0|i}};return I.Utils.requestCameraStream(n).then((e=>t.SpeedyMedia.load(e)))}static isSupported(){return"undefined"!=typeof WebAssembly&&"undefined"!=typeof WebGL2RenderingContext&&null!=e.SpeedyGL.instance.gl}static get Vector2(){return y}static Point2(e,t){return new o.SpeedyPoint2(e,t)}static Size(e,t){return new a.SpeedySize(e,t)}static get Matrix(){return f}static get Promise(){return p.SpeedyPromise}static Pipeline(){return new l.SpeedyPipeline}static get Image(){return A.SpeedyPipelineImageFactory}static get Filter(){return d.SpeedyPipelineFilterFactory}static get Transform(){return u.SpeedyPipelineTransformFactory}static get Keypoint(){return g.SpeedyPipelineKeypointFactory}static get version(){return"0.9.0-wip-dev"}static get fps(){return r.FPSCounter.instance.fps}static get Settings(){return s.Settings}}Object.freeze(S),I.Utils.log(`Speedy Vision version ${S.version}. GPU-accelerated Computer Vision for JavaScript by Alexandre Martins. https://github.com/alemart/speedy-vision`),m.LITTLE_ENDIAN||I.Utils.warning("Running on a big-endian machine")})(),n=n.default})()},e.exports=t()}},t={};function i(n){var s=t[n];if(void 0!==s)return s.exports;var r=t[n]={exports:{}};return e[n](r,r.exports,i),r.exports}i.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return i.d(t,{a:t}),t},i.d=(e,t)=>{for(var n in t)i.o(t,n)&&!i.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var n={};return(()=>{"use strict";i.d(n,{default:()=>fe});var e=i(528),t=i.n(e);class s extends Error{constructor(e="",t=null){super(`${e}\n${t?t.toString():""}`),this.cause=t}get name(){return this.constructor.name}}class r extends s{}class o extends s{}class a extends s{}class c extends s{}class p extends s{}class l extends s{}class A extends s{}class d extends s{}const u={xs:120,"xs+":160,sm:200,"sm+":240,md:320,"md+":360,lg:480,"lg+":600};class g{static log(e,...t){console.log("[martins-js]",e,...t)}static warning(e,...t){console.warn("[martins-js]",e,...t)}static error(e,...t){console.error("[martins-js]",e,...t)}static assert(e,t=""){if(!e)throw new p(t)}static range(e){if((e|=0)<0)throw new r;return Array.from({length:e},((e,t)=>t))}static resolution(e,i){return function(e,i){const n=u[e];let s=0,r=0;return i>=1?(r=n,s=Math.round(r*i),s-=s%2):(s=n,r=Math.round(s/i),r-=r%2),t().Size(s,r)}(e,i)}}class h extends Event{constructor(e){super(e)}get type(){return super.type}}class I{constructor(){this._delegate=new EventTarget}addEventListener(e,t){this._delegate.addEventListener(e,t)}removeEventListener(e,t){this._delegate.removeEventListener(e,t)}dispatchEvent(e){return this._delegate.dispatchEvent(e)}}class m{constructor(e,t){if(this._container=t||this._createContainer(e),this._ownContainer=null==t,this._container.parentElement!==e)throw new r("The container of the HUD must be a direct child of the container of the viewport");this._container.hidden||g.warning("The container of the HUD should have the hidden attribute")}get container(){return this._container}get visible(){return!this._container.hidden}set visible(e){this._container.hidden=!e}_init(e){const t=this._container;t.style.position="absolute",t.style.left=t.style.top="0px",t.style.right=t.style.bottom="0px",t.style.padding=t.style.margin="0px",t.style.zIndex=String(e),t.style.userSelect="none"}_release(){this._ownContainer&&(this._ownContainer=!1,this._container.remove())}_createContainer(e){const t=document.createElement("div");return t.hidden=!0,e.appendChild(t),t}}class f extends h{}const y={container:null,hudContainer:null,resolution:"lg",canvas:null};class S extends I{constructor(e){super();const i=Object.assign({},y,e);if(null==i.container)throw new r("Unspecified viewport container");this._resolution=i.resolution,this._container=i.container,this._hud=new m(i.container,i.hudContainer),this._parentOfImportedForegroundCanvas=i.canvas?i.canvas.parentNode:null;const n=t().Size(300,150);this._backgroundCanvas=this._createBackgroundCanvas(this._container,n),this._foregroundCanvas=null==i.canvas?this._createForegroundCanvas(this._container,n):this._foregroundCanvas=this._importForegroundCanvas(i.canvas,this._container,n)}get container(){return this._container}get hud(){return this._hud}get resolution(){return this._resolution}get virtualSize(){const e=this._backgroundCanvas.width/this._backgroundCanvas.height;return g.resolution(this._resolution,e)}get canvas(){return this._foregroundCanvas}get _background(){return this._backgroundCanvas}get _size(){throw new o}_init(){this._container.style.touchAction="none",this._hud._init(2),this._hud.visible=!0}_release(){this._hud._release(),this._restoreImportedForegroundCanvas(),this._container.style.touchAction="auto"}_onResize(){const e=this.virtualSize;this._foregroundCanvas.width=e.width,this._foregroundCanvas.height=e.height,this._styleCanvas(this._foregroundCanvas,"foreground");const t=new f("resize");this.dispatchEvent(t)}_createBackgroundCanvas(e,t){const i=this._createCanvas(e,t);return this._styleCanvas(i,"background")}_createForegroundCanvas(e,t){const i=this._createCanvas(e,t);return this._styleCanvas(i,"foreground")}_createCanvas(e,t){const i=document.createElement("canvas");return i.width=t.width,i.height=t.height,e.appendChild(i),i}_styleCanvas(e,t){const i=0+("foreground"==t?1:0);return e.setAttribute("style",["position: absolute","left: 0px","top: 0px","z-index: "+String(i),"width: 100% !important","height: 100% !important"].join("; ")),e}_importForegroundCanvas(e,t,i){if(!(e instanceof HTMLCanvasElement))throw new r(`Not a <canvas>: ${e}`);return e.remove(),t.appendChild(e),e.width=i.width,e.height=i.height,e.dataset.cssText=e.style.cssText,e.style.cssText="",this._styleCanvas(e,"foreground"),e}_restoreImportedForegroundCanvas(){if(null==this._parentOfImportedForegroundCanvas)return;const e=this._foregroundCanvas;e.style.cssText=e.dataset.cssText||"",e.remove(),this._parentOfImportedForegroundCanvas.appendChild(e)}}class _ extends I{constructor(e,t){super(),this._base=e,this._getSize=t}get container(){return this._base.container}get hud(){return this._base.hud}get resolution(){return this._base.resolution}get virtualSize(){return this._base.virtualSize}get canvas(){return this._base.canvas}get _background(){return this._base._background}get _size(){return this._getSize()}_init(){this._base._init()}_release(){this._base._release()}_onResize(){this._base._onResize()}addEventListener(e,t){this._base.addEventListener(e,t)}removeEventListener(e,t){this._base.removeEventListener(e,t)}dispatchEvent(e){return this._base.dispatchEvent(e)}}class x extends _{constructor(e,t){super(e,t),this._active=!1}_init(){super._init(),this._active=!0;let e=null;const t=()=>{this._active?(null!==e&&clearTimeout(e),e=setTimeout((()=>{e=null,this._resize.call(this),this._onResize.call(this)}),100)):window.removeEventListener("resize",t)};window.addEventListener("resize",t),this._resize(),this._onResize()}_release(){this._active=!1,super._release()}}class C extends x{_release(){this.canvas.remove(),this._background.remove(),this.hud.visible=!1,this.container.style.cssText="",super._release()}_resize(){const{width:e,height:i}=this._size,n=t().Size(0,0),s=e/i,r=t().Size(window.innerWidth,window.innerHeight);s<=r.width/r.height?(n.height=r.height,n.width=n.height*s|0):(n.width=r.width,n.height=n.width/s|0);const o=this.container;o.style.position="fixed",o.style.left=`calc(50% - ${n.width>>>1}px)`,o.style.top=`calc(50% - ${n.height>>>1}px)`,o.style.zIndex="1000000000",o.style.width=n.width+"px",o.style.height=n.height+"px",o.style.backgroundColor="#000";const a=this._background,c=s,p=i;a.height=p,a.width=a.height*c|0}}class E extends x{_resize(){const{width:e,height:t}=this._size;this.container.style.position="relative",this.container.style.width=e+"px",this.container.style.height=t+"px",this._background.width=e,this._background.height=t}}class P{constructor(){this._timeOfLastUpdate=this._now(),this._partialCycleCount=0,this._cyclesPerSecond=0}update(){const e=this._now();++this._partialCycleCount,e>=this._timeOfLastUpdate+500&&(this._cyclesPerSecond=this._partialCycleCount/.5,this._partialCycleCount=0,this._timeOfLastUpdate=e)}reset(){this._timeOfLastUpdate=this._now(),this._partialCycleCount=0,this._cyclesPerSecond=0}get cyclesPerSecond(){return this._cyclesPerSecond}_now(){return performance.now()}}const v=Object.freeze({default:"","low-power":'<span style="color:#0f0">&#x1F50B</span>',"high-performance":'<span style="color:#ff0">&#x26A1</span>'});class B{constructor(e){this._container=this._createContainer(e),this._lastUpdate=0}release(){this._container.remove()}update(e,t,i,n,s){e>=this._lastUpdate+500&&(this._lastUpdate=e,this._update(t,i,s,n))}get visible(){return!this._container.hidden}set visible(e){this._container.hidden=!e}_update(e,t,i,n){const s=e.map((e=>e._stats)).join(", "),r=t.map((e=>e._stats)).join(", "),o={fps:this._colorize(i),gpu:this._colorize(n),powerIcon:v[z.powerPreference]};this._container.textContent=`MARTINS.js ${fe.edition}\n            Version ${fe.version}\n            FPS: [fps] | GPU: [gpu] [powerIcon]\n            IN : ${r}\n            OUT: ${s}`;this._container.innerHTML=this._container.innerHTML.replace(/\[(\w+)\]/g,((e,t)=>o[t]))}_colorize(e){const t="#0f0",i="#f33",n=e>=50?t:e>=30?"#ff0":i,s=e>=30?t:i;return`<span style="color:${"low-power"!=z.powerPreference?n:s}">${Number(e)}</span>`}_createContainer(e){const t=document.createElement("div");return t.style.position="absolute",t.style.left=t.style.top="0px",t.style.zIndex="1000000",t.style.padding="4px",t.style.whiteSpace="pre-line",t.style.backgroundColor="rgba(0,0,0,0.5)",t.style.color="#fff",t.style.fontFamily="monospace",t.style.fontSize="14px",e.appendChild(t),t}}class M{constructor(e){this._results=e,this._index=0}next(){const e=this._index++;return e<this._results.length?{done:!1,value:this._results[e]}:{done:!0,value:void 0}}[Symbol.iterator](){return this}}class w{constructor(e,t){this._session=e,this._results=new M(t)}get session(){return this._session}get results(){return this._results}}class b{constructor(){this._scale=1,this._time=0,this._unscaledTime=0,this._delta=0,this._firstUpdate=0,this._lastUpdate=Number.POSITIVE_INFINITY}_update(e){e<this._lastUpdate?this._firstUpdate=this._lastUpdate=e:(this._delta=(e-this._lastUpdate)*this._scale,this._time+=this._delta,this._unscaledTime=e-this._firstUpdate,this._lastUpdate=e)}get elapsed(){return.001*this._time}get delta(){return.001*this._delta}get scale(){return this._scale}set scale(e){this._scale=Math.max(0,+e)}get unscaled(){return.001*this._unscaledTime}}class Q{constructor(){this._visible=!1}get visible(){return this._visible}set visible(e){this._visible=e}_render(e,t){if(!this._visible)return;const i=e._size,n=e._background.getContext("2d",{alpha:!1});if(!n)throw new o;for(let e=0;e<t.length;e++){if("image-tracker"!=t[e].type)continue;const s=t[e]._output,r=s.keypoints,o=s.screenSize;void 0!==r&&void 0!==o&&this._splitAndRenderKeypoints(n,r,o,i)}for(let e=0;e<t.length;e++){if("image-tracker"!=t[e].type)continue;const s=t[e]._output,r=s.polyline,o=s.screenSize;void 0!==r&&void 0!==o&&this._renderPolyline(n,r,o,i)}for(let e=0;e<t.length;e++){if("image-tracker"!=t[e].type)continue;const s=t[e]._output,r=s.cameraMatrix,o=s.screenSize;void 0!==r&&void 0!==o&&this._renderAxes(n,r,o,i)}}_splitAndRenderKeypoints(e,t,i,n,s=1){if(0==t.length)return;if(!Object.prototype.hasOwnProperty.call(t[0],"_matches"))return void this._renderKeypoints(e,t,i,n,"#f00",s);const r=e=>1==e.matches.length&&e.matches[0].index>=0||e.matches.length>1&&e.matches[0].index>=0&&e.matches[1].index>=0&&e.matches[0].distance<=.7*e.matches[1].distance,o=t,a=o.filter((e=>r(e))),c=o.filter((e=>!r(e)));this._renderKeypoints(e,c,i,n,"#f00",s),this._renderKeypoints(e,a,i,n,"#0f0",s)}_renderKeypoints(e,t,i,n,s="red",r=1){const o=n.width/i.width,a=n.height/i.height;e.beginPath();for(let i=t.length-1;i>=0;i--){const n=t[i],s=n.x*o+.5|0,c=n.y*a+.5|0,p=r*n.scale+.5|0;e.rect(s-p,c-p,2*p,2*p)}e.strokeStyle=s,e.lineWidth=1,e.stroke()}_renderPolyline(e,t,i,n,s="#0f0",r=2){if(0==t.length)return;const o=t.length,a=n.width/i.width,c=n.height/i.height;e.beginPath(),e.moveTo(t[o-1].x*a,t[o-1].y*c);for(let i=0;i<o;i++)e.lineTo(t[i].x*a,t[i].y*c);e.strokeStyle=s,e.lineWidth=r,e.stroke()}_renderAxes(e,t,i,n,s=4){const r=["#f00","#0f0","#00f"],o=n.width/i.width,a=n.height/i.height,c=t.read(),p=[c[9],c[10],c[11]],l=[[1*c[0]+c[9],1*c[1]+c[10],1*c[2]+c[11]],[1*c[3]+c[9],1*c[4]+c[10],1*c[5]+c[11]],[1*c[6]+c[9],1*c[7]+c[10],1*c[8]+c[11]]],A=p[0]/p[2],d=p[1]/p[2];for(let t=0;t<3;t++){const i=l[t],n=i[0]/i[2],c=i[1]/i[2];e.beginPath(),e.moveTo(A*o,d*a),e.lineTo(n*o,c*a),e.strokeStyle=r[t],e.lineWidth=s,e.stroke()}}}const k=[],D=[],K="asap"+Math.random().toString(36).substr(1);window.addEventListener("message",(e=>{if(e.source!==window||e.data!==K)return;if(e.stopPropagation(),0==k.length)return;const t=k.pop(),i=D.pop();t.apply(void 0,i)}),!0);class T extends h{}const N={mode:"immersive",trackers:[],sources:[],viewport:null,stats:!1,gizmos:!1};class L extends I{constructor(e,t,i,n,s){super(),this._mode=t,this._trackers=[],this._sources=e,this._updateStats=new P,this._renderStats=new P,this._active=!0,this._frameReady=!0,this._rafQueue=[],this._time=new b,this._gizmos=new Q,this._gizmos.visible=s;const o=this.media;if("immersive"==t)this._viewport=new C(i,(()=>o.size));else{if("inline"!=t)throw new r(`Invalid session mode "${t}"`);this._viewport=new E(i,(()=>o.size))}this._viewport._init(),this._setupUpdateLoop(),this._setupRenderLoop(),this._statsPanel=new B(this._viewport.hud.container),this._statsPanel.visible=n,L._count++,g.log(`The ${t} session is now active!`)}static isSupported(){return t().isSupported()}static instantiate(e=N){const{mode:i=N.mode,sources:n=N.sources,trackers:s=N.trackers,viewport:c=N.viewport,stats:p=N.stats,gizmos:l=N.gizmos}=e;return g.log(`Starting a new ${i} session...`),t().Promise.resolve().then((()=>{if(!L.isSupported())throw new a("You need a browser/device compatible with WebGL2 and WebAssembly in order to experience Augmented Reality with the MARTINS.js engine");if("inline"!==i&&L.count>0)throw new o("Can't start more than one immersive session");return t().Matrix.ready()})).then((()=>{if(1!=n.filter((e=>"video"==e._type)).length)throw new r("One video source of data must be provided");for(let e=n.length-1;e>=0;e--)if(n.indexOf(n[e])<e)throw new r("Found repeated sources of data");return t().Promise.all(n.map((e=>e._init())))})).then((()=>{if(!c)throw new r("Can't create a session without a viewport");return new L(n,i,c,p,l)})).then((e=>{0==s.length&&g.warning("No trackers have been attached to the session!");for(let e=s.length-1;e>=0;e--)if(s.indexOf(s[e])<e)throw new r("Found repeated trackers");return t().Promise.all(s.map((t=>e._attachTracker(t)))).then((()=>e))})).catch((e=>{throw g.error(`Can't start session: ${e.message}`),e}))}static get count(){return this._count}end(){if(!this._active)return t().Promise.resolve();g.log("Shutting down the session..."),this._active=!1;return(e=100,new(t().Promise)((t=>{setTimeout(t,e)}))).then((()=>t().Promise.all(this._trackers.map((e=>e._release()))))).then((()=>t().Promise.all(this._sources.map((e=>e._release()))))).then((()=>{this._sources.length=0,this._trackers.length=0,this._updateStats.reset(),this._renderStats.reset(),this._statsPanel.release(),this._viewport._release(),L._count--;const e=new T("end");this.dispatchEvent(e),g.log("Session ended.")}));var e}requestAnimationFrame(e){const t=Symbol("raf-handle");if(!this._active)throw new o("Can't requestAnimationFrame(): session ended.");return this._rafQueue.push([t,e]),t}cancelAnimationFrame(e){for(let t=this._rafQueue.length-1;t>=0;t--)if(this._rafQueue[t][0]===e){this._rafQueue.splice(t,1);break}}get media(){for(let e=this._sources.length-1;e>=0;e--)if("video"==this._sources[e]._type)return this._sources[e]._data;throw new o("Invalid input source")}get mode(){return this._mode}get viewport(){return this._viewport}get time(){return this._time}get gizmos(){return this._gizmos}_attachTracker(e){if(this._trackers.indexOf(e)>=0)throw new r("Duplicate tracker attached to the session");if(!this._active)throw new o("Inactive session");return this._trackers.push(e),e._init(this)}_renderUserMedia(){const e=this._viewport._background,t=e.getContext("2d",{alpha:!1});if(t){t.imageSmoothingEnabled=!1;const i=this.media.source;t.drawImage(i,0,0,e.width,e.height);for(let i=0;i<this._trackers.length;i++){const n=this._trackers[i]._output.image;void 0!==n&&t.drawImage(n.source,0,0,e.width,e.height)}this._gizmos._render(this._viewport,this._trackers)}}_setupUpdateLoop(){const e=()=>{this._active&&("high-performance"==z.powerPreference?function(e,...t){k.unshift(e),D.unshift(t),window.postMessage(K,"*")}(i):window.requestAnimationFrame(i))},t=()=>{this._update().then(e).turbocharge()};function i(){"low-power"==z.powerPreference?window.requestAnimationFrame(t):t()}window.requestAnimationFrame(t)}_update(){return this._active?t().Promise.all(this._trackers.map((e=>e._update().turbocharge()))).then((()=>{this._updateStats.update(),this._frameReady=!0})).catch((e=>{g.warning("Tracking error: "+e.toString())})):(this._updateStats.reset(),t().Promise.resolve())}_setupRenderLoop(){let e=!1;const t=i=>{const n="low-power"==z.powerPreference;z.powerPreference;this._time._update(i),n&&(e=!e)||this._render(i,!1),this._active&&window.requestAnimationFrame(t)};window.requestAnimationFrame(t)}_render(e,t){if(this._active)if(this._frameReady){const i=this._trackers.map((e=>e._output.exports||{tracker:e,trackables:[]})),n=new w(this,i),s=this._rafQueue.slice(0);this._rafQueue.length=0,t||this._renderUserMedia();for(let t=0;t<s.length;t++)s[t][1].call(void 0,e,n);this._renderStats.update(),this._statsPanel.update(e,this._trackers,this._sources,this._updateStats.cyclesPerSecond,this._renderStats.cyclesPerSecond),this._frameReady=!1}else this._renderStats.update();else this._renderStats.reset()}}L._count=0;class z{static get powerPreference(){return this._powerPreference}static set powerPreference(e){if(L.count>0)throw new o("Can't change the powerPreference while there are active sessions going on");if("low-power"!=e&&"default"!=e&&"high-performance"!=e)throw new r(`Invalid powerPreference: "${e}"`);t().Settings.gpuPollingMode="high-performance"==e?"asap":"raf",this._powerPreference=e,g.log(`Changed the powerPreference to "${this._powerPreference}"`)}}z._powerPreference="default";class R{constructor(){this._capacity=100,this._database=[],this._locked=!1}get count(){return this._database.length}get capacity(){return this._capacity}*[Symbol.iterator](){const e=this._database.map((e=>e.referenceImage));yield*e}add(e){if(0==e.length)return t().Promise.resolve();if(e.length>1){const i=e.map((e=>this.add([e])));return t().Promise.all(i).then((()=>{}))}const i=e[0];if(this._locked)throw new o("Can't add reference image to the database: it's locked");if(this.count>=this.capacity)throw new o(`Can't add reference image to the database: the capacity of ${this.capacity} images has been exceeded.`);if(void 0!==this._database.find((e=>e.referenceImage.name===i.name)))throw new r(`Can't add reference image to the database: found duplicated name "${i.name}"`);return t().load(i.image).then((e=>{this._database.push({referenceImage:Object.freeze(Object.assign(Object.assign({},i),{name:i.name||"target-"+Math.random().toString(16).substr(2)})),media:e})}))}_lock(){this._locked=!0}_findMedia(e){for(let t=0;t<this._database.length;t++)if(this._database[t].referenceImage.name===e)return this._database[t].media;throw new r(`Can't find reference image "${e}"`)}}const O=1024,F=.3,j=.5,X="low",U="bilinear-upsample",G=.18;class H{constructor(e,t){this._name=e,this._imageTracker=t,this._pipeline=this._createPipeline()}get name(){return this._name}get screenSize(){const e=this._pipeline.node("screen");if(!e)throw new o;return e.size}init(){}release(){return this._pipeline.release()}update(e,t){const i=this._pipeline.node("source"),n=this._pipeline.node("screen");if(!i||!n)throw new o;return i.media=e,n.size=t,this._beforeUpdate().then((()=>this._gpuUpdate())).then((e=>this._afterUpdate(e)))}onEnterState(e){}onLeaveState(){}_beforeUpdate(){return t().Promise.resolve()}_gpuUpdate(){return this._pipeline.run()}_findPolylineCoordinates(e,i){const n=i.width,s=i.height,r=t().Matrix(2,4,[0,0,n,0,n,s,0,s]),o=t().Matrix.Zeros(2,4);return t().Matrix.applyPerspectiveTransform(o,r,e)}_findPolyline(e,i){return this._findPolylineCoordinates(e,i).then((e=>{const i=e.read();return Array.from({length:4},((e,n)=>t().Point2(i[2*n],i[2*n+1])))}))}_mustRotateWarpedImage(e,t){const i=t.width/t.height,n=e.width/e.height;return n>=1.1&&i<.9||n<.9&&i>=1.1}_findRectificationMatrixOfFullscreenImage(e,i){const n=.15,s=i.width,r=i.height,o=e.width/e.height,a=this._mustRotateWarpedImage(e,i),c=a?1/o:o,p=s>=r?n*r:(r-.7*s/c)/2,l=s>=r?(s-.7*r*c)/2:n*s,A=s-l,d=r-p,u=t().Matrix(2,4,[l,p,A,p,A,d,l,d]),g=t().Matrix(2,4,[0,0,s,0,s,r,0,r]),h=t().Matrix.Eye(3),I=t().Matrix.Zeros(3),m=t().Matrix.Zeros(3);return(a?t().Matrix.perspective(h,g,t().Matrix(2,4,[0,r,0,0,s,0,s,r])):t().Promise.resolve(h)).then((e=>t().Matrix.perspective(I,g,u))).then((e=>m.setTo(I.times(h))))}_findRectificationMatrixOfCameraImage(e,i,n,s){const r=s.width,o=s.height,a=t().Matrix(2,4,[0,0,r,0,r,o,0,o]),c=t().Matrix.Zeros(3);return this._findPolylineCoordinates(e,i).then((e=>t().Matrix.perspective(c,e,a))).then((e=>this._findRectificationMatrixOfFullscreenImage(n,s))).then((e=>c.setTo(e.times(c))))}}class W extends H{constructor(e){super("initial",e)}_beforeUpdate(){return this._pipeline.node("source").media.size.area()<this.screenSize.area()&&g.warning("The resolution of the tracker is larger than the resolution of the video. This is inefficient."),t().Promise.resolve()}_afterUpdate(e){return t().Promise.resolve({nextState:"training",trackerOutput:{}})}_createPipeline(){const e=t().Pipeline(),i=t().Image.Source("source"),n=t().Transform.Resize("screen"),s=t().Filter.Greyscale(),r=t().Transform.PerspectiveWarp(),o=t().Filter.Nightvision(),a=t().Image.Multiplexer(),c=t().Keypoint.Detector.Harris(),p=t().Keypoint.Descriptor.ORB(),l=t().Filter.GaussianBlur(),A=t().Keypoint.Clipper(),d=t().Keypoint.BorderClipper(),u=t().Filter.GaussianBlur(),g=t().Keypoint.SubpixelRefiner(),h=t().Keypoint.Matcher.BFKNN(),I=t().Keypoint.Transformer(),m=t().Keypoint.Portal.Sink(),f=t().Keypoint.Portal.Source(),y=t().Keypoint.Multiplexer(),S=t().Keypoint.Buffer(),_=t().Keypoint.Multiplexer(),x=t().Keypoint.SinkOfMatchedKeypoints();return i.media=null,n.size=t().Size(0,0),r.transform=t().Matrix.Eye(3),o.quality=X,g.method=U,d.imageSize=t().Size(100,100),d.borderSize=t().Vector2(0,0),h.k=1,I.transform=t().Matrix.Eye(3),f.source=m,y.port=0,_.port=0,S.frozen=!1,x.turbo=!1,i.output().connectTo(n.input()),n.output().connectTo(s.input()),s.output().connectTo(r.input()),r.output().connectTo(a.input("in0")),r.output().connectTo(o.input()),o.output().connectTo(a.input("in1")),a.output().connectTo(l.input()),a.output().connectTo(c.input()),c.output().connectTo(d.input()),d.output().connectTo(A.input()),r.output().connectTo(u.input()),u.output().connectTo(g.input("image")),A.output().connectTo(g.input("keypoints")),l.output().connectTo(p.input("image")),g.output().connectTo(p.input("keypoints")),p.output().connectTo(y.input("in0")),_.output().connectTo(y.input("in1")),y.output().connectTo(h.input("database")),p.output().connectTo(h.input("keypoints")),f.output().connectTo(_.input("in0")),S.output().connectTo(_.input("in1")),f.output().connectTo(S.input()),p.output().connectTo(m.input()),p.output().connectTo(I.input()),I.output().connectTo(x.input()),h.output().connectTo(x.input("matches")),e.init(i,n,s,r,o,a,l,c,g,A,d,u,p,f,y,h,S,_,I,x,m),e}}class q extends H{constructor(e){super("training",e),this._currentImageIndex=0,this._image=[],this._trainingMap={referenceImageIndex:[],referenceImage:[],keypoints:[]}}onEnterState(e){const t=this._imageTracker.database;if(0==t.count)throw new d("Can't train the Image Tracker: the Reference Image Database is empty");this._currentImageIndex=0,this._image.length=0,this._trainingMap.referenceImageIndex.length=0,this._trainingMap.referenceImage.length=0,this._trainingMap.keypoints.length=0,g.log(`Image Tracker: training using ${t.count} reference image${1!=t.count?"s":""}`),t._lock();for(const e of t)this._image.push(e)}_beforeUpdate(){this.screenSize;const e=this._pipeline.node("source"),i=this._pipeline.node("screen"),n=this._pipeline.node("keypointScaler");if(this._currentImageIndex>=this._image.length)return t().Promise.reject(new o);const s=this._imageTracker.database,r=this._image[this._currentImageIndex],a=s._findMedia(r.name);e.media=a;const c=this._imageTracker.resolution,p=a.width/a.height;i.size=g.resolution(c,p),i.size.width=Math.round(.8*i.size.width),i.size.height=Math.round(.8*i.size.height);const l=O/i.size.width,A=O/i.size.height;return n.transform=t().Matrix(3,3,[l,0,0,0,A,0,0,0,1]),g.log(`Image Tracker: training using reference image "${r.name}" at ${i.size.width}x${i.size.height}...`),t().Promise.resolve()}_afterUpdate(e){const i=this._image[this._currentImageIndex],n=e.keypoints;e.image;g.log(`Image Tracker: found ${n.length} keypoints in reference image "${i.name}"`),this._trainingMap.referenceImage.push(i);for(let e=0;e<n.length;e++)this._trainingMap.keypoints.push(n[e]),this._trainingMap.referenceImageIndex.push(this._currentImageIndex);return++this._currentImageIndex,this._currentImageIndex>=this._image.length?t().Promise.resolve({nextState:"scanning",nextStateSettings:{keypoints:this._trainingMap.keypoints},trackerOutput:{}}):t().Promise.resolve({nextState:"training",trackerOutput:{}})}_createPipeline(){const e=t().Pipeline(),i=t().Image.Source("source"),n=t().Transform.Resize("screen"),s=t().Filter.Greyscale(),r=t().Filter.GaussianBlur(),o=t().Filter.Nightvision(),a=t().Image.Multiplexer("nightvisionMux"),c=t().Image.Pyramid(),p=t().Keypoint.Detector.FAST("fast"),l=t().Keypoint.Descriptor.ORB(),A=t().Keypoint.SubpixelRefiner(),d=t().Image.Pyramid(),u=t().Filter.GaussianBlur(),g=t().Keypoint.Clipper(),h=t().Keypoint.Transformer("keypointScaler"),I=t().Keypoint.Sink("keypoints"),m=t().Image.Sink("image");return i.media=null,n.size=t().Size(0,0),r.kernelSize=t().Size(9,9),r.sigma=t().Vector2(2,2),o.gain=F,o.offset=j,o.decay=0,o.quality=X,a.port=1,p.levels=4,p.scaleFactor=1.19,p.threshold=60,p.capacity=8192,A.method=U,u.kernelSize=t().Size(5,5),u.sigma=t().Vector2(1,1),g.size=1024,h.transform=t().Matrix.Eye(3),I.turbo=!1,i.output().connectTo(n.input()),n.output().connectTo(s.input()),s.output().connectTo(a.input("in0")),s.output().connectTo(o.input()),o.output().connectTo(a.input("in1")),a.output().connectTo(c.input()),c.output().connectTo(p.input()),p.output().connectTo(g.input()),s.output().connectTo(u.input()),u.output().connectTo(d.input()),g.output().connectTo(A.input("keypoints")),d.output().connectTo(A.input("image")),s.output().connectTo(r.input()),r.output().connectTo(l.input("image")),g.output().connectTo(l.input("keypoints")),l.output().connectTo(h.input()),h.output().connectTo(I.input()),a.output().connectTo(m.input()),e.init(i,n,s,o,a,c,p,r,l,g,u,d,A,h,I,m),e}referenceImageOfKeypoint(e){const t=this.referenceImageIndexOfKeypoint(e);return t<0?null:this._trainingMap.referenceImage[t]}referenceImageIndexOfKeypoint(e){const t=this._trainingMap.referenceImageIndex.length;if(e<0||e>=t)return-1;const i=this._trainingMap.referenceImageIndex[e];return i<0||i>=this._trainingMap.referenceImage.length?-1:i}referenceKeypoint(e){return e<0||e>=this._trainingMap.keypoints.length?null:this._trainingMap.keypoints[e]}}const Y=t().Size(O,O);class J extends H{constructor(e){super("scanning",e),this._counter=0,this._bestScore=0,this._bestHomography=t().Matrix.Eye(3)}onEnterState(e){const t=this._pipeline.node("imagePortalMux"),i=this._pipeline.node("lshTables"),n=e.keypoints;this._counter=0,this._bestScore=0,t.port=0,void 0!==n&&(i.keypoints=n)}_afterUpdate(e){const i=this._pipeline.node("imagePortalMux"),n=e.keypoints,s=this._goodMatches(n),r={keypoints:n,screenSize:this.screenSize};return i.port=1,s.length>=20?this._findHomography(s).then((([e,t])=>(t>=this._bestScore&&this._counter<29&&(this._bestScore=t,this._bestHomography=e,i.port=0),this._findPolyline(e,Y)))).then((e=>{if(++this._counter<30)return{nextState:this.name,trackerOutput:Object.assign({polyline:e},r)};const t=this._pipeline.node("imagePortalSink"),i=this._imageTracker._referenceImageOfKeypoint(s[0].matches[0].index);return{nextState:"pre-tracking",nextStateSettings:{homography:this._bestHomography,snapshot:t,referenceImage:i},trackerOutput:Object.assign({polyline:e},r)}})).catch((()=>({nextState:this.name,trackerOutput:r}))):(this._counter=0,this._bestScore=0,t().Promise.resolve({nextState:this.name,trackerOutput:r}))}_goodMatches(e){const t=Object.create(null);for(let i=e.length-1;i>=0;i--){const n=e[i];if(n.matches[0].index>=0&&n.matches[1].index>=0){if(n.matches[0].distance<=.7*n.matches[1].distance){const e=this._imageTracker._referenceImageIndexOfKeypoint(n.matches[0].index);e>=0&&(Object.prototype.hasOwnProperty.call(t,e)||(t[e]=[]),t[e].push(n))}}}let i=[];for(const e in t)t[e].length>i.length&&(i=t[e]);return i}_findHomography(e){const i=[],n=[];for(let s=e.length-1;s>=0;s--){const r=e[s],o=this._imageTracker._referenceKeypoint(r.matches[0].index);if(null==o)return t().Promise.reject(new A(`Invalid keypoint match index: ${r.matches[0].index} from ${r.toString()}`));i.push(o.x),i.push(o.y),n.push(r.x),n.push(r.y)}const s=i.length/2;if(s<4)return t().Promise.reject(new A("Too few points to compute a homography"));const r=t().Matrix(2,s,i),o=t().Matrix(2,s,n),a=t().Matrix.Zeros(1,s),c=t().Matrix.Zeros(3);return t().Matrix.findHomography(c,r,o,{method:"pransac",reprojectionError:5,numberOfHypotheses:512,bundleSize:128,mask:a}).then((e=>{const t=e.at(0,0);if(Number.isNaN(t))throw new A("Can't compute homography");const i=a.read();let n=0;for(let e=i.length-1;e>=0;e--)n+=i[e];return[e,n/i.length]}))}_createPipeline(){const e=t().Pipeline(),i=t().Image.Source("source"),n=t().Transform.Resize("screen"),s=t().Filter.Greyscale(),r=t().Filter.GaussianBlur(),o=t().Filter.Nightvision(),a=t().Image.Multiplexer("nightvisionMux"),c=t().Image.Pyramid(),p=t().Keypoint.Detector.FAST(),l=t().Keypoint.Descriptor.ORB(),A=t().Keypoint.Clipper(),d=t().Keypoint.Matcher.StaticLSHTables("lshTables"),u=t().Keypoint.Matcher.LSHKNN(),g=t().Keypoint.SinkOfMatchedKeypoints("keypoints"),h=t().Image.Portal.Sink("imagePortalSink"),I=t().Image.Portal.Source("imagePortalSource"),m=t().Image.Multiplexer("imagePortalMux"),f=t().Image.Buffer(),y=t().Transform.Resize();return i.media=null,n.size=t().Size(0,0),r.kernelSize=t().Size(9,9),r.sigma=t().Vector2(2,2),o.gain=F,o.offset=j,o.decay=0,o.quality=X,a.port=1,p.levels=4,p.scaleFactor=1.19,p.threshold=60,p.capacity=2048,A.size=512,d.keypoints=[],d.numberOfTables=8,d.hashSize=15,u.k=2,u.quality="default",I.source=h,m.port=0,y.size=t().Size(0,0),y.scale=t().Vector2(1,1),g.turbo=!0,i.output().connectTo(n.input()),n.output().connectTo(s.input()),s.output().connectTo(r.input()),s.output().connectTo(a.input("in0")),s.output().connectTo(o.input()),o.output().connectTo(a.input("in1")),a.output().connectTo(c.input()),c.output().connectTo(p.input()),p.output().connectTo(A.input()),r.output().connectTo(l.input("image")),A.output().connectTo(l.input("keypoints")),l.output().connectTo(u.input("keypoints")),d.output().connectTo(u.input("lsh")),A.output().connectTo(g.input()),u.output().connectTo(g.input("matches")),i.output().connectTo(f.input()),f.output().connectTo(m.input("in0")),I.output().connectTo(y.input()),y.output().connectTo(m.input("in1")),m.output().connectTo(h.input()),e.init(i,n,s,r,o,a,c,p,l,A,d,u,g,h,I,m,f,y),e}}const Z=t().Size(O,O);class $ extends H{constructor(e){super("pre-tracking",e),this._homography=t().Matrix.Eye(3),this._referenceImage=null,this._step="read-reference-image",this._referenceKeypoints=[],this._iterations=0}onEnterState(e){const t=this._pipeline.node("imagePortalSource"),i=this._pipeline.node("muxOfReferenceKeypoints"),n=this._pipeline.node("muxOfBufferOfReferenceKeypoints"),s=this._pipeline.node("bufferOfReferenceKeypoints"),r=e.homography,o=e.referenceImage,a=e.snapshot;if(!o)throw new l("Can't track a null reference image");this._homography=r,this._referenceImage=o,this._step="read-reference-image",this._referenceKeypoints=[],this._iterations=0,t.source=a,i.port=0,n.port=0,s.frozen=!1}_beforeUpdate(){const e=this._referenceImage,i=this._pipeline.node("source"),n=this._pipeline.node("sourceMux"),s=this._pipeline.node("imageRectifier"),r=(this._pipeline.node("keypointRectifier"),this._pipeline.node("borderClipper")),o=this.screenSize,a=this._imageTracker.database._findMedia(e.name);i.media=a,"read-reference-image"==this._step?n.port=0:n.port=1,r.imageSize=o,r.borderSize=t().Vector2(o.width*G,o.height*G);return("read-reference-image"==this._step?this._findRectificationMatrixOfFullscreenImage(a,o):this._findRectificationMatrixOfCameraImage(this._homography,Z,a,o)).then((e=>{s.transform=e}))}_afterUpdate(e){const i=this._referenceImage,n=this._pipeline.node("imagePortal"),s=this._pipeline.node("keypointPortalSink"),r=this._pipeline.node("muxOfReferenceKeypoints"),o=this._pipeline.node("muxOfBufferOfReferenceKeypoints"),a=this._pipeline.node("bufferOfReferenceKeypoints"),c=e.keypoints,p=e.image,l={keypoints:void 0!==p?c:void 0,image:p,screenSize:this.screenSize};switch(this._step){case"read-reference-image":return r.port=1,this._referenceKeypoints=c,this._step="warp-camera-image",t().Promise.resolve({nextState:"pre-tracking",trackerOutput:l});case"warp-camera-image":return a.frozen=!0,o.port=1,++this._iterations<3?this._step="warp-camera-image":this._step="train-camera-image",this._findWarp(c,this._referenceKeypoints).then((e=>this._homography.setTo(this._homography.times(e)))).then((e=>({nextState:"pre-tracking",trackerOutput:l}))).catch((e=>(g.warning(`Can't pre-track target image "${i.name}". ${e.toString()}`),{nextState:"scanning",trackerOutput:l})));case"train-camera-image":return g.log(`Took a snapshot of target image "${i.name}". Found ${c.length} keypoints.`),this._changeSpace(this._homography,this.screenSize).then((e=>t().Promise.resolve({nextState:"tracking",trackerOutput:l,nextStateSettings:{homography:e,referenceImage:i,templateKeypoints:c,keypointPortalSink:s,imagePortalSink:n,screenSize:this.screenSize}})))}}_findWarp(e,i){const n=[],s=[];for(let t=0;t<e.length;t++){const r=e[t];if(r.matches[0].index>=0&&r.matches[1].index>=0){if(r.matches[0].distance<=.75*r.matches[1].distance){const e=i[r.matches[0].index];n.push(e.x),n.push(e.y),s.push(r.x),s.push(r.y)}}}const r=n.length/2;if(r<4)return t().Promise.reject(new l("Too few points to compute a warp"));const o=t().Matrix.Eye(3);return this._findKeypointWarp().then((e=>t().Matrix.applyAffineTransform(t().Matrix.Zeros(2,2*r),t().Matrix(2,2*r,n.concat(s)),e.block(0,1,0,2)))).then((e=>t().Matrix.findAffineTransform(o.block(0,1,0,2),e.block(0,1,0,r-1),e.block(0,1,r,2*r-1),{method:"pransac",reprojectionError:3,numberOfHypotheses:2048,bundleSize:128}))).then((e=>{const t=o.at(0,0);if(Number.isNaN(t))throw new l("Can't compute warp: bad keypoints");return o}))}_findKeypointWarp(){const e=this._referenceImage,i=this._imageTracker.database._findMedia(e.name),n=this.screenSize;if(!this._mustRotateWarpedImage(i,n))return t().Promise.resolve(t().Matrix.Eye(3));const s=n.width/2,r=n.height/2;return t().Promise.resolve(t().Matrix(3,3,[0,1,0,-1,0,0,r+s,r-s,1]))}_changeSpace(e,i){const n=i.width,s=i.height,r=t().Matrix(2,4,[0,0,n,0,n,s,0,s]),o=t().Matrix.Zeros(3);return this._findPolylineCoordinates(e,Z).then((e=>t().Matrix.perspective(o,r,e)))}_createPipeline(){const e=t().Pipeline(),i=t().Image.Source("source"),n=t().Image.Portal.Source("imagePortalSource"),s=t().Image.Multiplexer("sourceMux"),r=t().Transform.Resize("screen"),o=t().Filter.Greyscale(),a=t().Transform.PerspectiveWarp("imageRectifier"),c=t().Filter.Nightvision(),p=t().Image.Multiplexer(),l=t().Keypoint.Detector.Harris(),A=t().Keypoint.Descriptor.ORB(),d=t().Filter.GaussianBlur(),u=t().Keypoint.Clipper(),g=t().Keypoint.BorderClipper("borderClipper"),h=t().Filter.GaussianBlur(),I=t().Keypoint.SubpixelRefiner(),m=t().Keypoint.Matcher.BFKNN(),f=t().Keypoint.Transformer("keypointRectifier"),y=t().Keypoint.Portal.Sink("keypointPortalSink"),S=t().Keypoint.Portal.Source("keypointPortalSource"),_=t().Keypoint.Multiplexer("muxOfReferenceKeypoints"),x=t().Keypoint.Buffer("bufferOfReferenceKeypoints"),C=t().Keypoint.Multiplexer("muxOfBufferOfReferenceKeypoints"),E=t().Keypoint.SinkOfMatchedKeypoints("keypoints");t().Image.Sink("image");return i.media=null,r.size=t().Size(0,0),n.source=null,a.transform=t().Matrix.Eye(3),s.port=0,c.gain=F,c.offset=j,c.decay=0,c.quality=X,p.port=0,d.kernelSize=t().Size(9,9),d.sigma=t().Vector2(2,2),h.kernelSize=t().Size(5,5),h.sigma=t().Vector2(1,1),l.quality=.005,l.capacity=2048,I.method=U,u.size=200,g.imageSize=r.size,g.borderSize=t().Vector2(0,0),m.k=2,f.transform=t().Matrix.Eye(3),S.source=y,_.port=0,C.port=0,x.frozen=!1,E.turbo=!1,i.output().connectTo(s.input("in0")),n.output().connectTo(s.input("in1")),s.output().connectTo(r.input()),r.output().connectTo(o.input()),o.output().connectTo(a.input()),a.output().connectTo(p.input("in0")),a.output().connectTo(c.input()),c.output().connectTo(p.input("in1")),p.output().connectTo(d.input()),p.output().connectTo(l.input()),l.output().connectTo(g.input()),g.output().connectTo(u.input()),a.output().connectTo(h.input()),h.output().connectTo(I.input("image")),u.output().connectTo(I.input("keypoints")),d.output().connectTo(A.input("image")),I.output().connectTo(A.input("keypoints")),A.output().connectTo(_.input("in0")),C.output().connectTo(_.input("in1")),_.output().connectTo(m.input("database")),A.output().connectTo(m.input("keypoints")),S.output().connectTo(C.input("in0")),x.output().connectTo(C.input("in1")),S.output().connectTo(x.input()),A.output().connectTo(y.input()),A.output().connectTo(f.input()),f.output().connectTo(E.input()),m.output().connectTo(E.input("matches")),e.init(i,n,s,r,o,a,c,p,d,l,I,u,g,h,A,S,_,m,x,C,f,E,y),e}}class V extends h{constructor(e,t){super(e),this._referenceImage=t}get referenceImage(){return this._referenceImage}}const ee=(()=>{const e=[0,1,0,-1,0],t=[-1,0,1,0,0],i=e.length;return Object.freeze({x:e,y:t,a1:new Array(i),a2:new Array(i),a3:new Array(i),m:new Array(3*i*3),v:new Array(3*i),t:new Array(3),r:new Array(3*i),c:new Array(3),Mc:new Array(3*i)})})();class te{constructor(){this._screenSize=t().Size(0,0),this._matrix=t().Matrix.Eye(3,4),this._intrinsics=[1,0,0,0,1,0,0,0,1],this._extrinsics=[1,0,0,0,1,0,0,0,1,0,0,0],this._f=new Array(401).fill(this._intrinsics[4]),this._fp=0,this._partialRotationBuffer=[],this._translationBuffer=[]}init(e){if(0==e.area())throw new r(`Can't initialize the camera model with screenSize = ${e.toString()}`);this._screenSize.width=e.width,this._screenSize.height=e.height,this._resetIntrinsics(),this._resetExtrinsics(),g.log("Initializing the camera model...")}release(){return this.reset(),null}update(e,i){if(3!=e.rows||3!=e.columns)throw new r("Camera model: provide a homography matrix");if(0==i.area())throw new r(`Camera model: invalid screenSize = ${i.toString()}`);this._screenSize.equals(i)||(g.log("Camera model: detected a change in screen size..."),this._screenSize.width=i.width,this._screenSize.height=i.height,this.reset());const n=e.read(),s=n[0],o=n[3],a=n[6],c=n[1],p=n[4],l=n[7],A=n[2],d=n[5],u=a*(c*d-p*A)-l*(s*d-o*A)+n[8]*(s*p-o*c);if(Math.abs(u)<1e-6)return g.warning("Can't update the camera model using an invalid homography matrix"),t().Promise.resolve(this._matrix);const h=this._estimateFocal(e);h>0&&this._storeFocal(h);const I=this._estimatePose(e);this._storePose(I);const m=this.denormalizer(),f=t().Matrix(3,3,this._intrinsics),y=t().Matrix(3,4,this._extrinsics);return this._matrix.setToSync(f.times(y).times(m)),t().Promise.resolve(this._matrix)}reset(){this._resetIntrinsics(),this._resetExtrinsics()}get matrix(){return this._matrix}get intrinsics(){return this._intrinsics}get extrinsics(){return this._extrinsics}denormalizer(){const e=this._screenSize.width/2,i=this._screenSize.height/2,n=Math.min(e,i);return t().Matrix(4,4,[n,0,0,0,0,-n,0,0,0,0,-n,0,e,i,0,1])}denormalizerInverse(){const e=this._screenSize.width/2,i=this._screenSize.height/2,n=1/Math.min(e,i);return t().Matrix(4,4,[n,0,0,0,0,-n,0,0,0,0,-n,0,-e*n,i*n,0,1])}get screenSize(){return this._screenSize}get focalLength(){return this._intrinsics[4]}get fovx(){return 2*Math.atan(this._intrinsics[6]/this._intrinsics[0])}get fovy(){return 2*Math.atan(this._intrinsics[7]/this._intrinsics[4])}principalPoint(){return t().Point2(this._intrinsics[6],this._intrinsics[7])}_resetExtrinsics(){this._extrinsics.fill(0),this._extrinsics[0]=this._extrinsics[4]=this._extrinsics[8]=1,this._partialRotationBuffer.length=0,this._translationBuffer.length=0}_resetIntrinsics(){const e=this._screenSize.width/2,t=this._screenSize.height/2,i=t/Math.tan(.39269908169872414);this._intrinsics[0]=i,this._intrinsics[4]=i,this._intrinsics[6]=e,this._intrinsics[7]=t,this._f.fill(this._intrinsics[4]),this._fp=0}_estimateFocal(e){return 0}_storeFocal(e){this._f[this._fp]=e,this._fp=(this._fp+1)%401;const t=this._f.concat([]).sort(((e,t)=>e-t)),i=t[t.length>>>1];this._intrinsics[0]=this._intrinsics[4]=i}_normalizeHomography(e,i=this._intrinsics[4]){const n=e.read(),s=this._intrinsics[6],r=this._intrinsics[7],o=n[0]-s*n[2],a=n[3]-s*n[5],c=n[6]-s*n[8],p=n[1]-r*n[2],l=n[4]-r*n[5],A=n[7]-r*n[8],d=n[2]*i,u=n[5]*i,g=n[8]*i;return t().Matrix(3,3,[o,p,d,a,l,u,c,A,g])}_estimatePartialPose(e){const i=e.read(),n=i[0],s=i[3],r=i[6],o=i[1],a=i[4],c=i[7],p=i[2],l=i[5],A=i[8],d=A>=0?1:-1,u=Math.sqrt(n*n+o*o+p*p),g=Math.sqrt(s*s+a*a+l*l),h=d/Math.max(u,g);if(Number.isNaN(h))return t().Matrix(3,3,new Array(9).fill(Number.NaN));const I=h*r,m=h*c,f=h*A,y=h*n,S=h*o,_=h*p,x=h*s,C=h*a,E=h*l,P=this._refineRotation(y,S,_,x,C,E),v=this._refineTranslation(e,P,[I,m,f]);return t().Matrix(3,3,P.concat(v))}_refineRotation(e,i,n,s,r,o){const a=e*e+i*i+n*n,c=s*s+r*r+o*o,p=e*s+i*r+n*o,l=(a-c)*(a-c)+4*p*p,A=Math.sqrt(l),d=(a+c+A)/2,u=(a+c-A)/2,g=c-d-p*(1+p)/(a-d),h=Math.sqrt(g*g/(1+g*g)),I=h/g,m=c-u-p*(1+p)/(a-u),f=Math.sqrt(m*m/(1+m*m)),y=f/m,S=Math.sqrt(d),_=Math.sqrt(u),x=t().Matrix(2,2,[1/S,0,0,1/_]),C=t().Matrix(2,2,[h,I,f,y]),E=t().Matrix(2,2,[h,f,I,y]),P=C.times(x).times(E),v=t().Matrix(3,2,[e,i,n,s,r,o]);return t().Matrix(v.times(P)).read()}_refineTranslation(e,t,i){const n=ee,s=15;g.assert(5===n.x.length);const r=e.read(),o=r[0],a=r[3],c=r[6],p=r[1],l=r[4],A=r[7],d=r[2],u=r[5],h=r[8],I=t[0],m=t[3],f=t[1],y=t[4],S=t[2],_=t[5],x=n.x,C=n.y,E=n.a1,P=n.a2,v=n.a3;for(let e=0;e<5;e++)E[e]=x[e]*o+C[e]*a+c,P[e]=x[e]*p+C[e]*l+A,v[e]=x[e]*d+C[e]*u+h;const B=n.m,M=n.v;for(let e=0,t=0;t<5;e+=3,t++)B[e]=B[e+s+1]=B[e+s+s+2]=0,B[e+s]=-(B[e+1]=v[t]),B[e+2]=-(B[e+s+s]=P[t]),B[e+s+s+1]=-(B[e+s+2]=E[t]),M[e]=v[t]*(x[t]*f+C[t]*y)-P[t]*(x[t]*S+C[t]*_),M[e+1]=-v[t]*(x[t]*I+C[t]*m)+E[t]*(x[t]*S+C[t]*_),M[e+2]=P[t]*(x[t]*I+C[t]*m)-E[t]*(x[t]*f+C[t]*y);const w=n.t;w[0]=i[0],w[1]=i[1],w[2]=i[2];const b=n.r,Q=n.c,k=n.Mc;for(let e=0;e<3;e++){for(let e=0;e<s;e++){b[e]=0;for(let t=0;t<3;t++)b[e]+=B[t*s+e]*w[t];b[e]-=M[e]}for(let e=0;e<3;e++){Q[e]=0;for(let t=0;t<s;t++)Q[e]+=B[e*s+t]*b[t]}for(let e=0;e<s;e++){k[e]=0;for(let t=0;t<3;t++)k[e]+=B[t*s+e]*Q[t]}let e=0,t=0;for(let t=0;t<3;t++)e+=Q[t]*Q[t];for(let e=0;e<s;e++)t+=k[e]*k[e];const i=e/t;if(Number.isNaN(i))break;for(let e=0;e<3;e++)w[e]-=i*Q[e]}return w}_filterPartialPose(e){const i=new Array(9).fill(0),n=e.read(),s=n.slice(0,6),r=n.slice(6,9),o="low-power"==z.powerPreference?1.5:1,a=Math.ceil(10/o),c=Math.ceil(10/o);if(Number.isNaN(n[0])){if(0==this._partialRotationBuffer.length)return t().Matrix.Eye(3)}else this._partialRotationBuffer.unshift(s),this._partialRotationBuffer.length>a&&(this._partialRotationBuffer.length=a),this._translationBuffer.unshift(r),this._translationBuffer.length>c&&(this._translationBuffer.length=c);const p=this._partialRotationBuffer.length;for(let e=0;e<p;e++){const t=this._partialRotationBuffer[e];for(let e=0;e<6;e++)i[e]+=t[e]/p}const l=this._refineRotation(i[0],i[1],i[2],i[3],i[4],i[5]),A=this._translationBuffer.length;for(let e=0;e<A;e++){const t=this._translationBuffer[e];for(let n=0;n<3;n++)i[6+n]+=(A-e)*t[n]/((A*A+A)/2)}const d=[i[6],i[7],i[8]];return t().Matrix(3,3,l.concat(d))}_estimateFullPose(e){const i=e.read(),n=i[0],s=i[3],r=i[6],o=i[1],a=i[4],c=i[7],p=i[2],l=i[5],A=i[8];let d=o*l-p*a,u=p*s-n*l,g=n*a-o*s;return n*(a*g-u*l)-o*(s*g-d*l)+p*(s*u-d*a)<0&&(d=-d,u=-u,g=-g),t().Matrix(3,4,[n,o,p,s,a,l,d,u,g,r,c,A])}_estimatePose(e,i=this._intrinsics[4]){const n=this._normalizeHomography(e,i),s=t().Matrix.Eye(3),r=t().Matrix(n);for(let e=0;e<30;e++){const e=this._estimatePartialPose(r);s.setToSync(e.times(s)),r.setToSync(r.times(e.inverse()))}const o=this._filterPartialPose(s);return this._estimateFullPose(o)}_storePose(e){this._extrinsics=e.read()}}class ie{constructor(e){this._transform=e}get transform(){return this._transform}}class ne extends class extends class{constructor(e){if(4!=e.rows||4!=e.columns)throw new r("A 3D transform expects a 4x4 matrix");this._matrix=e}get matrix(){return this._matrix}}{}{constructor(e){super(e)}static fromMatrix(e){return new ne(e)}get inverse(){const e=this._matrix.read();if(0==e[15])throw new o("Not a rigid transform");const i=1/e[15],n=e[0]*i,s=e[4]*i,r=e[8]*i,a=e[1]*i,c=e[5]*i,p=e[9]*i,l=e[2]*i,A=e[6]*i,d=e[10]*i,u=e[12]*i,g=e[13]*i,h=e[14]*i,I=n*u+a*g+l*h,m=s*u+c*g+A*h,f=r*u+p*g+d*h,y=t().Matrix(4,4,[n,s,r,0,a,c,p,0,l,A,d,0,-I,-m,-f,1]);return new ne(y)}}class se extends ie{constructor(e){const i=se._computeViewMatrix(e),n=ne.fromMatrix(i).inverse.matrix,s=e.denormalizer(),r=e.denormalizerInverse(),o=t().Matrix(i.times(s)),a=t().Matrix(r.times(n));super(ne.fromMatrix(a)),this._viewMatrix=o}get viewMatrix(){return this._viewMatrix}static _computeViewMatrix(e){const i=e.extrinsics;return t().Matrix(4,4,[i[0],-i[1],-i[2],0,i[3],-i[4],-i[5],0,i[6],-i[7],-i[8],0,i[9],-i[10],-i[11],1])}}class re{constructor(e,t=.1,i=2e3){const n=e.intrinsics,s=e.screenSize;if(this._near=Math.max(0,+t),this._far=Math.max(0,+i),this._near>=this._far)throw new r(`View expects near < far (found near = ${this._near} and far = ${this._far})`);this._aspect=s.width/s.height,this._tanOfHalfFovy=n[7]/n[4],this._projectionMatrix=re._computeProjectionMatrix(n,this._near,this._far)}get projectionMatrix(){return this._projectionMatrix}get aspect(){return this._aspect}get fovy(){return 2*Math.atan(this._tanOfHalfFovy)}get near(){return this._near}get far(){return this._far}static _computeProjectionMatrix(e,i,n){const s=i*(e[7]/e[4]),r=i*(e[6]/e[0]),o=-s,a=-r;return t().Matrix(4,4,[2*i/(r-a),0,0,0,0,2*i/(s-o),0,0,(r+a)/(r-a),(s+o)/(s-o),-(n+i)/(n-i),-1,0,0,-2*n*i/(n-i),0])}}class oe{constructor(e){this._pose=new se(e),this._views=[new re(e)]}get pose(){return this._pose}get view(){return this._views[0]}convertToViewerSpace(e){const i=e.transform.matrix,n=this._pose.viewMatrix,s=t().Matrix(n.times(i)),r=ne.fromMatrix(s);return new ie(r)}}const ae=!0,ce=(()=>{let e=null;return()=>e=e||ne.fromMatrix(t().Matrix.Eye(4))})();class pe extends H{constructor(e){super("tracking",e),this._referenceImage=null,this._warpHomography=t().Matrix.Eye(3),this._poseHomography=t().Matrix.Eye(3),this._initialHomography=t().Matrix.Eye(3),this._initialKeypoints=[],this._counter=0,this._camera=new te,this._predictedKeypoints=[],this._lastPipelineOutput={keypoints:[]},this._pipelineCounter=0,this._lastOutput={},this._lostCounter=0,g.assert(!0)}onEnterState(e){const i=e.homography,n=e.referenceImage,s=e.templateKeypoints,r=e.keypointPortalSink,a=e.screenSize,c=this._pipeline.node("keypointPortalSource");if(!n)throw new o("Can't track a null reference image");this._referenceImage=n,this._warpHomography=t().Matrix(i),this._poseHomography=t().Matrix(i),this._initialHomography=t().Matrix(i),this._initialKeypoints=s,this._counter=0,this._predictedKeypoints=[],this._lastPipelineOutput={keypoints:[]},this._pipelineCounter=0,this._lastOutput={},this._lostCounter=0,c.source=r,this._camera.init(a);const p=new V("targetfound",n);this._imageTracker.dispatchEvent(p),g.log(`Tracking image "${n.name}"...`)}onLeaveState(){const e=this._referenceImage;this._camera.release();const t=new V("targetlost",e);this._imageTracker.dispatchEvent(t)}_beforeUpdate(){const e=this._pipeline.node("imageRectifier"),i=this._pipeline.node("borderClipper"),n=(this._pipeline.node("keypointRectifier"),this.screenSize);return i.imageSize=n,i.borderSize=t().Vector2(n.width*G,n.height*G),this._findImageWarp(this._warpHomography,n).then((t=>{e.transform=t}))}_gpuUpdate(){if("low-power"==z.powerPreference)return super._gpuUpdate();const e=this._pipelineCounter;return this._pipelineCounter=(this._pipelineCounter+1)%2,0!=e?(void 0!==this._lastPipelineOutput.keypoints?this._predictedKeypoints=this._predictKeypoints(this._lastPipelineOutput.keypoints,this._initialKeypoints):this._predictedKeypoints.length=0,this._lastPipelineOutput.keypoints=this._predictedKeypoints,t().Promise.resolve(this._lastPipelineOutput)):super._gpuUpdate().then((e=>(this._lastPipelineOutput=e,e)))}_afterUpdate(e){const i=this._pipeline.node("imageRectifier"),n=e.keypoints,s=e.image,r=this._referenceImage;return this._preprocessMatches(n,this._initialKeypoints).then((e=>t().Promise.all([this._findAffineMotion(e),this._findPerspectiveMotion(e)]))).then((([e,t])=>{const i="low-power"==z.powerPreference,n=!(i||this._counter%2==0),s=2*(i?1:2),r=s>>>1;return this._counter%s==r&&this._warpHomography.setToSync(this._warpHomography.times(e)),n||this._poseHomography.setToSync(this._warpHomography.times(t)),this._counter=(this._counter+1)%s,n?this._camera.matrix:this._camera.update(this._poseHomography,this.screenSize)})).then((e=>{const s=i.transform,r=t().Matrix(s.inverse()),o=n.length,a=new Array(2*o);for(let e=0,t=0;e<o;e++,t+=2)a[t]=n[e].position.x,a[t+1]=n[e].position.y;return t().Matrix.applyPerspectiveTransform(t().Matrix.Zeros(2,o),t().Matrix(2,o,a),r)})).then((e=>this._findPolyline(this._poseHomography,this.screenSize))).then((e=>{const t=new ie(ce()),i=new oe(this._camera),n={pose:t,referenceImage:r},o={tracker:this._imageTracker,trackables:[n],viewer:i};return this._lastOutput={exports:o,cameraMatrix:this._camera.matrix,homography:this._warpHomography,screenSize:this.screenSize,image:s,polyline:e},this._lostCounter=0,{nextState:"tracking",trackerOutput:this._lastOutput}})).catch((e=>e instanceof l&&++this._lostCounter<=10?{nextState:"tracking",trackerOutput:this._lastOutput}:(g.warning(`The target has been lost! ${e.toString()}`),this._camera.reset(),{nextState:"scanning",trackerOutput:{image:s,screenSize:this.screenSize}})))}_findQualityMatches(e,t){const i=[[],[]],n=e.length;for(let s=0;s<n;s++){const n=e[s];if(n.matches[0].index>=0&&n.matches[1].index>=0){if(n.matches[0].distance<=.75*n.matches[1].distance){const e=t[n.matches[0].index];i[0].push(n),i[1].push(e)}}}return i}_refineQualityMatches(e){const t=e[0],i=e[1],n=this._distributeKeypoints(t,10),s=n.length,r=[new Array(s),new Array(s)];for(let e=0;e<s;e++)r[0][e]=t[n[e]],r[1][e]=i[n[e]];return r}_distributeKeypoints(e,t){const i=e.length,n=new Array(2*i);for(let t=0,s=0;t<i;t++,s+=2)n[s]=e[t].x,n[s+1]=e[t].y;this._normalizePoints(n);const s=t*t,r=new Array(s).fill(-1);for(let e=0,s=0;e<i;e++,s+=2){const i=Math.floor(n[s]*t);r[Math.floor(n[s+1]*t)*t+i]=e}const o=[];for(let e=0;e<s;e++)if(r[e]>=0){const t=r[e];o.push(t)}return o}_normalizePoints(e){g.assert(e.length%2==0);const t=e.length/2;if(0==t)return e;let i=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY,s=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;for(let o=0,a=0;o<t;o++,a+=2){const t=e[a],o=e[a+1];i=t<i?t:i,s=o<s?o:s,n=t>n?t:n,r=o>r?o:r}const o=n-i+1,a=r-s+1;for(let n=0,r=0;n<t;n++,r+=2)e[r]=(e[r]-i)/o,e[r+1]=(e[r+1]-s)/a;return e}_findMatrixOfMatches(e){const i=e[0].length;g.assert(i>0);const n=e[0],s=e[1],r=new Array(2*i),o=new Array(2*i);for(let e=0,t=0;e<i;e++,t+=2)r[t]=s[e].x,r[t+1]=s[e].y,o[t]=n[e].x,o[t+1]=n[e].y;return t().Matrix(2,2*i,r.concat(o))}_preprocessMatches(e,i){const n=this._findQualityMatches(e,i),s=this._refineQualityMatches(n),r=s[0].length;if(r<4)return t().Promise.reject(new l("Not enough data to compute a motion model"));const o=this._findMatrixOfMatches(s),a=t().Matrix.Zeros(2,2*r);return this._findKeypointWarp().then((e=>t().Matrix.applyAffineTransform(a,o,e.block(0,1,0,2))))}_findAffineMotion(e){const i=t().Matrix.Eye(3),n=e.columns/2;return t().Matrix.findAffineTransform(i.block(0,1,0,2),e.block(0,1,0,n-1),e.block(0,1,n,2*n-1),{method:"pransac",reprojectionError:3,numberOfHypotheses:512,bundleSize:128}).then((e=>{const t=i.at(0,0);if(Number.isNaN(t))throw new l("Can't compute affine motion model: bad keypoints");return i}))}_findPerspectiveMotion(e){const i=t().Matrix.Zeros(3),n=e.columns/2;return t().Matrix.findHomography(i,e.block(0,1,0,n-1),e.block(0,1,n,2*n-1),{method:"pransac",reprojectionError:3,numberOfHypotheses:1024,bundleSize:512}).then((e=>{const t=i.at(0,0);if(Number.isNaN(t))throw new l("Can't compute perspective motion model: bad keypoints");return i}))}_findImageWarp(e,i){const n=this._referenceImage,s=this._imageTracker.database._findMedia(n.name),r=t().Matrix.Zeros(3);return this._findRectificationMatrixOfFullscreenImage(s,i).then((t=>r.setTo(t.times(e.inverse()))))}_findKeypointWarp(){const e=this._referenceImage,i=this._imageTracker.database._findMedia(e.name),n=this.screenSize,s=n.width,r=n.height,o=t().Matrix.Eye(3,3);return this._mustRotateWarpedImage(i,n)?t().Matrix.affine(o.block(0,1,0,2),t().Matrix(2,3,[0,r,0,0,s,0]),t().Matrix(2,3,[0,0,s,0,s,r])).then((e=>o)):t().Promise.resolve(o)}_predictKeypoints(e,t){const i=[],n=e.length;for(let s=0;s<n;s++){const n=e[s];if(n.matches[0].index<0||n.matches[1].index<0)continue;const r=t[n.matches[0].index],o=n.position.x-r.position.x,a=n.position.y-r.position.y,c=.8;n.position.x=r.position.x+c*o,n.position.y=r.position.y+c*a,i.push(n)}return i}_createPipeline(){const e=t().Pipeline(),i=t().Image.Source("source"),n=t().Transform.Resize("screen"),s=t().Filter.Greyscale(),r=t().Transform.PerspectiveWarp("imageRectifier"),o=t().Filter.Nightvision(),a=t().Image.Multiplexer(),c=t().Filter.GaussianBlur(),p=t().Keypoint.Detector.Harris(),l=t().Keypoint.Descriptor.ORB(),A=t().Keypoint.Matcher.BFKNN(),d=t().Keypoint.SubpixelRefiner(),u=t().Filter.GaussianBlur(),g=t().Keypoint.BorderClipper("borderClipper"),h=t().Keypoint.Clipper(),I=t().Keypoint.Transformer("keypointRectifier"),m=t().Keypoint.Portal.Source("keypointPortalSource"),f=t().Keypoint.SinkOfMatchedKeypoints("keypoints");t().Image.Sink("image");return i.media=null,n.size=t().Size(0,0),r.transform=t().Matrix.Eye(3),o.gain=F,o.offset=j,o.decay=0,o.quality=X,a.port=0,c.kernelSize=t().Size(9,9),c.sigma=t().Vector2(2,2),u.kernelSize=t().Size(5,5),u.sigma=t().Vector2(1,1),p.quality=.005,p.capacity=2048,d.method=U,h.size=200,g.imageSize=n.size,g.borderSize=t().Vector2(0,0),I.transform=t().Matrix.Eye(3),A.k=2,m.source=null,f.turbo=ae,i.output().connectTo(n.input()),n.output().connectTo(s.input()),s.output().connectTo(r.input()),r.output().connectTo(a.input("in0")),r.output().connectTo(o.input()),o.output().connectTo(a.input("in1")),a.output().connectTo(p.input()),p.output().connectTo(g.input()),g.output().connectTo(h.input()),r.output().connectTo(u.input()),u.output().connectTo(d.input("image")),h.output().connectTo(d.input("keypoints")),r.output().connectTo(c.input()),c.output().connectTo(l.input("image")),d.output().connectTo(l.input("keypoints")),m.output().connectTo(A.input("database")),l.output().connectTo(A.input("keypoints")),l.output().connectTo(I.input()),I.output().connectTo(f.input()),A.output().connectTo(f.input("matches")),e.init(i,n,s,r,o,a,c,p,d,g,h,u,l,A,m,I,f),e}}class le extends I{constructor(){super(),this._state={initial:new W(this),training:new q(this),scanning:new J(this),"pre-tracking":new $(this),tracking:new pe(this)},this._session=null,this._activeStateName="initial",this._lastOutput={},this._database=new R,this._resolution="sm+"}get type(){return"image-tracker"}get state(){return this._activeStateName}get database(){return this._database}get resolution(){return this._resolution}set resolution(e){this._resolution=e}get screenSize(){return this._state[this._activeStateName].screenSize}get _output(){return this._lastOutput}get _stats(){return`${e=this.screenSize,`${e.width}x${e.height}`} ${this.state}`;var e}_init(e){this._session=e;for(const e of Object.values(this._state))e.init();return t().Promise.resolve()}_release(){for(const e of Object.values(this._state))e.release();return this._session=null,t().Promise.resolve()}_update(){if(null==this._session)return t().Promise.reject(new o("Uninitialized tracker"));const e=this._session.media,i=e.width/e.height,n=g.resolution(this._resolution,i),s=this._state[this._activeStateName];return s.update(e,n).then((({trackerOutput:e,nextState:t,nextStateSettings:i})=>{this._lastOutput=e,this._activeStateName!=t&&(s.onLeaveState(),this._activeStateName=t,this._state[t].onEnterState(i||{}))}))}_referenceImageOfKeypoint(e){return this._state.training.referenceImageOfKeypoint(e)}_referenceImageIndexOfKeypoint(e){return this._state.training.referenceImageIndexOfKeypoint(e)}_referenceKeypoint(e){return this._state.training.referenceKeypoint(e)}}class Ae{static ImageTracker(){return new le}}class de{constructor(e){this._media=null,this._source=e}get _type(){return"video"}get _data(){if(null==this._media)throw new o("The media of the source of data isn't loaded");return this._media}_init(){return t().load(this._source).then((e=>{g.log(`Source of data is ${e.width}x${e.height}`),this._media=e}))}_release(){return this._media&&this._media.release(),this._media=null,t().Promise.resolve()}get _size(){const e=this._media;return null!=e?`${e.width}x${e.height}`:"-"}}class ue extends de{constructor(e){g.assert(e instanceof HTMLVideoElement,"Expected a video element"),super(e)}get _stats(){return`${this._size} video`}}class ge extends de{constructor(e){g.assert(e instanceof HTMLCanvasElement,"Expected a canvas element"),super(e)}get _stats(){return`${this._size} canvas`}}const he={resolution:"md",aspectRatio:16/9,constraints:{facingMode:"environment"}};class Ie extends ue{constructor(e){const t=document.createElement("video");super(t),this._video=t,this._options=Object.assign({},he,e)}get resolution(){return this._options.resolution}get _stats(){return`${this._size} webcam`}_init(){if(g.log("Accessing the webcam..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new a("Unsupported browser: no navigator.mediaDevices.getUserMedia()");const e=this._options,i=g.resolution(e.resolution,e.aspectRatio),n={audio:!1,video:Object.assign({width:i.width,height:i.height},e.constraints)};return new(t().Promise)(((e,t)=>{navigator.mediaDevices.getUserMedia(n).then((t=>{const i=this._video;i.onloadedmetadata=()=>{i.play(),g.log("Access to the webcam has been granted."),e(i)},i.srcObject=t,i.muted=!0})).catch((e=>{t(new c("Please give access to the webcam and reload the page.",e))}))})).then((e=>super._init()))}_release(){return this._video.srcObject.getTracks().forEach((e=>e.stop())),this._video.onloadedmetadata=null,this._video.srcObject=null,super._release()}}class me{static Video(e){return new ue(e)}static Canvas(e){return new ge(e)}static Camera(e={}){return new Ie(e)}}class fe{static startSession(e){return L.instantiate(e)}static get Tracker(){return Ae}static get Source(){return me}static Viewport(e){return new S(e)}static get Settings(){return z}static get version(){return"0.1.0"}static get edition(){return"Free Edition"}static get Speedy(){return t()}static isSupported(){return L.isSupported()}}Object.freeze(fe),(e=>{e.Speedy=e.Speedy||t()})(window),g.log(`MARTINS.js ${fe.edition} version ${fe.version}. GPU-accelerated Augmented Reality for the web by Alexandre Martins. https://github.com/alemart/martins-js`)})(),n=n.default})()}));